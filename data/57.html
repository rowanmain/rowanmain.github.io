<!DOCTYPE html><html lang="ru"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>book</title></head><body>Если вы пишете только одно приложение и не для предприятия, эти сущ-

ности становятся бизнес-объектами приложения . Они инкапсулируют 

наиболее общие и высокоуровневые правила . Их изменение маловероятно 

под влиянием внешних изменений . Например, трудно представить, что эти 

объекты изменятся из-за изменения структуры навигации или безопасности 

страницы . Никакие изменения в работе любого конкретного приложения не 

должны влиять на уровень сущностей .

Варианты использования

Программное обеспечение на уровне вариантов использования содержит 

бизнес-правила, характерные для приложения . Оно инкапсулирует и ре-

ализует все варианты использования системы . Варианты использования 

организуют поток данных в сущности и из них и требуют от этих сущностей 

использовать их критические бизнес-правила для достижения своих целей .

Изменения внутри этого уровня не должны влиять на сущности . Аналогич-

но изменения во внешних уровнях, например в базе данных, пользователь-

ском интерфейсе или в любом из общих фреймворков, не должны влиять 

на этот уровень . Уровень вариантов использования изолирован от таких 

проблем .

Но изменения в работе приложения безусловно повлияют на варианты ис-

пользования и, соответственно, на программное обеспечение, находящееся 

на этом уровне . Изменение деталей вариантов использования определенно 

затронет некоторый код на этом уровне .

Адаптеры интерфейсов

Программное обеспечение на уровне адаптеров интерфейсов — это набор 

адаптеров, преобразующих данные из формата, наиболее удобного для 

206   Глава 22. Чистая архитектура

вариантов использования и сущностей, в формат, наиболее удобный для 

некоторых внешних агентов, таких как база данных или веб-интерфейс . 

Именно на этом уровне целиком находится архитектура MVC графического 

пользовательского интерфейса . Презентаторы, представления и контрол-

леры — все принадлежат уровню адаптеров интерфейсов . Модели — часто 

лишь структуры данных, которые передаются из контроллеров в варианты 

использования и затем обратно из вариантов использования в презентаторы 

и представления .

Аналогично на этом уровне преобразуются данные из формата, наиболее 

удобного для вариантов использования и сущностей, в формат, наиболее 

удобный для инфраструктуры хранения данных (например, базы данных) . 

Никакой код, находящийся в других внутренних кругах, не должен ничего 

знать о базе данных . Если данные хранятся в базе данных SQL, тогда весь 

код на языке SQL должен находиться именно на этом уровне, точнее, в эле-

ментах этого уровня, связанных с базой данных .

Также в этом уровне находятся любые другие адаптеры, необходимые для 

преобразования данных из внешнего формата, например полученных от 

внешней службы, во внутренний, используемый вариантами использования 

и сущностями .

Фреймворки и драйверы

Самый внешний уровень модели на рис . 22 .1 обычно состоит из фреймвор-

ков и инструментов, таких как база данных и веб-фреймворк . Как правило, 

для этого уровня требуется писать не очень много кода, и обычно этот код 

играет роль связующего звена со следующим внутренним кругом .

На уровне фреймворков и драйверов сосредоточены все детали . Веб-

интерфейс — это деталь . База данных — это деталь . Все это мы храним во 

внешнем круге, где они не смогут причинить большого вреда .

Толька четыре круга?

Круги на рис . 22 .1 лишь схематически изображают основную идею: иногда 

вам может понадобиться больше четырех кругов . Фактически нет никако-

го правила, утверждающего, что кругов должно быть именно четыре . Но 

всегда действует правило зависимостей . Зависимости в исходном коде 

всегда должны быть направлены внутрь . По мере движения внутрь уро-

вень абстракции и политик увеличивается . Самый внешний круг включает 

низкоуровневые конкретные детали . По мере приближения к центру про-

Правило зависимостей      207

граммное обеспечение становится все более абстрактным и инкапсулирует 

все более высокоуровневые политики . Самый внутренний круг является 

самым обобщенным и находится на самом высоком уровне .

Пересечение границ

Справа внизу на рис . 22 .1 приводится пример пересечения границ кругов . 

На нем изображены контроллеры и презентаторы, взаимодействующие 

с вариантами использования на следующем уровне . Обратите внимание на 

поток управления: он начинается в контроллере, проходит через вариант 

использования и завершается в презентаторе . Отметьте также, как направ-

лены зависимости в исходном коде: каждая указывает внутрь, на варианты 

использования .

Обычно мы разрешаем это кажущееся противоречие с использованием 

принципа инверсии зависимостей (Dependency Inversion Principle) . В таких 

языках, как Java, например, мы можем определять интерфейсы и использо-

вать механизм наследования, чтобы направление зависимостей в исходном 

коде было противоположно направлению потока управления на границах 

справа .

Допустим, что вариант использования должен вызвать презентатора . Такой 

вызов нельзя выполнить непосредственно, потому что иначе нарушится 

правило зависимостей: никакие имена, объявленные во внешних кругах, 

не должны упоминаться во внутренних . Поэтому вариант использования 

должен вызвать интерфейс (на рис . 22 .1 подписан как «Порт вывода вари-

анта использования»), объявленный во внутреннем круге, а презентатор во 

внешнем круге должен реализовать его .

Тот же прием используется для всех пересечений границ в архитектуре . Мы 

используем преимущество динамического полиморфизма, чтобы обратить 

зависимости в исходном коде в направлении, противоположном потоку 

управления, и тем самым соблюсти правило зависимостей при любом на-

правлении потока управления .

Какие данные пересекают границы

Обычно через границы данные передаются в виде простых структур . При 

желании можно использовать простейшие структуры или объекты переда-

чи данных (Data Transfer Objects; DTO) . Данные можно также передавать 

в вызовы функций через аргументы . Или упаковывать их в ассоциативные 

массивы или объекты . Важно, чтобы через границы передавались простые, 

208   Глава 22. Чистая архитектура

изолированные структуры данных . Не нужно хитрить и передавать объекты 

сущностей или записи из базы данных . Структуры данных не должны на-
</body></html>