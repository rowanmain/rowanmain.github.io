<!DOCTYPE html><html lang="ru"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>book</title></head><body>Принцип согласованного изменения

В один компонент должны включаться классы, изменяющиеся по одним при-

чинам и в одно время. В разные компоненты должны включаться классы, из-

меняющиеся в разное время и по разным причинам.

Это принцип единственной ответственности (SRP), перефразированный 

для компонентов . Так же, как принцип SRP, гласящий, что класс не должен 

иметь нескольких причин для изменения, принцип согласованного изме-

нения (CCP) требует, чтобы компонент не имел нескольких причин для 

изменения .

Для большинства приложений простота сопровождения важнее возмож-

ности повторного использования . Если возникнет необходимость изменить 

116   Глава 13. Связность компонентов

код приложения, предпочтительнее, если все изменения будут сосредото-

чены в одном месте, а не разбросаны по нескольким компонентам1 . Если 

изменения ограничиваются единственным компонентом, нам потребуется 

развернуть только один, изменившийся компонент . Другие компоненты, не 

зависящие от измененного, не придется повторно проверять и развертывать .

Принцип CCP требует от нас собирать вместе все классы, которые может 

понадобиться изменить по одной, общей причине . Если два класса тесно 

связаны, физически или концептуально, настолько, что всегда будут изме-

няться вместе, они должны принадлежать одному компоненту . Это поможет 

уменьшить трудозатраты, имеющие отношение к повторному выпуску, те-

стированию и развертыванию программного обеспечения .

Этот принцип тесно связан с принципом открытости/закрытости (Open 

Closed Principle; OCP) . Фактически он означает «закрытость» в смысле 

принципа OCP . Принцип открытости/закрытости (OCP) требует, чтобы 

классы были закрыты для изменений, но открыты для расширения . Так как 

100% закрытость невозможна, она должна носить скорее стратегический 

характер . Мы проектируем свои классы так, чтобы они были закрыты для 

изменений, наиболее типичных из ожидаемых по опыту .

Принцип согласованного изменения (CCP) развивает эту идею, предпи-

сывая объединять в один компонент только классы, закрытые для одного 

и того же вида изменений . То есть увеличивает вероятность, что изменение 

требований повлечет необходимость изменения минимального количества 

компонентов .

Сходство с принципом единственной 

ответственности

Как отмечалось выше, принцип согласованного изменения (CCP) есть 

форма принципа единственной ответственности (SRP) для компонентов . 

Принцип SRP требует выделять методы в разные классы, если они изменя-

ются по разным причинам .

Принцип CCP аналогично требует выделять классы в разные компоненты, 

если они изменяются по разным причинам . Оба принципа можно привести 

к общей формуле:

Собирайте вместе все, что изменяется по одной причине и в одно время. Раз-

деляйте все, что изменяется в разное время и по разным причинам.

1 См . раздел «Проблема с животными» в главе 27 «Службы: большие и малые» .

Принцип совместного повторного использования      117

Принцип совместного повторного 

использования

Не вынуждайте пользователей компонента зависеть от того, чего им 

не требуется.

Принцип совместного повторного использования (Common Reuse Principle; 

CRP) — еще один принцип, помогающий определять, какие классы и модули 

должны включаться в компонент . Он указывает, что в компонент должны 

включаться классы и модули, используемые совместно .

Классы редко используются по отдельности . Обычно многократно ис-

пользуемые классы взаимодействуют с другими классами, являющимися 

частью многократно используемой абстракции . Принцип CRP указывает, 

что такие классы должны включаться в один компонент . Мы надеемся 

увидеть в компонентах классы, имеющие множественные зависимости 

друг от друга .

Простейшим примером могут служить класс коллекции и связанные с ним 

итераторы . Эти классы используются вместе, потому что они тесно связаны 

друг с другом . Соответственно, должны находиться в одном компоненте .

Но принцип CRP говорит не только о том, какие классы должны вклю-

чаться в компонент; он также сообщает, какие классы не должны объ-

единяться . Когда один компонент использует другой компонент, между 

ними образуется зависимость . Использующий компонент может нуждаться 

только в одном классе из используемого компонента, но это не ослабляет 

зависимости . Использующий компонент все так же зависит от используе-

мого компонента .

Из-за этой зависимости изменение используемого компонента часто влечет 

необходимость соответствующих изменений в использующем компоненте . 

Даже если в использующем компоненте ничего не нужно изменять, его 

почти наверняка потребуется повторно скомпилировать, протестировать 

и развернуть . Это верно, даже если реализация использующего компонента 

совершенно не зависит от изменений в используемом компоненте .

То есть когда образуется зависимость от компонента, желательно, чтобы она 

распространялась на все классы в этом компоненте . Иначе говоря, классы, 

включаемые в компонент, должны быть неотделимы друг от друга — чтобы 

нельзя было зависеть от одних и не зависеть от других . Иначе нам придется 

повторно развертывать больше компонентов, чем требуется, и тратить су-

щественно больше усилий .

118   Глава 13. Связность компонентов

Итак, принцип совместного повторного использования (CRP) в большей 

степени говорит о том, какие классы не должны объединяться, чем какие 

должны объединяться . Принцип CRP указывает, что классы, не имеющие 

тесной связи, не должны включаться в один компонент .

Связь с принципом разделения интерфейсов

Принцип совместного повторного использования (CRP) является обоб-

щенной версией принципа разделения интерфейсов (ISP) . Принцип ISP 

советует не создавать зависимостей от классов, методы которых не исполь-

зуются . Принцип CRP советует не создавать зависимостей от компонентов, 

имеющих неиспользуемые классы .

Обобщая, эти советы можно объединить в один:

Не создавайте зависимостей от чего-либо неиспользуемого.

Диаграмма противоречий 

для определения связности 

компонентов
</body></html>