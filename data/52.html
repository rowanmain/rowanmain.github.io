<!DOCTYPE html><html lang="ru"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>book</title></head><body>Служба или локальный процесс чаще имеют форму монолита, составленно-

го из исходных кодов компонентов, или группы динамически подключаемых 

компонентов развертывания .

Это означает, что границы в системе часто будут представлены смесью 

локальных границ (недорогих в пересечении) и границ, страдающих за-

держками .

19 Политика и уровень

Уровень      187

Программные системы — это заявления о направлении действий . Факти-

чески любая компьютерная программа является таким заявлением . Ком-

пьютерная программа — это подробное описание политики преобразования 

входных данных в выходные .

В большинстве нетривиальных систем общую политику можно разбить на 

множество более мелких заявлений . Некоторые из этих заявлений могут 

описывать действие конкретных бизнес-правил . Другие могут определять 

оформление отчетов . А третьи — описывать порядок проверки входных 

данных .

Отчасти искусство создания программных архитектур заключается в отде-

лении этих политик друг от друга и их перегруппировке с учетом способов 

их изменения . Политики, изменяющиеся по одинаковым причинам и в одно 

время, находятся на одном уровне и принадлежат одному компоненту . По-

литики, изменяющиеся по разным причинам или в разное время, находятся 

на разных уровнях и должны помещаться в разные компоненты .

Искусство создания программных архитектур нередко связано с организа-

цией перегруппированных компонентов в ориентированный ациклический 

граф . Узлами такого графа являются компоненты, содержащие политики 

одного уровня . А ориентированными ребрами — зависимости между ком-

понентами . Они соединяют компоненты, находящиеся на разных уровнях .

К ним относятся зависимости на уровне исходного кода или времени компи-

ляции . В Java они выражаются инструкциями import . В C# — инструкциями 

using . В Ruby — инструкциями require . Все эти зависимости необходимы 

компилятору для выполнения своей работы .

В хорошей архитектуре направление этих зависимостей обусловлено уров-

нем компонентов, которые они соединяют . В любом случае низкоуровневые 

компоненты проектируются так, чтобы они зависели от высокоуровневых 

компонентов .

Уровень

Термин «уровень» имеет строгое определение: «удаленность от ввода и вы-

вода» . Чем дальше политика от ввода и вывода, тем выше ее уровень . Поли-

тики, управляющие вводом и выводом, являются самыми низкоуровневыми 

в системе .

Диаграмма потоков данных на рис . 19 .1 соответствует простой программе 

шифрования, которая читает символы из устройства ввода, преобразует 

188   Глава 19. Политика и уровень

их с использованием таблицы и записывает преобразованные символы 

в устройство вывода . Направления потоков данных показаны на диаграмме 

извилистыми сплошными стрелками . Правильно спроектированные зави-

симости в исходном коде показаны пунктирными стрелками .

Преобразование

Чтение символа

Запись символа

зависи-

мости

в исходном 

коде

символ

Таблица

символ

Рис. 19.1. Простая программа шифрования

Компонент, выполняющий преобразование, — это самый высокоуровневый 

компонент в данной системе, потому что он дальше других находится от 

ввода и вывода1 .

Обратите внимание, что потоки данных и зависимости в исходном коде не 

всегда указывают в одном направлении . Это тоже один из элементов искус-

ства создания программных архитектур . Мы должны отделить зависимости 

в исходном коде от потоков данных и связать с уровнем .

Мы легко могли бы создать неправильную архитектуру, реализовав про-

грамму так:

function encrypt() {

  while(true)

    writeChar(translate(readChar()));

}

Это неправильная архитектура, потому что высокоуровневая функция 

encrypt зависит от низкоуровневых функций readChar и writeChar .

1 Меилир Пейдж-Джонс (Meilir Page-Jones) назвал этот компонент «центральным пре-

образованием» в своей книге The Practical Guide to Structured Systems Design, 2nd ed ., 

Yourdon Press, 1988 .

Уровень      189

Более удачная архитектура для этой системы изображена на рис . 19 .2 . 

Обратите внимание на пунктирную границу, окружающую класс Encrypt, 

и интерфейсы CharWriter и CharReader . Все зависимости, пересекающие гра-

ницу, указывают внутрь . Этот модуль является элементом высшего уровня 

в системе .

Рис. 19.2. Диаграмма классов, демонстрирующая  

более удачную архитектуру для системы

На диаграмме также изображены классы ConsoleReader и ConsoleWriter . Они 

находятся на более низком уровне, потому что расположены ближе к вводу 

и выводу .

Обратите внимание, как эта структура отделяет высокоуровневую политику 

шифрования от низкоуровневых политик ввода/вывода . Это позволяет ис-

пользовать политику шифрования в широком диапазоне контекстов . Когда 

в политиках ввода и вывода происходят изменения, они никак не затраги-

вают политику шифрования .

Помните, что политики группируются в компоненты по способам из-

менения . Политики, изменяющиеся по одним причинам и в одно время, 

объединяются в соответствии с принципами единственной ответствен-

ности (SRP) и согласованного изменения (CCP) . Чем дальше политика 

от ввода и вывода, тем выше ее уровень и тем реже она изменяется и по 

более важным причинам . Чем ближе политика к вводу и выводу, тем ниже 

ее уровень и тем чаще она изменяется и по более неотложным, но менее 
</body></html>