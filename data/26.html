<!DOCTYPE html><html lang="ru"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>book</title></head><body>Заключение

Принцип открытости/закрытости — одна из движущих сил в архитектуре 

систем . Его цель — сделать систему легко расширяемой и обезопасить ее от 

влияния изменений . Эта цель достигается делением системы на компоненты 

и упорядочением их зависимостей в иерархию, защищающую компоненты 

уровнем выше от изменений в компонентах уровнем ниже .

9

Принцип подстановки 

Барбары Лисков

92   Глава 9. Принцип подстановки Барбары Лисков

В 1988 году Барбара Лисков написала следующие строки с формулировкой 

определения подтипов .

Здесь требуется что-то вроде следующего свойства подстановки: если для 

каждого объекта o1 типа S существует такой объект o2 типа T, что для 

всех программ P, определенных в терминах T, поведение P не изменяется при 

подстановке o1 вместо o2, то S является подтипом T1.

Чтобы понять эту идею, известную как принцип подстановки Барбары Ли-

сков (Liskov Substitution Principle; LSP), рассмотрим несколько примеров .

Руководство по использованию 

наследования

Представьте, что у нас есть класс с именем License, как показано на рис . 9 .1 . 

Этот класс имеет метод с именем calcFee(), который вызывается приложе-

нием Billing . Существует два «подтипа» класса License: PersonalLicense 

и BusinessLicense . Они реализуют разные алгоритмы расчета лицензионных 

отчислений .

Рис. 9.1. Класс License и его производные, соответствующие принципу LSP

Этот дизайн соответствует принципу подстановки Барбары Лисков, потому 

что поведение приложения Billing не зависит от использования того или 

иного подтипа . Оба подтипа могут служить заменой для типа License .

Проблема квадрат/прямоугольник

Классическим примером нарушения принципа подстановки Барбары Ли-

сков может служить известная проблема квадрат/прямоугольник (рис . 9 .2) .

1 Barbara Liskov . Data Abstraction and Hierarchy, SIGPLAN Notices 23, 5 (May 1988) .

LSP и архитектура      93

Рис. 9.2. Известная проблема квадрат/прямоугольник

В этом примере класс Square (представляющий квадрат) неправильно 

определен как подтип класса Rectangle (представляющего прямоугольник), 

потому что высоту и ширину прямоугольника можно изменять независимо; 

а высоту и ширину квадрата можно изменять только вместе . Поскольку 

класс User полагает, что взаимодействует с экземпляром Rectangle, его легко 

можно ввести в заблуждение, как демонстрирует следующий код:

Rectangle r = ...

r.setW(5);

r.setH(2);

assert(r.area() == 10);

Если на место ... подставить код, создающий экземпляр Square, тогда 

проверка assert потерпит неудачу . Единственный способ противостоять 

такому виду нарушений принципа LSP — добавить в класс User механизм 

(например, инструкцию if), определяющий ситуацию, когда прямоуголь-

ник фактически является квадратом . Так как поведение User зависит от ис-

пользуемых типов, эти типы не являются заменяемыми (совместимыми) .

LSP и архитектура

На заре объектно-ориентированной революции принцип LSP рассматри-

вался как руководство по использованию наследования, как было показано 

в предыдущих разделах . Но со временем LSP был преобразован в более 

широкий принцип проектирования программного обеспечения, который 

распространяется также на интерфейсы и реализации .

Подразумеваемые интерфейсы могут иметь множество форм . Это могут 

быть интерфейсы в стиле Java, реализуемые несколькими классами . Или 

это может быть группа классов на языке Ruby, реализующих методы с оди-

94   Глава 9. Принцип подстановки Барбары Лисков

наковыми сигнатурами . Или это может быть набор служб, соответствующих 

общему интерфейсу REST .

Во всех этих и многих других ситуациях применим принцип LSP, потому что 

существуют пользователи, зависящие от четкого определения интерфейсов 

и замещаемости их реализаций .

Лучший способ понять значение LSP с архитектурной точки зрения — по-

смотреть, что случится с архитектурой системы при нарушении принципа .

Пример нарушения LSP

Допустим, что мы взялись за создание приложения, объединяющего не-

сколько служб, предоставляющих услуги такси . Клиенты, как предпола-

гается, будут использовать наш веб-сайт для поиска подходящего такси, 

независимо от принадлежности к той или иной компании . Как только 

клиент подтверждает заказ, наша система передает его выбранному такси, 

используя REST-службу .

Теперь предположим, что URI службы является частью информации, хра-

нящейся в базе данных водителей . Выбрав водителя, подходящего для 

клиента, наша система извлекает URI из записи с информацией о водителе 

и использует ее для передачи заказа этому водителю .

Допустим, что для водителя с именем Bob адрес URI отправки заказа вы-

глядит так:

purplecab.com/driver/Bob

Наша система добавит в конец этого URI информацию о заказе и пошлет 

его методом PUT:

purplecab.com/driver/Bob

       /pickupAddress/24 Maple St.

       /pickupTime/153

       /destination/ORD

Это явно означает, что все службы должны соответствовать общему 

интерфейсу REST . Они должны единообразно интерпретировать поля 

pickupAddress, pickupTime и destination .

Теперь предположим, что компания такси Acme наняла несколько про-

граммистов, которые ознакомились со спецификацией недостаточно вни-

мательно . Они сократили имя поля destination до dest . Компания Acme — 

Заключение      95

крупнейшая компания такси в нашем регионе, и бывшая жена президента 

компании Acme вышла замуж за президента нашей компании, и . . . В общем, 

вы поняли . Что может произойти с архитектурой нашей системы?

Очевидно, мы должны бы добавить особый случай . Запрос с заказом для 

любого водителя из Acme должен бы конструироваться в соответствии 
</body></html>