<!DOCTYPE html><html lang="ru"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>book</title></head><body>Компиляторам требовалось выполнить несколько проходов по исходному 

коду, но памяти было недостаточно, чтобы уместить в ней весь исходный 

код . Как следствие, компилятору приходилось несколько раз читать исход-

ный код, используя медленные устройства .

Это требовало много времени, и чем больше была библиотека, тем дольше 

работал компилятор . Компиляция большой программы могла длиться часами .

Чтобы сократить время компиляции, программисты отделяли исходный 

код библиотек от приложений . Компилировали эти библиотеки отдельно 

и загружали готовый двоичный код в известный адрес — например, 20008 . 

Они создавали таблицу символов для библиотеки и компилировали ее со 

своим прикладным кодом . Когда им требовалось запустить приложение, 

они загружали двоичный код библиотеки2, а затем загружали приложение . 

Память была организована, как показано на рис . 12 .1 .

1 Мой первый работодатель хранил в шкафу несколько десятков колод перфокарт 

с исходным кодом библиотек подпрограмм . Когда кто-то писал новую программу, он 

просто брал требуемую колоду и добавлял ее в конец колоды со своей программой .

2 В действительности на многих старых ЭВМ использовалась энергонезависимая опе-

ративная память, которая не очищалась при выключении питания . Поэтому мы часто 

в течение нескольких дней использовали библиотеку, загруженную однажды .

Краткая история компонентов      109

Приложение

Библиотека функций

Рис. 12.1. Организация памяти на заре программирования

Такой прием прекрасно работал, пока приложение умещалось в объем между 

адресами 00008 и 17778 . Но если размер приложения оказывался больше от-

веденного адресного пространства, программисту приходилось разбивать 

программу на два сегмента, располагавшихся по обеим сторонам сегмента 

с библиотекой (рис . 12 .2) .

Приложение...

...Приложение

Библиотека функций

Рис. 12.2. Деление приложения на два сегмента

Очевидно, что так не могло продолжаться вечно . Добавляя новые функции 

в библиотеку, программисты выходили за границы объема, отведенного для 

110   Глава 12. Компоненты

нее, и были вынуждены выделять дополнительный сегмент (в этом при-

мере начинающийся с адреса 70008) . Такое фрагментирование программ 

и библио тек продолжалось с увеличением объемов памяти в компьютерах .

Совершенно понятно, что с этим нужно было что-то делать .

Перемещаемость

Решение проблемы было найдено в создании перемещаемого двоичного 

кода . Идея была проста . Компилятор изменили так, чтобы он производил 

двоичный код, который мог перемещаться в памяти специальным загрузчи-

ком . Этому загрузчику можно было сообщить, с какого адреса тот должен 

загрузить перемещаемый код . Код снабжался флагами, сообщающими 

загрузчику, какие части загружаемых данных нужно изменить, чтобы за-

грузить в выбранный адрес . Обычно это означало простое добавление на-

чального адреса к любым ссылкам в двоичном коде .

Теперь программист мог указать загрузчику начальный адрес для загруз-

ки библиотеки и адрес для загрузки приложения . Фактически загрузчик 

мог принять несколько фрагментов двоичного кода и просто загрузить их 

в память друг за другом, корректируя адреса ссылок в них . Это позволило 

программистам загружать только необходимые функции .

В компилятор также была встроена возможность, позволяющая генериро-

вать имена функций в виде метаданных . Если программа вызывала библио-

течную функцию, компилятор определял ее имя как внешнюю ссылку . Если 

программа объявляла библиотечную функцию, компилятор определял ее 

имя как внешнее определение . После этого, зная адреса загрузки функций, 

загрузчик связывал внешние ссылки с внешними определениями .

Так родился связывающий загрузчик .

Компоновщики

Связывающий загрузчик дал программистам возможность делить свои 

программы на сегменты, компилируемые и загружаемые по отдельности . 

Такое решение оставалось жизнеспособным, пока относительно небольшие 

программы компоновались с относительно небольшими библиотеками . 

Однако в конце 1960-х — начале 1970-х годов программисты стали более 

честолюбивыми и их программы значительно выросли в размерах .

Компоновщики      111

В результате связывающий загрузчик оказался слишком медлительным . 

Библиотеки хранились на устройствах с медленным доступом, таких как 

накопители на магнитной ленте . Даже дисковые устройства в ту пору были 

слишком медленными . Связывающие загрузчики должны были читать 

с этих медленных устройств десятки, а то и сотни библиотек в двоичном 

коде и корректировать внешние ссылки . С увеличением размеров программ 

и количества функций в библиотеках связывающему загрузчику часто тре-

бовалось больше часа, чтобы загрузить программу .

В конечном итоге загрузка и компоновка (связывание) были разделены на 

два отдельных этапа . Программисты выделили самый медленный этап — 

этап компоновки (связывания) — в отдельное приложение, получившее 

название компоновщик, или редактор связей (linker) . В результате работы 

компоновщика получался скомпонованный и перемещаемый двоичный код, 

который загружался загрузчиком очень быстро . Это позволило програм-

мистам создавать выполняемый код, используя медленный компоновщик, 

который можно было быстро загрузить в любой момент .

Затем наступили 1980-е годы . Программисты писали программы на высоко-

уровневых языках, таких как C . С ростом их амбиций росли и создаваемые 

ими программы . Программы с сотнями и тысячами строк кода стали обыч-

ным делом .

Модули с исходным кодом в файлах .c компилировались в файлы .o и затем 

передавались компоновщику для создания выполняемых файлов, которые 

можно было быстро загрузить . Компиляция каждого отдельного модуля 

выполнялась относительно быстро, но компиляция всех модулей порой тре-

бовала значительного времени . Для корректировки связей компоновщику 

могло потребоваться еще больше времени . Во многих случаях длительность 

этого процесса снова стала достигать часа и даже больше .

Казалось, что программисты обречены всю жизнь ходить по кругу . Все 

усилия, сделанные в 1960-х, 1970-х и 1980-х годах для достижения высокой 

скорости рабочего процесса, пошли прахом из-за амбиций программистов, 

создававших большие программы . Казалось, нет выхода из замкнутого 

круга многочасового ожидания . Этап загрузки выполнялся быстро, но этап 
</body></html>