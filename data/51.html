<!DOCTYPE html><html lang="ru"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>book</title></head><body>противоположном потоку управления

Даже в монолитном, статически скомпонованном выполняемом файле та-

кой вид организационного разделения значительно помогает в разработке, 

тестировании и развертывании проекта . Команды разработчиков могут 

трудиться независимо друг от друга и не наступая друг другу на пятки . 

Высокоуровневые компоненты остаются независимыми от низкоуровневых 

деталей .

Взаимодействия между компонентами в монолите протекают быстро и эф-

фективно . Обычно они сводятся к простым вызовам функций . Как след-

ствие, взаимодействия через границы, проведенные на уровне исходного 

кода, могут быть очень обширными .

Поскольку для развертывания монолита обычно требуется выполнить ком-

пиляцию и статическую компоновку, компоненты в таких системах часто 

поставляются в исходном коде .

Компоненты развертывания

Простейшим примером физического представления архитектурной грани-

цы может служить динамическая библиотека DLL в  .Net, jar-файл в Java, 

gem-файл в Ruby или разделяемая библиотека (.so) в UNIX . Развертыва-

Локальные процессы      183

ние в этом случае не связано с компиляцией — компоненты поставляются 

в двоичном виде или в иной форме, пригодной к непосредственному раз-

вертыванию . Это режим разделения на уровне развертывания . Акт развер-

тывания заключается в простой сборке единиц развертывания в удобную 

форму, например WAR-файл, или даже в обычном копировании файлов 

в каталог .

Кроме этого единственного исключения, компоненты уровня развертыва-

ния остаются теми же, что и в монолите . Все функции обычно действуют 

в одном процессе и в общем адресном пространстве . Стратегии разделения 

компонентов и управления их зависимостями не меняются1 .

Так же как в монолите, взаимодействия между границами развертываемых 

компонентов часто осуществляются посредством вызовов функций и, со-

ответственно, обходятся очень дешево . Динамическая компоновка или 

загрузка во время выполнения могут однократно увеличивать потребление 

вычислительных ресурсов, но сами взаимодействия через границы все еще 

могут быть очень обширными .

Потоки выполнения

Монолиты и компоненты развертывания могут выполняться в многопоточ-

ном режиме . Потоки выполнения не являются архитектурными границами 

или единицами развертывания, это способ организации планирования и вы-

полнения задач . Они могут вообще не выходить за рамки компонента или 

охватывать сразу несколько компонентов .

Локальные процессы

Локальные процессы представляют более надежные физические архитек-

турные границы . Обычно локальный процесс запускается из командной 

строки или с помощью эквивалентного системного вызова . Локальные про-

цессы выполняются на одном процессоре или группе процессоров (в много-

процессорной системе), но в разных адресных пространствах . Механизмы 

защиты памяти обычно не позволяют таким процессам совместно исполь-

зовать одну и ту же область памяти, хотя для взаимодействий нередко ис-

пользуются сегменты разделяемой памяти .

1 Хотя в этом случае статический полиморфизм даже нельзя рассматривать как вариант .

184   Глава 18. Анатомия границ

Чаще всего локальные процессы взаимодействуют друг с другом посред-

ством сокетов или других средств связи, поддерживаемых операционной 

системой, таких как почтовые ящики или очереди сообщений .

Каждый локальный процесс может быть статически скомпонованным моно-

литом или динамически компонуемой группой компонентов развертыва-

ния . В первом случае несколько монолитных процессов могут содержать 

одни и те же компоненты, скомпилированные и скомпонованные в них . Во 

втором — они могут совместно использовать динамически составляемые 

компоненты развертывания .

Локальный процесс можно считать своеобразным суперкомпонентом: про-

цесс состоит из низкоуровневых компонентов и управляет их зависимостя-

ми с помощью динамического полиморфизма .

Стратегия разделения между локальными процессами остается той же, что 

для монолитов и двоичных компонентов . Зависимости в исходном коде 

направлены в одну сторону через границу и всегда в сторону высокоуров-

невого компонента .

Для локальных процессов это означает, что исходный код высокоуровне-

вых процессов не должен содержать имен, физических адресов или ключей 

в реестре, соответствующих низкоуровневым процессам . Не забывайте, что 

главная архитектурная цель — сделать низкоуровневые процессы плагинами 

(сменными модулями) для высокоуровневых процессов .

Взаимодействия через границы локальных процессов связаны с обращени-

ем к системным вызовам, маршалингом и декодированием данных, а также 

переключением контекстов и обходятся умеренно дорого . Количество таких 

взаимодействий следует тщательно ограничивать .

Службы

Самыми надежными являются границы служб . Часто служба — это процесс, 

который запускается из командной строки или с помощью эквивалентного 

системного вызова . Службы не зависят от физического местоположения . 

Две взаимодействующие службы могут или не могут действовать на одном 

процессоре или группе процессоров в многопроцессорной системе . Службы 

предполагают, что все взаимодействия осуществляются по сети .

Взаимодействия через границы служб осуществляются очень медленно 

в сравнении с вызовами функций . Время между запросом и ответом может 

составлять от десятков миллисекунд до нескольких секунд . Взаимодействия 

Заключение      185

следует ограничивать по мере возможностей . Взаимодействия на этом уров-

не должны учитывать возможность больших задержек .

В остальном к службам применяются те же правила, что и к локальным 

процессам . Низкоуровневые службы должны «подключаться» к высоко-

уровневым службам . Исходный код высокоуровневых служб не должен 

содержать никакой конкретной информации (например, URI) о низко-

уровневых службах .

Заключение

Большинство систем, кроме монолитных, используют несколько стратегий 

разграничения . Система, состоящая из служб, может также иметь несколь-

ко локальных процессов . В действительности служба часто является всего 

лишь фасадом для нескольких взаимодействующих локальных процессов . 
</body></html>