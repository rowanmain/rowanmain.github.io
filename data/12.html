<!DOCTYPE html><html lang="ru"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>book</title></head><body>должны всякий раз подчеркивать приоритет важности архитектуры перед 

срочностью поведения .

Битва за архитектуру

Эта обязанность означает постоянную готовность к битве — возможно, 

в данном случае лучше использовать слово «борьба» . Честно говоря, подоб-

ная ситуация распространена практически повсеместно . Команда разработ-

чиков должна бороться за то, что, по их мнению, лучше для компании, так же 

как команда управленцев, команда маркетинга, команда продаж и команда 

эксплуатации . Это всегда борьба .

Эффективные команды разработчиков часто выходят победителями в этой 

борьбе . Они открыто и на равных вступают в конфликт со всеми другими 

заинтересованными сторонами . Помните: как разработчик программного 

обеспечения вы тоже являетесь заинтересованной стороной . У вас есть 

свой интерес в программном обеспечении, который вы должны защищать . 

Это часть вашей роли и ваших обязанностей . И одна из основных причин, 

почему вас наняли .

40   Глава 2. История о двух ценностях

Важность этой задачи удваивается, если вы выступаете в роли архитектора 

программного обеспечения . Архитекторы, в силу своих профессиональных 

обязанностей, больше сосредоточены на структуре системы, чем на кон-

кретных ее особенностях и функциях . Архитекторы создают архитектуру, 

помогающую быстрее и проще создавать эти особенности и функции, из-

менять их и дополнять .

Просто помните, что если поместить архитектуру на последнее место, раз-

работка системы будет обходиться все дороже, и в конце концов внесение 

изменений в такую систему или в отдельные ее части станет практически 

невозможным . Если это случилось, значит, команда разработчиков сража-

лась недостаточно стойко за то, что они считали необходимым .

II   

Начальные основы: 

парадигмы 

программирования

Архитектура программного обеспечения начинается с кода, поэтому начнем 

обсуждение архитектуры с рассказа о самом первом программном коде .

Основы программирования заложил Алан Тьюринг в 1938 году . Он не 

первый, кто придумал программируемую машину, но он первым понял, что 

программы — это всего лишь данные . К 1945 году Тьюринг уже писал на-

стоящие программы для настоящих компьютеров, используя код, который 

мы смогли бы прочитать (приложив определенные усилия) . В своих про-

граммах он использовал циклы, конструкции ветвления, операторы присва-

ивания, подпрограммы, стеки и другие знакомые нам структуры . Тьюринг 

использовал двоичный язык .

С тех пор в программировании произошло несколько революций . Одна из 

самых известных — революция языков . Во-первых, в конце 1940-х появились 

ассемблеры . Эти «языки» освободили программистов от тяжкого бремени 

трансляции их программ в двоичный код . В 1951 году Грейс Хоппер изобрела 

первый компилятор A0 . Именно она фактически ввела термин компилятор . 

В 1953 году был изобретен язык Fortran (через год после моего рождения) . 

42   Начальные основы: парадигмы программирования

Затем последовал непрерывный поток новых языков программирования: 

COBOL, PL/1, SNOBOL, C, Pascal, C++, Java и так до бесконечности .

Другая, еще более важная, как мне кажется, революция произошла в пара-

дигмах программирования . Парадигма — это способ программирования, не 

зависящий от конкретного языка . Парадигма определяет, какие структуры 

использовать и когда их использовать . До настоящего времени было при-

думано три такие парадигмы . По причинам, которые мы обсудим далее, едва 

ли стоит ожидать каких-то других, новых парадигм .

3 Обзор парадигм

44   Глава 3. Обзор парадигм

В этой главе дается общий обзор следующих трех парадигм: структурное 

программирование, объектно-ориентированное программирование и функ-

циональное программирование .

Структурное программирование

Первой, получившей всеобщее признание (но не первой из придуманных), 

была парадигма структурного программирования, предложенная Эдсгером 

Вибе Дейкстрой в 1968 году . Дейкстра показал, что безудержное использо-

вание переходов (инструкций goto) вредно для структуры программы . Как 

будет описано в последующих главах, он предложил заменить переходы 

более понятными конструкциями if/then/else и do/while/until .

Подводя итог, можно сказать, что:

Структурное программирование накладывает ограничение на прямую пере-

дачу управления.

Объектно-ориентированное 

программирование

Второй парадигмой, получившей широкое распространение, стала пара-

дигма, в действительности появившаяся двумя годами ранее, в 1966-м, 

и предложенная Оле-Йоханом Далем и Кристеном Нюгором . Эти два про-

граммиста заметили, что в языке ALGOL есть возможность переместить 

кадр стека вызова функции в динамическую память (кучу), благодаря чему 

локальные переменные, объявленные внутри функции, могут сохраняться 

после выхода из нее . В результате функция превращалась в конструктор 

класса, локальные переменные — в переменные экземпляра, а вложенные 

функции — в методы . Это привело к открытию полиморфизма через строгое 

использование указателей на функции .

Подводя итог, можно сказать, что:

Объектно-ориентированное программирование накладывает ограничение на 

косвенную передачу управления.

Пища для ума      45

Функциональное программирование

Третьей парадигмой, начавшей распространяться относительно недавно, 

является самая первая из придуманных . Фактически изобретение этой па-

радигмы предшествовало появлению самой идеи программирования . Пара-

дигма функционального программирования является прямым результатом 

работы Алонзо Чёрча, который в 1936 году изобрел лямбда-исчисление (или 

λ-исчисление), исследуя ту же математическую задачу, которая примерно 

в то же время занимала Алана Тьюринга . Его λ-исчисление легло в основу 

языка LISP, изобретенного в 1958 году Джоном Маккарти . Основополагаю-

щим понятием λ-исчисления является неизменяемость — то есть невозмож-

ность изменения значений символов . Фактически это означает, что функ-

циональный язык не имеет инструкции присваивания . В действительности 
</body></html>