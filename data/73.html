<!DOCTYPE html><html lang="ru"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>book</title></head><body>Главное правило — использовать заголовочные файлы как определения 

интерфейсов . Однако такой подход требует внимательно следить за тем, что 

помещается в заголовочный файл . Желательно не помещать в него ничего, 

кроме объявлений функций, а также констант и имен структур, необходи-

мых функциям .

Не загромождайте интерфейсные заголовочные файлы структурами данных, 

константами и определениями типов, которые нужны только реализации . 

Это не просто вопрос беспорядка: подобный беспорядок приводит к не-

желательным зависимостям . Ограничьте видимость деталей реализации . 

Исходите из предположения, что детали реализации будут изменяться . 

Чем меньше мест, где код знает детали, тем меньше кода вам придется про-

сматривать и изменять .

Чистая встраиваемая архитектура позволяет выполнять послойное тести-

рование, потому что модули взаимодействуют посредством интерфейсов . 

Каждый интерфейс обеспечивает шов, или точку подстановки, для тести-

рования вне целевого окружения .

Принцип DRY и директивы условной 

компиляции

Одно из использований возможности подстановки, которое часто упускают 

из виду, связано с особенностями обработки разных целевых платформ или 

операционных систем программами на C и C++ . Для этого часто исполь-

зуются директивы условной компиляции, включающие и выключающие 

сегменты кода . Я вспоминаю один особенно тяжелый случай, когда в теле-

коммуникационном приложении директива #ifdef BOARD_V2 встречалась 

несколько тысяч раз .

Повторяющийся код нарушает принцип «не повторяйся» (Don’t Repeat 

Yourself; DRY)1 . Если #ifdef BOARD_V2 встречается один раз, в этом нет ни-

какой проблемы . Но шесть тысяч раз — это большая проблема. Условная 

1 Hunt and Thomas, The Pragmatic Programmer . (Э. Хант, Д. Томас . Программист-прагма-

тик . Путь от подмастерья к мастеру . М .: Лори, 2016 . — Примеч. пер.)

264   Глава 29. Чистая встраиваемая архитектура

компиляция, идентифицирующая тип целевого оборудования, часто ис-

пользуется во встраиваемых системах . Можно ли от нее избавиться?

Можно, если реализовать слой аппаратных абстракций и скрыть определе-

ние типа оборудования в этом слое . Если слой HAL предоставляет набор 

интерфейсов, вместо условной компиляции можно взвалить всю работу 

на компоновщика (редактора связей) или использовать некоторую форму 

связывания во время выполнения для подключения программного обеспе-

чения к оборудованию .

Заключение

Программисты, разрабатывающие встраиваемое программное обеспечение, 

могут многое взять из опыта разработки обычного программного обеспече-

ния . Если вы занимаетесь разработкой встраиваемого программного обе-

спечения, то найдете в этой книге много мудрых и полезных советов и идей, 

которые пригодятся и вам .

Не позволяйте всему вашему коду превращаться в микропрограммы — это 

вредно для долгого и доброго здоровья вашего продукта . Возможность 

тестирования исключительно в целевом окружении — вредна для долгого 

и доброго здоровья вашего продукта . Следование принципам чистой встра-

иваемой архитектуры — полезно для долгого и доброго здоровья вашего 

продукта .

VI 

Детали

30

База данных — 

это деталь

Реляционные базы данных      267

С архитектурной точки зрения база данных не является сущностью — это 

деталь, которая не должна подниматься до уровня архитектурного элемента . 

Ее отношение к архитектуре программной системы сопоставимо с отноше-

нием дверной ручки к архитектуре здания .

Я понимаю, что эти слова могут показаться провокационными . Но верьте 

мне, я знаю, о чем говорю . А теперь позвольте мне пояснить: я не имею 

в виду модель данных . Структура, которую вы придаете данным в своем 

приложении, очень важна для архитектуры системы . Но база данных — это 

не модель данных . База данных — это часть программного обеспечения . База 

данных — это утилита, обеспечивающая доступ к данным . С архитектурной 

точки зрения эта утилита не имеет никакого значения, это низкоуровневая 

деталь — механизм . А хороший архитектор не позволяет низкоуровневым 

механизмам просачиваться в архитектуру системы .

Реляционные базы данных

Принципы реляционных баз данных были определены Эдгаром Коддом 

в 1970 году . К середине 1980-х годов реляционная модель разрослась 

и превратилась в доминирующую форму хранения данных . Такая попу-

лярность появилась не на пустом месте: реляционная модель элегантна, 

дисциплинированна и надежна . Это отличная технология хранения и до-

ступа к данным .

Но какой бы блестящей, полезной и близкой к математике ни выглядела 

технология, она не перестает быть просто технологией . А значит, она — 

деталь .

Реляционные таблицы удобны для некоторых видов доступа к данным, но 

в упорядочивании данных по записям в таблицах нет ничего архитектур-

но значимого . Варианты использования в приложении не должны знать 

и заботиться о таких вещах . В действительности о табличной организации 

данных должны знать только низкоуровневые вспомогательные функции 

во внешних кругах архитектуры .

Многие фреймворки доступа к данным позволяют передавать записи и та-

блицы из базы данных в виде объектов через всю систему . Но такой способ 

действий является архитектурной ошибкой . Он связывает варианты ис-

пользования, бизнес-правила, а в некоторых случаях даже пользовательский 

интерфейс с определенной реляционной структурой данных .

268   Глава 30. База данных — это деталь

Почему системы баз данных 

настолько распространены?

Почему среди программных систем и корпоративных программных про-

дуктов доминирующее положение заняли системы баз данных? Чем объяс-

няется превосходство Oracle, MySQL и SQL Server? Если говорить одним 

словом — диски .

Пять десятилетий вращающийся магнитный диск был основой хранения 

данных . Несколько поколений программистов не знали иных форм хране-
</body></html>