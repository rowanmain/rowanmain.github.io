<!DOCTYPE html><html lang="ru"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>book</title></head><body>1 В далеком прошлом мы назвали бы компонент на вершине центральным преобразова-

телем (Central Transform) . Подробности см . в книге Meilir Page-Jones, Practical Guide 

to Structured Systems Design», 2nd ed ., 1988 .

Разбиение потоков      225

и какие объекты находятся в каждой пещере . Они знают, как переместить 

игрока из пещеры в пещеру и как генерировать события для игрока .

Но есть еще ряд политик на еще более высоком уровне — политик, которые 

управляют здоровьем персонажа и действием определенных событий . Эти 

политики могут вызывать ухудшение здоровья у персонажа или улучшать 

его, давая персонажу еду и питье . Низкоуровневые политики, отвечающие за 

механику перемещений, могут определять события для этой высокоуровне-

вой политики, такие как FoundFood или FellInPit . А высокоуровневая поли-

тика могла бы управлять состоянием персонажа (как показано на рис . 25 .6) . 

В конечном итоге эта политика могла бы определять окончательный итог — 

победу или проигрыш в игре .

Рис. 25.6. Высокоуровневая политика управляет состоянием персонажа

Является ли это архитектурной границей? Нужно ли нам определить API, 

отделяющий MoveManagement от PlayerManagement? А давайте сделаем ситуа-

цию еще интереснее и добавим микрослужбы .

Допустим, что мы получили массивную многопользовательскую вер-

сию игры «Охота на Вампуса» . Компонент MoveManagement действует ло-

кально, на компьютере игрока, а PlayerManagement действует на сервере . 

PlayerManagement предлагает API микрослужбы для всех подключенных 

компонентов MoveManagement .

Диаграмма на рис . 25 .7 представляет несколько упрощенное отражение 

этого сценария . Элементы Network в действительности немного сложнее, 

чем показано на диаграмме, но сама идея должна быть понятна . В данном 

226   Глава 25. Уровни и границы

случае между MoveManagement и PlayerManagement пролегает полноценная 

архитектурная граница .

Рис. 25.7. Добавление API микрослужб

Заключение

Что из всего этого следует? Почему я взял эту до абсурда простую програм-

му, которую можно уместить в 200 строк кода на языке оболочки Kornshell, 

и развил ее до огромных размеров со всеми этими сумасшедшими архитек-

турными границами?

Этот пример призван был показать, что архитектурные границы существуют 

повсюду . Мы как архитекторы должны проявлять осторожность и проводить 

их, только когда они действительно нужны . Мы также должны помнить, что 

полная реализация границ обходится дорого .

В то же время мы должны помнить, что игнорирование границ может вы-

звать сложности в будущем — даже при наличии всеобъемлющего набора 

тестов и жесткой дисциплины рефакторинга .

Итак, что мы должны делать как архитекторы? Ответ едва ли удовлетворит 

вас . С одной стороны, некоторые очень умные люди много лет говорили нам, 

что мы не должны испытывать потребности в абстракциях . Это философия 

YAGNI: «You Aren’t Going to Need It» («Вам это не понадобится») . В этом 

есть определенная мудрость, поскольку излишнее усложнение конструк-

ции часто намного хуже ее упрощения . С другой стороны, когда обнару-

живается, что в том или ином месте действительно необходимо провести 

архитектурную границу, стоимость и риск ее добавления могут оказаться 

очень высокими .

Заключение      227

Вот так-то, Архитектор Программного Обеспечения, вы должны предви-

деть будущее . Вы должны предугадывать с пониманием дела . Вы должны 

взвесить все за и против, определить, где пролегают архитектурные границы 

и какие из них должны быть реализованы полностью, какие частично, а ка-

кие можно вообще игнорировать .

Но это не единовременное решение . Невозможно раз и навсегда решить на 

ранних этапах проектирования, какие границы реализовать, а какие игно-

рировать . Вы должны наблюдать за развитием системы, отмечать места, где 

может потребоваться провести новую границу, и затем внимательно следить 

за появлением первых трений, возникающих из-за отсутствия границ .

В этот момент нужно взвесить затраты на реализацию границ и цену их 

игнорирования и принять решение . Ваша цель — создать границу прямо 

в точке перегиба, когда реализовать ее окажется дешевле, чем продолжать 

игнорировать .

Для этого вы должны наблюдать очень внимательно .

26 Главный компонент

Конечная деталь      229

В каждой системе имеется хотя бы один компонент, который создает другие 

компоненты, наблюдает за ними и координирует их действия . Я называю 

такой компонент главным (Main) .

Конечная деталь

Компонент Main — это конечная деталь, политика самого низкого уровня . 

Он является точкой входа в систему . От него ничего не зависит, кроме ра-

ботоспособности системы . Его задача — создать все Фабрики, Стратегии 

и другие глобальные средства и затем передать управление высокоуровне-

вым абстракциям в системе .

Именно в компоненте Main должны внедряться все зависимости с использо-

ванием инфраструктуры внедрения зависимостей . После этого компонент 

Main должен распространить эти зависимости, обычно без использования 

инфраструктуры .

Компонент Main можно считать самым грязным из всех грязных компонен-

тов .

Рассмотрим следующий компонент Main из последней версии игры «Охота 

на Вампуса» . Обратите внимание, как он загружает все строки, о которых 

не должен знать основной код .

public class Main implements HtwMessageReceiver {

  private static HuntTheWumpus game;

  private static int hitPoints = 10;

  private static final List<String> caverns = 

      new ArrayList<>();

  private static final String[] environments = new String[]{

    "bright",

    "humid",

    "dry",

    "creepy",

    "ugly",

    "foggy",
</body></html>