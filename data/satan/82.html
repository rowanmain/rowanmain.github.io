<!DOCTYPE html>
<html>
<head>
   <title>Моя статья</title>
   <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<style>
body {
   background-color: #f0f0f0;
   font-family: Arial, sans-serif;
}

header {
   background-color: #333;
   color: white;
   padding: 10px;
   text-align: center;
}

h1 {
   margin: 0;
}

article {
   margin: 20px;
}

h2 {
   color: #333;
}

p {
   line-height: 1.6;
}
</style>
<body>
   <header>
       <h1>статья</h1>
   </header>
   <article>
       <p>
технологии PowerBuilder и суперпродуктивного языка 4GL, прекрасно подходящего 

для создания приложений баз данных . Спустя пару лет я создавал клиент-серверные 

приложения на Java, в которых мне приходилось создавать собственные подключения 

к базе данных (это было еще до появления JDBC) и наши собственные инструменты 

с графическим интерфейсом поверх AWT . Для вас это «прогресс»!

<<использует>>

<<интерфейс>>

<<интерфейс>>

<<использует>>

Рис. 34.4. Случай использования  

«просмотр заказов»

294   Глава 34. Недостающая глава

 доступа к данным . Как было показано на UML-диаграмме классов, с точки 

зрения реализации уровень примерно соответствует пакету . С точки зре-

ния доступности кода, чтобы OrdersController мог зависеть от интерфейса 

OrdersService, последний должен быть объявлен общедоступным, потому 

что класс и интерфейс находятся в разных пакетах . Аналогично общедо-

ступным должен быть объявлен интерфейс OrdersRepository, так как он 

используется классом OrdersServiceImpl, находящимся за пределами пакета, 

определяющего функции доступа к хранилищу .

В настоящей многоуровневой архитектуре стрелки зависимостей всегда 

должны быть направлены вниз . Уровни должны зависеть только от соседне-

го, нижележащего уровня . В результате введения некоторых правил, опреде-

ляющих, как должны зависеть элементы в базе кода, получается красивый, 

чистый, ациклический граф зависимостей . Большая проблема в том, что мы 

можем хитрить, вводя некоторые нежелательные зависимости, и при этом 

получать замечательный ациклический граф зависимостей .

Предположим, что на работу был нанят новый специалист, он присоеди-

нился к вашей команде и вы поручаете ему реализовать другой вариант 

использования, связанный с заказами . Как всякий новичок, этот человек 

хочет произвести впечатление и реализовать порученное ему задание макси-

мально быстро . Посидев несколько минут с чашкой кофе, новичок замечает 

существующий класс OrdersController и решает, что это именно тот код, 

который должен использоваться новой веб-страницей, порученной ему . Но 

ему нужны некоторые данные о заказах из базы данных . Новичка озаряет: 

«О, здесь уже есть интерфейс OrdersRepository . Я могу просто внедрить ре-

ализацию в мой контроллер . Отлично!» Спустя несколько минут он создает 

действующую веб-страницу . Но получившаяся UML-диаграмма выглядит, 

как показано на рис . 34 .5 .

Стрелки зависимостей все еще направлены вниз, но теперь для некоторых 

вариантов использования OrdersController минует OrdersService . Такую ор-

ганизацию часто называют нестрогой многоуровневой архитектурой, так как 

уровням позволено перепрыгивать через смежные, соседние уровни . В не-

которых ситуациях это делается намеренно, например, если вы пытаетесь 

следовать шаблону CQRS1 . Во многих других случаях нежелательно пере-

прыгивать через уровень бизнес-логики, особенно если эта бизнес-логика 

отвечает за авторизацию доступа к отдельным записям, например .

1 В шаблоне CQRS (Command Query Responsibility Segregation — разделение ответ-

ственности команд и запросов) для чтения и изменения данных используются разные 

шаблоны .

Упаковка по компонентам      295

<<использует>>

<<интерфейс>>

<<интерфейс>>

<<использует>>

<<использует>>

Рис. 34.5. Нестрогая многоуровневая архитектура

Новый вариант использования работает, но наверняка реализован не так, 

как вам хотелось бы . Нечто подобное я видел во многих командах, которые 

посещал как консультант, и обычно это проявляется, когда команды начи-

нают выяснять, как выглядит база кода, часто в первый раз .

В такой ситуации необходимо установить правило — архитектурный прин-

цип, — которое гласит, например: «Веб-контроллеры никогда не должны об-

296   Глава 34. Недостающая глава

ращаться к хранилищу непосредственно» . Проблема, конечно, заключается 

в исполнении правила . Многие команды, с которыми я встречался, заявля-

ли: «Мы обеспечиваем соблюдение этого принципа строгой дисциплиной 

и обзорами кода, потому что доверяем нашим разработчикам» . Это хорошо, 

что есть такая уверенность, но все мы знаем, что происходит, когда бюджет 

и сроки начинают приближаться к концу .

Намного меньше команд сообщали мне, что они используют инструменты 

статического анализа (например, NDepend, Structure101, Checkstyle) для 

автоматической проверки и выявления архитектурных нарушений во время 

сборки . Возможно, вы уже видели такие правила; обычно они имеют форму 

регулярных выражений или строк с шаблонными символами, которые ука-

зывают: «типы в пакете **/web не должны использоваться типами в **/data» 

и проверяются после этапа компиляции .

Это немного грубоватый подход, но он может помочь, сообщая о наруше-

ниях архитектурных принципов, которые (по вашему мнению) должны по-

мешать вашей команде разработчиков выполнить сборку . Проблема обоих 

подходов в том, что они чреваты ошибками и цикл обратной связи дольше, 

чем хотелось бы . Если отключить проверку, в результате код может превра-

титься в «большой ком грязи»1 . Лично я хотел бы, чтобы за соблюдением 

архитектурных принципов следил компилятор .

Это ведет нас к варианту «упаковка по компонентам» . Цель этого гибрид-

ного подхода, обсуждавшегося до сих пор, — упаковать все обязанности, 

связанные с одним крупным компонентом, в единый Java-пакет . Речь идет 

о сервис-ориентированном представлении программной системы, что, 

собственно, мы наблюдаем в архитектурах микрослужб . Подобно портам 

и адаптерам, интерпретирующим Веб как всего лишь еще один механизм 

доставки, методика «упаковка по компонентам» помогает отделить пользо-

вательский интерфейс от этих крупных компонентов . На рис . 34 .6 показано, 

как мог бы выглядеть вариант «просмотр заказов» .

По сути, этот подход связывает «бизнес-логику» и код для работы с хра-

нилищем в единое нечто, что мы называем «компонентом» . Выше в книге 

дядюшка Боб дал такое определение компонента:

Компоненты — это единицы развертывания. Они представляют наименьшие 

сущности, которые можно развертывать в составе системы. В Java — это 

jar-файлы. 

1 http://www.laputan.org/mud/ .

</p>
   </article>
</body>
</html>
