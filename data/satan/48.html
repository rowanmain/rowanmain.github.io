<!DOCTYPE html>
<html>
<head>
   <title>Моя статья</title>
   <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<style>
body {
   background-color: #f0f0f0;
   font-family: Arial, sans-serif;
}

header {
   background-color: #333;
   color: white;
   padding: 10px;
   text-align: center;
}

h1 {
   margin: 0;
}

article {
   margin: 20px;
}

h2 {
   color: #333;
}

p {
   line-height: 1.6;
}
</style>
<body>
   <header>
       <h1>статья</h1>
   </header>
   <article>
       <p>
Это правило управляло многими нашими решениями .

Одним из первых решений было создание собственного веб-сервера, отве-

чающего потребностям FitNesse . Это решение может показаться абсурдным . 

Даже в 2001 году существовало немало веб-серверов с открытым исходным 

кодом, которые мы могли бы использовать . Тем не менее решение написать 

свой сервер оправдало себя, потому что реализовать простой веб-сервер 

совсем несложно и это позволило нам отложить решение о выборе веб-

фреймворка на более поздний срок1 .

Еще одно решение, принятое на ранней стадии, — не думать о базе данных . 

У нас была задумка использовать MySQL, но мы намеренно отложили это 

решение, использовав дизайн, сделавший это решение несущественным . 

Суть его заключалась в том, чтобы вставить интерфейс между всеми об-

ращениями к данным и самим хранилищем .

Мы поместили методы доступа к данным в интерфейс с именем WikiPage . 

Эти методы обеспечивали все необходимое для поиска, извлечения и со-

хранения страниц . Конечно, мы не реализовали эти методы с самого начала, 

а просто добавили «заглушки», пока работали над функциями, не связан-

ными с извлечением и сохранением данных .

1 Много лет спустя мы смогли перенести фреймворк Velocity на FitNesse .

FitNesse      171

В действительности в течение трех месяцев мы работали над переводом 

текста вики-страницы в HTML . Это не потребовало использования какого-

либо хранилища данных, поэтому мы создали класс с именем MockWikiPage, 

содержащий простые заглушки методов доступа к данным .

В какой-то момент этих заглушек оказалось недостаточно для новых функ-

ций, которые мы должны были написать . Нам понадобился настоящий до-

ступ к данным, без заглушек . Поэтому мы создали новый класс InMemoryPage, 

производный от WikiPage . Этот класс реализовал методы доступа к данным 

в хеш-таблице с вики-страницами, хранящейся в ОЗУ .

Это позволило нам целый год писать функцию за функцией . В результате 

мы получили первую версию программы FitNesse, действующую именно 

так . Мы могли создавать страницы, ссылаться на другие страницы, при-

менять самое причудливое форматирование и даже выполнять тесты под 

управлением FIT . Мы не могли только сохранять результаты нашего труда .

Когда пришло время реализовать долговременное хранение, мы снова по-

думали о MySQL, но решили, что в краткосрочной перспективе это необя-

зательно, потому что хеш-таблицы было очень легко записывать в простые 

файлы . Как результат, мы реализовали класс FileSystemWikiPage, который 

работал с простыми файлами, и продолжили работу над созданием новых 

возможностей .

Три месяца спустя мы пришли к заключению, что решение на основе про-

стых файлов достаточно хорошее, и решили вообще отказаться от идеи 

использовать MySQL . Мы отложили это решение до неопределенного бу-

дущего и никогда не оглядывались назад .

На этом история закончилась бы, если бы не один из наших клиентов, ре-

шивший, что ему очень нужно сохранить свою вики-страницу в MySQL . Мы 

показали ему архитектуру WikiPages, позволившую нам отложить решение . 

Через день он вернулся с законченной системой, работавшей в MySQL . Он 

просто написал производный класс MySqlWikiPage и получил необходимое .

Мы включили этот вариант в FitNesse, но никто больше не использовал 

его, по крайней мере, поэтому мы отбросили его . Даже клиент, написавший 

производный класс, в конечном счете отказался от него .

Начиная работу над FitNesse, мы провели границу между бизнес-правилами 

и базами данных . Эта граница позволила реализовать бизнес-правила так, 

что они вообще никак не зависели от выбора базы данных, им требовались 

только методы доступа к данным . Это решение позволило нам больше года 

откладывать выбор и реализацию базы данных . Оно позволило опробовать 

вариант с файловой системой и изменить направление, когда мы увидели 

172   Глава 17. Границы: проведение разделяющих линий

лучшее решение . Кроме того, оно не препятствовало и даже не мешало движе-

нию в первоначальном направлении (к MySQL), когда кто-то пожелал этого .

Факт отсутствия действующей базы данных в течение 18 месяцев разработ-

ки означал, что 18 месяцев мы не испытывали проблем со схемами, запро-

сами, серверами баз данных, паролями, тайм-аутами и прочими неприятно-

стями, которые непременно начинают проявляться, как только вы включаете 

в работу базу данных . Это также означало, что все наши тесты выполнялись 

очень быстро, потому что не было базы данных, тормозившей их .

Проще говоря, проведение границ помогло нам задержать и отложить при-

нятие решений, и это сэкономило нам немало времени и нервов . Именно 

такой должна быть хорошая архитектура .

Какие границы проводить и когда?

Отделять линиями нужно все, что не имеет значения . Графический интер-

фейс не имеет значения для бизнес-правил, поэтому между ними нужно 

провести границу . База данных не имеет значения для графического интер-

фейса, поэтому между ними нужно провести границу . База данных не имеет 

значения для бизнес-правил, поэтому между ними нужно провести границу .

Возможно, кто-то из вас пожелал бы возразить против этих заявлений, осо-

бенно против заявления о независимости бизнес-правил от базы данных . 

Многие из нас привыкли считать, что база данных неразрывно связана с биз-

нес-правилами . Кое-кто может быть даже уверен, что база данных является 

воплощением бизнес-правил .

Но, как будет показано в другой главе, эта идея ошибочна . База данных — 

это инструмент, который бизнес-правила могут использовать опосредован-

но . Бизнес-правила не зависят от конкретной схемы, языка запросов и лю-

бых других деталей организации базы данных . Бизнес-правилам требуется 

только набор функций для извлечения и сохранения данных . Это позволяет 

нам скрыть базу данных за интерфейсом .

Это ясно видно на рис . 17 .1 . Класс BusinessRules использует интерфейс 

DatabaseInterface для загрузки и сохранения данных . Класс DatabaseAccess 

реализует интерфейс и выполняет операции в фактической базе данных 

Database .

Классы и интерфейсы на этой диаграмме носят символический характер . 

В настоящем приложении может иметься несколько классов бизнес-правил, 

несколько интерфейсов доступа данным и несколько классов, реализующих 

этот доступ . Но все они будут следовать примерно одному и тому же шаблону .

Какие границы проводить и когда?      173

Рис. 17.1. База данных за интерфейсом

Где здесь граница? Граница пересекает отношение наследования чуть ниже 

DatabaseInterface (рис . 17 .2) .

Рис. 17.2. Линия границы

</p>
   </article>
</body>
</html>
