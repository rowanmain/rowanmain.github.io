<!DOCTYPE html>
<html>
<head>
   <title>Моя статья</title>
   <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<style>
body {
   background-color: #f0f0f0;
   font-family: Arial, sans-serif;
}

header {
   background-color: #333;
   color: white;
   padding: 10px;
   text-align: center;
}

h1 {
   margin: 0;
}

article {
   margin: 20px;
}

h2 {
   color: #333;
}

p {
   line-height: 1.6;
}
</style>
<body>
   <header>
       <h1>статья</h1>
   </header>
   <article>
       <p>
При такой организации, изображенной 

на рис . 34 .2, имеются те же интерфей-

сы и классы, но они помещаются в еди-

ный Java-пакет . Ее легко получить про-

стым рефакторингом из «упаковки по 

уровням», но теперь верхнеуровневая 

структура кричит о предметной области . 

Теперь видно, что кодовая база имеет 

какое-то отношение к заказам, а не к Веб, 

не к службам и не к хранилищам . Другим 

преимуществом является относитель-

ная простота поиска кода для изменения, 

например, когда потребуется изменить 

вариант использования «просмотр зака-

зов» . Весь код сосредоточен вместе, а не 

разбросан по разным Java-пакетам1 .

Мне часто встречаются команды раз-

работчиков, испытывающие трудности 

с разделением на горизонтальные уров-

ни («упаковка по уровням») и переклю-

чающиеся на разделение по вертикали 

(«упаковка по особенностям») . По моему 

мнению, оба подхода не оптимальны . До-

читав книгу до этого места, многие из 

вас подумают, что можно сделать лучше, 

и они будут правы .

Порты и адаптеры

Как говорил «дядюшка Боб», подходы, 

такие как «порты и адаптеры», «гексаго-

нальная архитектура», «граница, управление, сущность» и др ., придуманы 

с целью создания архитектур, в которых прикладной/предметный код неза-

1 Ценность этого преимущества нивелируется навигационными возможностями совре-

менных IDE, но, похоже, в последнее время наблюдается возрождение популярности 

легковесных текстовых редакторов, причины которого я, в силу возраста, не могу понять .

<<использует>>

<<использует>>

<<интерфейс>>

<<интерфейс>>

Рис. 34.2. Упаковка  

по особенностям

292   Глава 34. Недостающая глава

висим и отделен от технических деталей реализации, таких как фреймворки 

и базы данных . Такие базы кода часто состоят из двух областей: «внутрен-

няя» (предметная) и «внешняя» (инфраструктура), как показано на рис . 

34 .3 .

Инфраструктура

Предметная область

Рис. 34.3. Кодовая база с внутренней и внешней областями

«Внутренняя» область включает все предметные понятия, а «внешняя» 

отвечает за взаимодействия с внешним миром (то есть содержит пользова-

тельские интерфейсы, базы данных, механизмы интеграции со сторонними 

продуктами) . Главное правило при такой организации: «внешняя» область 

зависит от «внутренней», но никогда наоборот . На рис . 34 .4 изображена 

версия реализации случая использования «просмотр заказов» .

Пакет com.mycompany.myapp.domain в этой версии — «внутренний», а другие 

пакеты — «внешние» . Обратите внимание, что зависимости указывают 

в сторону «внутренней» области . Внимательный читатель наверняка за-

метит, что класс OrdersRepository переименован в Orders . Это объясняется 

влиянием правил предметно-ориентированного проектирования, которые 

требуют всему, что находится «внутри», давать простые имена из словаря 

«универсального предметного языка» . Так, в предметных дискуссиях мы 

говорим «заказы», а не «хранилище заказов» .

Также стоит отметить, что это существенно упрощенная версия UML-диа-

граммы классов, потому что в ней отсутствуют такие элементы, как интерак-

торы и объекты для передачи данных через границы зависимостей .

Упаковка по компонентам      293

Упаковка по 

компонентам

В целом я согласен с рассуждениями 

о принципах SOLID, эквивалентности 

повторного использования (REP), согла-

сованного изменения (CCP) и совмест-

ного повторного использования (CRP) 

и большинством советов в этой книге, но 

я пришел к немного другим выводам, ка-

сающимся организации кода . Поэтому 

я представлю еще один вариант, который 

я называю «упаковка по компонентам» . 

Прежде всего, в своей карьере я много 

лет посвятил созданию корпоративного 

программного обеспечения, в основном 

на Java, во многих прикладных областях . 

Эти программные системы сильно от-

личались . Подавляющее их число были 

основаны на Веб, но имелись также кли-

ент-серверные1, распределенные, основан-

ные на обмене сообщениями и некоторые 

другие системы . Хотя технологии отлича-

лись, всех их объединяла традиционная 

многоуровневая архитектура .

Я уже упоминал пару причин, почему 

многоуровневую архитектуру следует 

считать неудовлетворительной, но это 

еще не все . Цель многоуровневой архи-

тектуры — отделить код, выполняющий 

схожие функции . Веб-интерфейс отде-

ляется от бизнес-логики, которая, в свою 

очередь, отделяется от механизмов 

1 На первой работе, после окончания университета в 1996 году, я занимался создани-

ем клиент-серверных приложений для настольных компьютеров с использованием 

</p>
   </article>
</body>
</html>
