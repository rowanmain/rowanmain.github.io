<!DOCTYPE html>
<html>
<head>
   <title>Моя статья</title>
   <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<style>
body {
   background-color: #f0f0f0;
   font-family: Arial, sans-serif;
}

header {
   background-color: #333;
   color: white;
   padding: 10px;
   text-align: center;
}

h1 {
   margin: 0;
}

article {
   margin: 20px;
}

h2 {
   color: #333;
}

p {
   line-height: 1.6;
}
</style>
<body>
   <header>
       <h1>статья</h1>
   </header>
   <article>
       <p>
всех разработчиков, развивающих эти компоненты, будет преследовать 

«синдром следующего утра» . Они будут постоянно наступать друг другу 

на пятки из-за необходимости использования одних и тех же версий ком-

понентов друг друга .

126   Глава 14. Сочетаемость компонентов

Рис. 14.2. Циклическая зависимость

Но список проблем этим не исчерпывается . Подумайте, что произойдет, 

когда нам потребуется протестировать компонент Entities . К нашему глу-

бокому огорчению обнаружится, что мы должны собрать и интегрировать 

его с Authorizer и Interactors . Такая степень зависимости компонентов вы-

зывает беспокойство, если она вообще допустима .

Возможно, вам уже приходилось задаваться вопросом, почему для простого 

модульного тестирования одного из классов приходится подключать так 

много библиотек и всякой другой всячины . Если бы вы копнули глубже, 

то наверняка бы обнаружили циклы в графе зависимостей . Такие циклы 

существенно усложняют изоляцию компонентов . Модульное тестирование 

и выпуск новой версии превращается в очень сложную задачу . Кроме того, 

проблемы, проявляющиеся во время сборки, начинают нарастать в геоме-

трической прогрессии от количества модулей .

Более того, наличие циклов в графе зависимостей усложняет определение по-

рядка сборки компонентов . И действительно, в этом случае нет правильного 

порядка . Это может повлечь другие неприятности в языках, таких как Java, 

которые извлекают объявления из скомпилированных двоичных файлов .

Разрыв цикла

Образовавшуюся циклическую зависимость всегда можно разорвать и при-

вести граф зависимостей к форме ациклического ориентированного графа 

(DAG) . Для этого используются два основных механизма:

Принцип ацикличности зависимостей      127

1 . Применить принцип инверсии зависимостей (Dependency Inversion 

Principle; DIP) . В этом случае, как показано на рис . 14 .3, можно было бы 

создать интерфейс, определяющий методы, необходимые классу User, затем 

поместить этот интерфейс в Entities и унаследовать его в Authorizer . Это 

обратило бы зависимость между Entities и Authorizer и разорвало цикл .

Рис. 14.3. Инверсия зависимости между Entities и Authorizer

2 . Создать новый компонент, от которого зависят Entities и Authorizer . 

Поместить в новый компонент класс(ы), от которых они оба зависят 

(рис . 14 .4) .

Рис. 14.4. Новый компонент, от которого зависят Entities и Authorizer

128   Глава 14. Сочетаемость компонентов

«Изменчивость»

Второе решение предполагает зависимость структуры компонентов от из-

менения требований . И действительно, с ростом приложения структура 

зависимостей компонентов растет и изменяется . Поэтому ее постоянно 

нужно проверять на предмет появления циклов . Когда образуются циклы, 

их нужно разрывать тем или иным способом . Иногда для этого приходится 

создавать новые компоненты, что заставляет разрастаться структуру за-

висимостей .

Проектирование сверху вниз

Проблемы, что мы обсудили к данному моменту, ведут к однозначному за-

ключению: структура компонентов не может проектироваться сверху вниз . 

К этому выводу приходят не сразу, как только начинают проектировать 

систему, но это неизбежно случается с ростом и изменением системы .

Некоторые читатели могут счесть это утверждение нелогичным . Мы обычно 

ожидаем, что разложение на крупные составляющие, такие как компоненты, 

будет также соответствовать разложению по функциональному признаку .

Рассматривая крупноблочную диаграмму, такую как структура зависимо-

стей компонентов, мы полагаем, что компоненты должны каким-то образом 

представлять функции системы . Но в действительности это не является 

непременным атрибутом диаграмм зависимостей компонентов .

Фактически диаграммы зависимостей компонентов слабо отражают функ-

ции приложения . В большей степени они являются отражением удобства 

сборки и сопровождения приложения . В этом главная причина, почему они 

не проектируются в начале разработки проекта . В этот период нет программ-

ного обеспечения, которое требуется собирать и сопровождать, поэтому нет 

необходимости составлять карту сборки и сопровождения . Но с появлением 

все большего числа модулей на ранних стадиях реализации и проектирова-

ния возрастает потребность управлять зависимостями, чтобы проект можно 

было разрабатывать, не опасаясь «синдрома следующего утра» . Кроме того, 

появляется желание максимально ограничить влияние изменений, поэтому 

мы начинаем обращать внимание на принципы единственной ответственно-

сти (SRP) и согласованного изменения (CCP) и объединять классы, которые 

наверняка будут изменяться вместе .

Одной из главных задач такой структуры зависимостей является изо-

ляция изменчивости . Нам не нужны компоненты, часто изменяющиеся 

Принцип устойчивых зависимостей      129

по самым мелким причинам и влияющие на другие компоненты, которые 

иначе были бы вполне стабильными . Например, косметические изменения 

в графическом интерфейсе не должны влиять на бизнес-правила . Добавле-

ние и изменение отчетов не должно влиять на высокоуровневые политики . 

Следовательно, граф зависимостей компонентов создается и формируется 

архитекторами для защиты стабильных и ценных компонентов от влияния 

изменчивых компонентов .

По мере развития приложения мы начинаем беспокоиться о создании эле-

ментов многократного пользования . На этом этапе на состав компонентов 

начинает влиять принцип совместного повторного использования (CRP) . 

Наконец, с появлением циклов мы начинаем применять принцип ациклич-

ности зависимостей (ADP), в результате начинает изменяться и разрастать-

ся граф зависимостей компонентов .

Попытка спроектировать структуру зависимостей компонентов раньше 

любых классов, скорее всего, потерпит неудачу . На этом этапе мы почти ни-

чего не знаем о согласовании изменений, не представляем, какие элементы 

можно использовать многократно и почти наверняка создадим компоненты, 

образующие циклические зависимости . Поэтому структура зависимостей 

компонентов должна расти и развиваться вместе с логическим дизайном 

системы .

Принцип устойчивых зависимостей

Зависимости должны быть направлены в сторону устойчивости.

Дизайн не может оставаться статичным . Некоторая изменчивость все равно 

необходима, если предполагается сопровождать дизайн . Следуя принципу 

согласованного изменения (CCP), мы создаем компоненты, чувствительные 

</p>
   </article>
</body>
</html>
