<!DOCTYPE html>
<html>
<head>
   <title>Моя статья</title>
   <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<style>
body {
   background-color: #f0f0f0;
   font-family: Arial, sans-serif;
}

header {
   background-color: #333;
   color: white;
   padding: 10px;
   text-align: center;
}

h1 {
   margin: 0;
}

article {
   margin: 20px;
}

h2 {
   color: #333;
}

p {
   line-height: 1.6;
}
</style>
<body>
   <header>
       <h1>статья</h1>
   </header>
   <article>
       <p>
Упаковка по компонентам      297

<<использует>>

<<использует>>

<<интерфейс>>

<<интерфейс>>

Рис. 34.6. Вариант использования «просмотр заказов»

Мое определение компонента немного отличается: «Группа функциональ-

ных возможностей, находящихся за общим чистым интерфейсом, которые 

постоянно находятся внутри среды выполнения, такой как приложение» . 

Это определение взято из описания модели C4 программной архитектуры 

298   Глава 34. Недостающая глава

(«C4 software architecture model»)1, которая определяет простую иерархиче-

скую организацию статических структур программной системы в терминах 

контейнеров, компонентов и классов (или кода) . В этом описании говорится, 

что программная система состоит из одного или нескольких контейнеров 

(например, веб-приложений, мобильных приложений, обычных прило-

жений, баз данных, файловых систем), каждый из которых содержит один 

или несколько компонентов, которые, в свою очередь, реализуются одним 

или несколькими классами (или кодом) . Находится ли каждый компонент 

в отдельном jar-файле — это уже второстепенный вопрос .

Ключевое преимущество подхода «упаковки по компонентам» заключает-

ся в размещении всего кода, например, имеющего отношение к обработке 

заказов, в одном месте — в компоненте OrdersComponent . Задачи внутри 

компонента все еще разделены, то есть бизнес-логика отделена от функций 

доступа к хранилищу, но это разделение является уже деталью реализации 

компонентов, о которой потребителям знать не обязательно . Это напоми-

нает организацию микрослужб или сервис-ориентированную архитектуру, 

когда имеется отдельная служба OrdersService, инкапсулирующая все, что 

связано с обработкой заказов, отличаясь лишь режимом разделения . 

Организацию монолитного приложения в виде набора тщательно про-

работанных компонентов можно рассматривать как шаг в направлении 

архитектуры микрослужб .

Дьявол в деталях реализации

На первый взгляд кажется, что все четыре подхода представляют собой 

разные способы организации кода и поэтому могут считаться разными ар-

хитектурными стилями . Это ощущение начинает быстро укрепляться, если 

нет понимания деталей реализации .

Я постоянно наблюдаю чересчур свободное использование модификатора 

доступа public в таких языках, как Java . Похоже, что разработчики использу-

ют ключевое слово public инстинктивно, не думая . Этот инстинкт хранится 

в нашей мышечной памяти . Если не верите, взгляните на примеры кода 

в книгах, руководствах и открытых фреймворках на сайте GitHub . Эта тен-

денция, похоже, никак не связана с архитектурным стилем, используемым 

для организации кода, будь то горизонтальные уровни, порты и адаптеры 

или что-то еще .

1 Дополнительные сведения можно найти по адресу https://www.structurizr.com/help/c4 .

Организация и инкапсуляция      299

Объявление всех типов общедоступными означает отказ от возможностей 

инкапсуляции, предлагаемых языком программирования . Как результат, это 

открывает возможность любому написать код с реализацией конкретного 

класса, нарушающий используемый архитектурный стиль .

Организация и инкапсуляция

Взглянем на эту проблему с другой стороны . Если все типы в Java-прило-

жении объявить общедоступными, пакеты превратятся в простой механизм 

организации (в группировки, как папки), утратив свойства инкапсуляции . 

Так как общедоступные типы могут беспрепятственно использоваться в лю-

бой точке приложения, вы фактически можете игнорировать пакеты, потому 

что они практически не несут никакой ценности . В результате, если вы иг-

норируете пакеты (потому что они не имеют никаких средств инкапсуляции 

и сокрытия), становится совершенно неважно, какой архитектурный стиль 

вы пытаетесь воплотить . Если все типы объявить общедоступными, пакеты 

Java на UML-диаграммах, представленных выше, превращаются в ненужную 

деталь . По сути, при злоупотреблении подобными объявлениями все четы-

ре архитектурных подхода, представленные выше в этой главе, становятся 

практически неотличимыми друг от друга (рис . 34 .7) .

<<использует>>

<<использует>>

<<использует>>

<<использует>>

<<использует>>

<<использует>>

<<использует>>

<<использует>>

<<интерфейс>>

<<интерфейс>>

<<интерфейс>>

<<интерфейс>>

<<интерфейс>>

<<интерфейс>>

<<интерфейс>>

<<интерфейс>>

Рис. 34.7. Все четыре архитектурных стиля идентичны

300   Глава 34. Недостающая глава

Обратите внимание на стрелки между типами на рис . 34 .7: они не зависят 

от архитектурного стиля, который вы пытаетесь воплотить . Концепту-

ально стили очень разные, но синтаксически они идентичны . Кроме того, 

можно даже утверждать, что после объявления всех типов общедоступ-

ными эти четыре стиля превращаются лишь в четыре способа описания 

традиционной архитектуры с горизонтальными уровнями . Это ловкий 

фокус, и, конечно же, никто не будет объявлять все свои Java-типы обще-

доступными . За исключением случаев, когда это действительно делается . 

И я видел их .

Модификаторы доступа в Java не идеальны1, но их игнорирование может 

вызывать проблемы . Порядок распределения типов Java по пакетам факти-

чески может иметь большое значение для доступности (или недоступности) 

этих типов, когда модификаторы доступа применяются соответственно . 

Если вернуть пакеты и отметить те типы (сделав их бледнее на диаграмме), 

которым можно дать более ограничивающий модификатор, картина станет 

интереснее (рис . 34 .8) .

Двигаясь слева направо в подходе «упаковка по уровням», интерфейсы 

</p>
   </article>
</body>
</html>
