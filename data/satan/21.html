<!DOCTYPE html>
<html>
<head>
   <title>Моя статья</title>
   <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<style>
body {
   background-color: #f0f0f0;
   font-family: Arial, sans-serif;
}

header {
   background-color: #333;
   color: white;
   padding: 10px;
   text-align: center;
}

h1 {
   margin: 0;
}

article {
   margin: 20px;
}

h2 {
   color: #333;
}

p {
   line-height: 1.6;
}
</style>
<body>
   <header>
       <h1>статья</h1>
   </header>
   <article>
       <p>
в течение времени выполнения приложения .

Эта идея положена в основу технологии регистрации событий (event 

sourcing)1 . Регистрация событий (event sourcing) — это стратегия, согласно 

которой сохраняются транзакции, а не состояние . Когда требуется получить 

состояние, мы просто применяем все транзакции с самого начала .

1 Спасибо Грегу Янгу, что объяснил мне суть этого понятия .

Заключение      73

Конечно, реализуя подобную стратегию, можно использовать компромисс-

ные решения для экономии ресурсов . Например, вычислять и сохранять 

состояние каждую полночь . А затем, когда потребуется получить инфор-

мацию о состоянии, выполнить лишь транзакции, имевшие место после 

полуночи .

Теперь представьте хранилище данных, которое потребуется для поддержки 

этой схемы: оно должно быть о-о-очень большим . В настоящее время объ-

емы хранилищ данных растут так быстро, что, например, триллион байтов 

мы уже не считаем большим объемом — то есть нам понадобится намного, 

намного больше .

Что особенно важно, никакая информация не удаляется из такого храни-

лища и не изменяется . Как следствие, от набора CRUD-операций1 в при-

ложениях остаются только CR . Также отсутствие операций изменения и/

или удаления с хранилищем устраняет любые проблемы конкурирующих 

обновлений .

Обладая хранилищем достаточного объема и достаточной вычислительной 

мощностью, мы можем сделать свои приложения полностью неизменяемы-

ми — и, как следствие, полностью функциональными .

Если это все еще кажется вам абсурдным, вспомните, как работают системы 

управления версиями исходного кода .

Заключение

Итак:

 

� Структурное программирование накладывает ограничение на прямую 

передачу управления .

 

� Объектно-ориентированное программирование накладывает ограниче-

ние на косвенную передачу управления .

 

� Функциональное программирование накладывает ограничение на при-

сваивание .

Каждая из этих парадигм что-то отнимает у нас . Каждая ограничивает под-

ходы к написанию исходного кода . Ни одна не добавляет новых возмож-

ностей .

1 CRUD — аббревиатура, обозначающая набор основных операций с данными: Create 

(создание), Read (чтение), Update (изменение) и Delete (удаление) . — Примеч. пер.

74   Глава 6. Функциональное программирование

Фактически последние полвека мы учились тому, как не надо делать .

Осознав это, мы должны признать неприятный факт: разработка программ-

ного обеспечения не является быстро развивающейся индустрией . Прави-

ла остаются теми же, какими они были в 1946 году, когда Алан Тьюринг 

написал первый код, который мог выполнить электронный компьютер . 

Инструменты изменились, аппаратура изменилась, но суть программного 

обеспечения осталась прежней .

Программное обеспечение — материал для компьютерных программ — со-

стоит из последовательностей, выбора, итераций и косвенности . Ни больше 

ни меньше .

III 

Принципы дизайна

Хорошая программная система начинается с чистого кода . С одной стороны, 

если здание строить из плохих кирпичей, его архитектура не имеет большого 

значения . С другой стороны, плохие кирпичи можно перемешать с хороши-

ми . Именно на этом основаны принципы SOLID .

Принципы SOLID определяют, как объединять функции и структуры 

данных в классы и как эти классы должны сочетаться друг с другом . Ис-

пользование слова «класс» не означает, что эти принципы применимы 

только к объектно-ориентированному программному коду . В данном случае 

«класс» означает лишь инструмент объединения функций и данных в груп-

пы . Любая программная система имеет такие объединения, как бы они ни 

назывались, «класс» или как-то еще . Принципы SOLID применяются к этим 

объединениям .

Цель принципов — создать программные структуры среднего уровня, ко-

торые:

 

� терпимы к изменениям;

 

� просты и понятны;

 

� образуют основу для компонентов, которые могут использоваться во 

многих программных системах .

Термин «средний уровень» отражает тот факт, что эти принципы приме-

няются программистами на уровне модулей . Они применяются на уровне, 

76   Принципы дизайна

лежащем непосредственно над уровнем программного кода, и помогают 

определять программные структуры, используемые в модулях и компо-

нентах .

Как из хороших кирпичей можно сложить никуда не годную стену, так из 

хорошо продуманных компонентов среднего уровня можно создать никуда 

не годную систему . Поэтому сразу после знакомства с принципами SOLID 

мы перейдем к их аналогам в мире компонентов, а затем к высокоуровневым 

принципам создания архитектур .

Принципы SOLID имеют долгую историю . Я начал собирать их в конце 

1980-х годов, обсуждая принципы проектирования программного обеспече-

ния с другими пользователями USENET (ранняя разновидность Facebook) . 

На протяжении многих лет принципы смещались и изменялись . Некоторые 

исчезали . Другие объединялись . А какие-то добавлялись . В окончательном 

виде они были сформулированы в начале 2000-х годов, хотя и в другом по-

рядке, чем я представлял .

В 2004 году или около того Майкл Физерс прислал мне электронное пись-

мо, в котором сообщил, что если переупорядочить мои принципы, из их 

первых букв можно составить слово SOLID1 — так появились принципы 

SOLID .

Последующие главы подробнее описывают каждый принцип, а пока позна-

</p>
   </article>
</body>
</html>
