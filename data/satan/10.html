<!DOCTYPE html>
<html>
<head>
   <title>Моя статья</title>
   <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<style>
body {
   background-color: #f0f0f0;
   font-family: Arial, sans-serif;
}

header {
   background-color: #333;
   color: white;
   padding: 10px;
   text-align: center;
}

h1 {
   margin: 0;
}

article {
   margin: 20px;
}

h2 {
   color: #333;
}

p {
   line-height: 1.6;
}
</style>
<body>
   <header>
       <h1>статья</h1>
   </header>
   <article>
       <p>
Новая система должна была быть написана на C для дисковой ОС UNIX, дей-

ствующей на микрокомпьютере с процессором Intel 8086. Наши конструкторы 

приступили к созданию нового компьютерного оборудования, а отобранная 

группа программистов, «The Tiger Team», занялась разработкой новой системы.

Не буду утомлять вас подробностями первого провала. Скажу лишь только, что 

первая команда «Tiger Team» полностью провалилась, потратив два или три 

человеко-года на проект, который так и не был закончен.

Компьютер зоны обслуживания   325

Спустя год или два, примерно в 1982 году, была предпринята новая попытка. 

Ее целью была полная и всеобщая переделка SAC на C, UNIX и нашем заново 

спроектированном оборудовании с впечатляюще производительным процессо-

ром 80286. Мы назвали новый компьютер «Deep Thought»1.

Прошли годы, потом еще несколько лет, затем еще несколько и еще. Я не знаю, 

когда, наконец, была развернута первая система SAC на базе UNIX; полагаю, 

что это случилось уже после моего ухода (в 1988 году). На самом деле я вообще 

не уверен, что она была хоть когда-то развернута.

Почему так долго? Просто потому, что команде, занимавшейся созданием новой 

системы, было сложно угнаться за огромной командой, активно развивавшей 

старую систему. Вот лишь некоторые из трудностей, с которыми они столкну-

лись.

Европа

Примерно в то же время, когда система SAC переписывалась на C, компания 

начала расширять продажи в Европе. Руководство не могло ждать, пока за-

кончится переделка программного обеспечения, поэтому в Европе стали раз-

вертываться старые системы на M365.

Проблема в том, что телефонные системы в Европе сильно отличались от 

телефонных систем в США. Организация труда рабочих и служащих также 

существенно отличалась. Поэтому один из наших лучших программистов 

был отправлен в Великобританию для руководства группой британских раз-

работчиков, занимающихся адаптацией программного обеспечения SAC под 

европейские требования.

Разумеется, не предпринималось никаких серьезных попыток интегрировать 

произведенные изменения с программным обеспечением в США. Эта работа 

велась задолго до появления сетей, позволявших передавать большие объемы 

кода через океан. Британские разработчики просто взяли за основу код из США 

и исправляли его под свои нужды.

Это, конечно, вызывало трудности. Ошибки обнаруживались по обе стороны 

Атлантики, и их требовалось исправлять на обеих же сторонах. Но модули зна-

чительно изменились, поэтому было трудно определить, будет ли исправление, 

сделанное в США, работать в Великобритании.

После нескольких лет изнуряющей гонки и появления скоростной линии, свя-

завшей офисы в США и Великобритании, была предпринята серьезная попытка 

интегрировать две системы, переместив все различия в настройки. И первая, 

1 «Думатель», так назывался компьютер из фантастического романа Дугласа Адам-

са, давший «ответ на главный вопрос жизни, вселенной и всего такого» (https://

ru.wikipedia.org/wiki/Автостопом_по_галактике_(серия_романов)). — Примеч. пер.

326   Приложение. Архитектурная археология

и вторая, и третья попытки провалились. Две базы кода, хотя и очень похожие, 

имели слишком много отличий для успешной реинтеграции, особенно в быстро 

меняющейся рыночной среде тех лет.

Между тем разработчики из команды «Tiger Team», пытавшиеся переписать 

все на C и UNIX, заметили, что им также приходится иметь дело с этой двой-

ственностью Европа/США. И конечно, это не способствовало ускорению их 

движения вперед.

В заключение о SAC

Я мог бы продолжать рассказывать истории об этой системе, но это неприятные 

для меня воспоминания. Достаточно сказать, что многие из этих горьких уроков 

в моей карьере программиста были получены в процессе погружений в ужасный 

ассемблерный код SAC.

Язык C

Оборудование на базе микропроцессора 8085, которое мы использовали в про-

екте 4-Tel Micro, дало нам относительно недорогую компьютерную платформу, 

пригодную для реализации многих разных промышленных проектов. Мы имели 

32 Кбайт ОЗУ и еще 32 Кбайт ПЗУ и чрезвычайно гибкую и мощную схему 

управления периферией. Чего у нас не было, так это гибкого и удобного языка 

программирования. На ассемблере 8085 было просто неинтересно писать код.

Кроме того, ассемблер, которым мы пользовались, был написан нашими же 

программистами. Он работал на наших ЭВМ M365 и использовал ленточный 

накопитель на картриджах, описанный в разделе «Laser Trim».

Так сложилось, что наш ведущий инженер-электронщик убедил генерального 

директора в необходимости иметь настоящий компьютер. На самом деле он не 

знал, что с ним делать, но он имел большое политическое влияние. Поэтому мы 

купили PDP-11/60.

Я, в то время скромный программист, был в восторге. Я точно знал, что я хочу 

сделать с этим компьютером. Я решил, что это будет моя машина.

Когда пришли инструкции и руководства, за несколько месяцев до того, как 

пришла сама машина, я забрал их домой и буквально проглотил. К моменту, 

когда был доставлен компьютер, я довольно глубоко изучил, как действует 

аппаратное и программное обеспечение, настолько глубоко, насколько это воз-

можно в домашних условиях.

Я помогал писать заказ на поставку. В частности, я указал, что новый компью-

тер должен иметь дисковый накопитель. Я решил, что мы должны купить два 

Язык C   327

дисковых привода, в которые можно устанавливать сменные пакеты дисков 

емкостью по 25 мегабайт каждый1.

Пятьдесят мегабайт! Этот объем казался неисчерпаемым! Я помню, как по но-

чам я гулял по коридорам офиса, подобно злой ведьме Бастинде, и восклицал: 

«Пятьдесят мегабайт! Ха-ха-ха-ха-ха-ха-ха-ха-ха!»

Руководитель службы эксплуатации здания отгородил небольшую комнату, 

в которой могло поместиться шесть терминалов VT100. Я украсил ее стены кар-

тинами с изображениями космоса. Наши программисты могли бы использовать 

эту комнату для написания и компиляции кода.

Когда пришла машина, я потратил несколько дней на ее установку, подключение 

терминалов и проверку работоспособности всех ее компонентов. Этот труд был 

в радость.

Мы закупили стандартные ассемблеры для 8085 в компании Boston Systems 

Office и переписали код 4-Tel Micro с использованием нового синтаксиса. Мы 

построили систему кросс-компиляции, позволявшую нам выгружать скомпили-

рованный двоичный код из PDP-11 в наши вычислительные комплексы на базе 

8085 и в программаторы ПЗУ. И план удался — все работало как часы.

C

Но у нас оставалась еще проблема в виде языка ассемблера 8085, который мы 

продолжали использовать. Это было ложкой дегтя в бочке меда. Я уже слышал 

про «новый» язык, широко использовавшийся в Bell Labs. Они назвали его «C». 

Поэтому я купил книгу The C Programming Language2 Кернигана и Ритчи. Как 

и руководства для PDP-11, несколькими месяцами раньше, я проглотил эту 

книгу.

Я был поражен простотой и элегантностью этого языка. Он обладал мощностью 

языка ассемблера, но открывал доступ к этой мощности, предоставляя более 

удобный синтаксис. Я был в восторге.

Я купил компилятор C в компании Whitesmiths и запустил его на PDP-11. 

Он производил код на языке ассемблера, синтаксис которого был совместим 

с компилятором 8085 от Boston Systems Office. То есть у нас появилась возмож-

ность писать программы на C для 8085! Мы были готовы к работе.

Теперь оставалась единственная проблема — убедить программистов, пишущих 

на ассемблере, что они должны перейти на C. Но эту кошмарную историю я рас-

скажу в другой раз...

1 RKO7.

2 Последнее переиздание на русском языке: Брайн Керниган, Денис Ритчи. Язык про-

граммирования C. М.: Вильямс, 2016. — Примеч. пер.

328   Приложение. Архитектурная археология

BOSS

Наша платформа на процессоре 8085 не имела операционной системы. Мой 

опыт работы с системой MPS на ЭВМ M365 и знание простейших механизмов 

прерываний в IBM System 7 подсказывали, что нам нужен простой диспетчер 

задач для 8085. Поэтому я задумал написать BOSS: Basic Operating System and 

Scheduler (базовая операционная система с планировщиком)1.

Значительная часть BOSS была написана на C. Она могла конкурентно выпол-

нять несколько задач. Многозадачность не была вытесняющей — переключение 

происходило не по прерываниям, а так же, как в системе MPS для M365, с по-

мощью простого механизма опроса. Опрос происходил всякий раз, когда задача 

блокировалась в ожидании события.

Вызов, блокирующий задачу, выглядел в BOSS так:

block(eventCheckFunction);

Этот вызов приостанавливал текущую задачу, помещал eventCheckFunction 

в список опроса и связывал ее с только что заблокированной задачей. Затем 

выполнялся цикл опроса, в котором последовательно вызывались функции из 

списка, пока одна из них не возвращала true. Затем возобновлялось выполнение 

задачи, связанной с этой функцией.

То есть, как я говорил выше, это был простой невытесняющий диспетчер задач.

Это программное обеспечение стало основой для большого количества про-

ектов, разрабатывавшихся в следующие несколько лет. Но одним из первых 

был pCCU.

pCCU

Конец 1970-х — начало 1980-х годов было шумным временем для те лефонных 

компаний. Одной из причин волнений стала цифровая революция.

В предыдущем веке коммутационный узел и телефон клиента связывала пара 

медных проводов. Эти провода связывались в кабели, образующие разветвлен-

ную сеть по всей стране. Иногда их подвешивали на столбах, иногда проклады-

вали под землей.

Медь — дорогой металл, и телефонные компании владели тоннами, буквально 

тоннами этого металла в виде проводов, опутывающих страну. Капиталовложения 

были огромными. Большую часть этих капиталовложений можно было сэконо-

1 Позднее эта аббревиатура получила другую расшифровку: Bob’s Only Successful 

Software (успешное программное обеспечение Боба).

pCCU   329

мить передачей телефонных разговоров через цифровые соединения. Одна пара 

медных проводов могла бы переносить сотни диалогов в цифровой форме.

В ответ телефонные компании приступили к замене старого аналогового ком-

мутационного оборудования современными цифровыми коммутаторами.

Наш продукт 4-Tel тестировал медные провода, но не мог тестировать цифровые 

соединения. В цифровой среде все еще использовались медные провода, но они 

были намного короче, чем раньше, и сосредоточены в основном рядом с теле-

фонами клиентов. Сигнал от телефонной станции передавался в цифровой 

форме до местного распределительного пункта, где преобразовывался обратно 

в аналоговую форму и доставлялся до клиента по обычной паре медных про-

водов. Это означало, что наша измеряющая аппаратура должна находиться там, 

где начинаются медные провода, но устройство соединения с ним должно было 

оставаться в телефонной станции. Проблема в том, что все наши компьютеры 

COLT объединяли устройство соединения и аппаратуру измерения в одном 

корпусе. (Мы могли бы сэкономить целое состояние, узнав об этой очевидной 

архитектурной границе на несколько лет раньше!)

В результате мы задумали продукт с новой архитектурой: CCU/CMU (COLT 

control unit/COLT measurement unit — модуль управления COLT/модуль из-

мерения COLT). По задумке модуль CCU должен находиться в телефонной 

станции и обеспечивать выбор телефонных линий для тестирования. Модуль 

CMU должен находиться в местных распределительных пунктах и измерять 

уровень сигнала в медных проводах, идущих к телефону клиента.

Проблема состояла в том, что на каждый модуль CCU приходилось много мо-

дулей CMU. Информация о том, какой модуль CMU использовать для каждого 

телефонного номера, содержалась в самом цифровом коммутаторе. То есть 

модуль CCU должен был опросить цифровой коммутатор, чтобы определить, 

с каким модулем он должен взаимодействовать.

Мы пообещали телефонным компаниям, что создадим эту новую архитектуру 

к моменту их перехода. Мы знали, что это займет месяцы, если не годы, по-

этому чувствовали себя раскованно. Мы также знали, что для разработки но-

вого программно-аппаратного комплекса CCU/CMU потребуется несколько 

человеко-лет.

Ловушка планирования

С течением времени у нас постоянно всплывали какие-то неотложные во-

просы, для решения которых мы были вынуждены откладывать разработку 

архитектуры CCU/CMU. Мы были уверены в своем решении, потому что 

телефонные компании тоже все время откладывали разработку цифровых 

коммутаторов. Заглядывая в их графики, мы были уверены, что у нас еще 

масса времени, поэтому мы постоянно откладывали нашу разработку.

330   Приложение. Архитектурная археология

Но настал день, когда мой начальник вызвал меня к себе в кабинет и сказал: 

«Один из наших клиентов развертывает цифровой коммутатор в следующем 

месяце. К тому времени у нас должен быть рабочий комплекс CCU/CMU».

Я был в ужасе! Как за месяц выполнить работы, требующие одного человеко-

года? Но у моего начальника был план...

На самом деле нам не нужна была полная архитектура CCU/CMU. Телефонная 

компания, устанавливающая цифровой коммутатор, была маленькой. У них 

была только одна телефонная станция и всего два местных распределительных 

пункта. Важно отметить, что «местные» распределительные пункты были не 

совсем местными. Фактически они являлись старыми добрыми аналоговы-

ми коммутаторами, к которым было подключено несколько сотен клиентов. 

К тому же эти коммутаторы принадлежали к типу, который успешно можно 

тестировать компьютерами COLT. Но самое замечательное, что телефонные 

номера клиентов включали всю информацию, необходимую для определения 

распределительного пункта. Если номер телефона включал цифру 5, 6 или 7 

в определенной позиции, это означало, что он подключен к распределительному 

пункту 1; иначе — к распределительному пункту 2.

Итак, как объяснил мне мой начальник, нам в действительности нужна не 

полная архитектура CCU/CMU, а только простой компьютер в телефонной 

станции, связанный модемными линиями с двумя стандартными компьютера-

ми COLT в распределительных пунктах. Компьютер SAC мог бы связываться 

с нашим компьютером в телефонной станции, а тот, в свою очередь, мог бы 

декодировать телефонный номер и посылать команды на выполнение тестиро-

вания в компьютер COLT, находящийся в соответствующем распределительном 

пункте.

Так родилась система pCCU.

Это был первый продукт, написанный на C и использующий BOSS, развер-

нутый у клиента. На разработку мне понадобилось что-то около недели. Эта 

история ничем не выделяется с архитектурной точки зрения, но она служит 

хорошим предисловием для следующего проекта.

DLU/DRU

В начале 1980-х годов в числе наших клиентов была телефонная компания из 

Техаса. Она обслуживала обширную географическую область. Область была 

настолько большой, что для ее обслуживания требовалось несколько сервисных 

центров с ремонтниками. В этих центрах находились люди, которым требова-

лись терминалы, связанные с нашим компьютером SAC.

Возможно, вы подумали, что это даже не проблема, но вспомните, что история 

происходила в начале 1980-х годов. Удаленные терминалы были редким яв-

DLU/DRU   331

лением. Хуже того, оборудование SAC предполагало размещение терминалов 

поблизости. Наши терминалы фактически подключались к нашей собственной 

высокоскоростной последовательной шине.

У нас имелась возможность подключить удаленные терминалы только через моде-

мы, которые в начале 1980-х годов могли передавать данные со скоростью не более 

300 бит в секунду. Наши клиенты были недовольны такой низкой скоростью.

В то время уже существовали высокоскоростные модемы, но они стоили очень 

дорого и им требовалось «условно» постоянное соединение. Качество комму-

тируемых соединений было определенно недостаточно высоким.

Наши клиенты требовали найти решение. Нашим ответом стала система DLU/

DRU.

Аббревиатура DLU/DRU расшифровывалась как «Display Local Unit» (локаль-

ное устройство отображения) и «Display Remote Unit» (удаленное устройство 

отображения). Устройство DLU — это компьютерная плата, включаемая в шасси 

SAC и играющая роль платы диспетчера терминала. Но вместо управления по-

следовательной шиной, соединяющей локальные терминалы, это устройство 

принимало поток символов и мультиплексировало его через единственное 

модемное соединение с пропускной способностью 9600 бит/с.

Устройство DRU размещалось удаленно, у клиента. Оно подключалось к дру-

гому концу модемного соединения с пропускной способностью 9600 бит/с 

и включало оборудование для управления терминалами, подключенными 

к разработанной нами последовательной шине. Оно демультиплексировало 

символы, принимаемые из модема, и передавало их соответствующим локаль-

ным терминалам.

Странно, правда? Нам пришлось разрабатывать решение, настолько обыденное 

в наши дни, что о нем никто не задумывается. Но тогда...

Нам пришлось даже придумать свой протокол связи, потому что тогда стандарт-

ные протоколы не были общедоступны в виде исходных кодов. Фактически все 

происходило задолго до того, как у нас появилось подключение к Интернету.

Архитектура

Система имела очень простую архитектуру, но в ней были некоторые интересные 

особенности, которые я хотел бы подчеркнуть. Во-первых, оба устройства были 

сконструированы на нашей технологии 8085, программное обеспечение для обоих 

было написано на C и использовало BOSS. Но на этом их сходство заканчивается.

Над проектом работали два человека. Я, как руководитель проекта, и Майк 

Карев (Mike Carew), мой близкий друг. Я взял на себя проектирование и раз-

работку DLU, а Майк — DRU.

332   Приложение. Архитектурная археология

Архитектура DLU основывалась на модели потока данных. Каждая задача 

выполняла небольшую узкоспециализированную работу и передавала свои 

результаты следующей задаче в конвейере, используя очередь. Представьте 

модель конвейеров и фильтров в UNIX. Архитектура получилась сложной. 

Добавлять данные в очередь могла одна задача, а извлекать их из нее — не-

сколько.

Представьте сборочную линию. На каждом участке такой сборочной линии 

выполняется единственная, простая, узкоспециализированная операция. После 

выполнения операции на одном участке продукт перемещается по конвейеру 

к следующему. Иногда сборочная линия может разветвляться на несколько 

линий. Иногда несколько линий могут сливаться в одну линию. Такова была 

архитектура устройства DLU.

Устройство DRU, созданное Майком, было основано на совершенно другой 

схеме. Он создал по одной задаче на каждый терминал и просто выполнял в ней 

всю работу, имеющую отношение к данному терминалу. Никаких очередей. Ни-

каких потоков данных. Просто несколько больших и одинаковых задач, каждая 

из которых управляет своим терминалом.

Это полная противоположность сборочной линии. В данном случае можно 

провести аналогию с несколькими опытными сборщиками, каждый из которых 

собирает свой продукт целиком.

В то время я думал, что моя архитектура лучше. Майк, конечно, думал, что его 

архитектура лучше. У нас было много интересных дискуссий на эту тему. Но, 

так или иначе, мы оба неплохо поработали. И мне оставалось лишь уяснить, 

что программные архитектуры могут быть совершенно разными, но одинаково 

эффективными.

VRS

На протяжении 1980-х годов появлялись все более и более новые технологии. 

Одной из таких технологий было голосовое управление компьютером.

Одной из функций системы 4-Tel было оказание помощи ремонтнику в поиске 

места повреждения кабеля. Процедура выглядела так:

 

� Тестировщик, работающий на телефонной станции, с помощью нашей си-

стемы определял расстояние в футах до точки повреждения с точностью 

около 20%. Затем он направлял ремонтника к точке доступа, ближайшей 

к повреждению.

 

� Ремонтник, прибыв на место, вызывал тестировщика и просил начать про-

цесс определения места повреждения. Тестировщик запускал процедуру 

поиска неисправности в системе 4-Tel. Система измеряла электрические 

VRS   333

характеристики поврежденной линии и выводила на экран сообщения, 

описывающие действия, которые требовалось выполнить дальше, такие как 

вскрыть кабель или закоротить кабель.

 

� Тестировщик сообщал ремонтнику, какие операции требуется выполнить, 

а ремонтник сообщал, когда та или иная операция была выполнена. После 

этого тестировщик сообщал системе, что затребованная операция выполнена, 

и она возобновляла тестирование.

 

� После двух-трех операций система рассчитывала новое расстояние до по-

вреждения. После этого ремонтник мог переехать в указанное место и про-

цесс повторялся вновь.

Представьте, насколько проще было бы, если бы ремонтник, поднявшись на 

столб или опору, мог бы сам управлять системой. Именно эту возможность дали 

нам новые голосовые технологии. Ремонтник мог бы вызвать систему непосред-

ственно, управлять ею с помощью тонального набора и прослушивать ответы, 

читаемые приятным голосом.

Название

Компания провела небольшой конкурс по выбору названия для новой системы. 

Одним из самых необычных предложений было имя SAM CARP. Оно расшиф-

ровывалось как «Still Another Manifestation of Capitalist Avarice Repressing the 

Proletariat» (еще одно проявление капиталистической алчности, подавляющей 

пролетариат). Разумеется, это название не было выбрано.

Еще одно название — Teradyne Interactive Test System (интерактивная тест-

система Tradyne) — тоже не было выбрано.

Также не было выбрано название Service Area Test Access Network (сеть доступа 

к тест-системе зоны обслуживания).

Победило название VRS: Voice Response System (система с голосовым ответом).

Архитектура

Мне не довелось работать над этой системой, но я был в курсе происходящего. 

Историю, которую я собираюсь рассказать, вы узнаете из вторых рук, но это не 

повлияло на ее правдивость.

Это был период эйфории, связанной с микрокомпьютерами, операционными 

системами UNIX, C и базами данных SQL. Мы были полны решимости ис-

пользовать все это.

Из множества баз данных мы выбрали UNIFY — систему управления базами 

данных для UNIX, что было идеально для нас.

334   Приложение. Архитектурная археология

База данных UNIFY поддерживала также новую технологию с названием 

Embedded SQL, позволявшую внедрять команды SQL в виде строк прямо в код 

на языке C. Что мы и не преминули сделать, причем повсюду.

Я имею в виду, это было так необычно — иметь возможность поместить код SQL 

прямо в программный код, в любое место, куда захотите. И куда мы захотели? 

Да повсюду! В результате код SQL оказался размазан ровным слоем по всему 

программному коду.

В те времена SQL еще не был солидным стандартом. Каждый производитель 

добавлял в язык SQL какие-то свои особенности. Поэтому нестандартный код 

SQL и нестандартные вызовы UNIFY API можно было увидеть повсюду в про-

граммном коде.

Но все работало замечательно! Система оказалась успешной. Ремонтники 

пользовались ею, и телефонные компании полюбили ее. Жизнь улыбалась нам.

Затем поддержка продукта UNIFY прекратилась.

Ой-ё!

Поэтому мы решили переключиться на SyBase. Или это была Ingress? Я не 

помню. Но важно не это, а то, что нам пришлось отыскать в коде на C весь код 

SQL и вызовы нестандартного API и заменить их аналогичным кодом, взаимо-

действующим с новой базой данных.

Через три месяца мы прекратили бесплодные попытки. Мы не могли заставить 

систему работать с новой базой данных. Мы оказались настолько привязанны-

ми к UNIFY, что не было никакой надежды реструктурировать код с более или 

менее разумными издержками.

В результате мы наняли сторонних специалистов, поддерживавших UNIFY 

для нас, заключив с ними контракт на техническое обслуживание. И конечно, 

с каждым годом затраты на обслуживание росли.

В заключение о VRS

Таким способом я узнал, что базы данных — это деталь, которую следует изо-

лировать от общей бизнес-цели системы. Это также одна из причин, почему мне 

не нравится зависимость от сторонних систем.

Электронный секретарь

В 1983 году наша компания оказалась на стыке компьютерных, телекоммуни-

кационных и голосовых систем. Наш генеральный директор считал, что такое 

положение может способствовать разработке новых продуктов. Он поручил 

Электронный секретарь   335

команде из трех человек (включая меня) придумать, спроектировать и реали-

зовать новый продукт для компании.

Нам не потребовалось много времени, чтобы прийти к идее создания элек-

тронного секретаря (Electronic Receptionist; ER). Суть была проста. Когда вы 

звонили в компанию, электронный секретарь (ER) поднимал трубку и спра-

шивал, с кем бы вы хотели поговорить. Вы могли ответить на вопрос, нажимая 

кнопки на телефоне в режиме тонального набора, и таким способом сообщить 

имя человека, а ER соединял вас с ним. То есть пользователи могли позвонить 

на номер электронного секретаря и, используя простые тональные команды, 

связаться с нужным человеком, где бы тот ни находился. Фактически система 

могла попробовать несколько альтернативных номеров.

Когда кто-то звонил электронному секретарю и набирал RMART (мой код), 

тот, в свою очередь, звонил по первому номеру в моем списке. В случае неудачи 

он звонил по следующему номеру, и т. д. Если связаться со мной не удалось, 

электронный секретарь мог бы записать голосовое сообщение для меня.

Затем электронный секретарь предпринимал периодические попытки найти 

меня и доставить сообщение, оставленное для меня кем-то другим.

Это была первая система голосовой почты, и мы1 получили патент на нее.

Мы собрали все необходимое оборудование для этой системы — компьютерную 

плату, плату памяти, платы для связи и записи голоса и все остальное. Роль 

компьютерной платы играла плата компьютера Deep Thought (Думатель) на 

процессоре Intel 80286, о котором я уже рассказывал.

Для каждой телефонной линии была создана отдельная голосовая плата. Эти 

платы содержали телефонный интерфейс, аппаратуру для кодирования/деко-

дирования голоса, некоторый объем памяти и микрокомпьютер Intel 80186.

Программное обеспечение для главной компьютерной платы было написано 

на C. В качестве операционной системы использовалась MP/M-86, одна из 

первых многозадачных дисковых систем, управляемых из командной строки. 

MP/M — это UNIX для бедных.

Программное обеспечение для голосовых плат было написано на ассемблере 

и действовало без операционной системы. Взаимодействие компьютера Deep 

Thought с голосовыми платами осуществлялось через общую память.

Архитектуру этой системы в наши дни назвали бы сервис-ориентированной. 

Каждая телефонная линия обслуживалась отдельным процессом, действующим 

под управлением MP/M.

1 Держателем патента стала наша компания. В нашем контракте с работодателем 

однозначно говорилось, что права на любые наши изобретения будут принадлежать 

компании. Мой начальник сказал мне: «Вы продали нам это за один доллар, но мы не 

выплатили вам этот доллар».

336   Приложение. Архитектурная археология

Когда поступал входящий звонок, запускался начальный процесс для обработ-

ки и звонок передавался ему. По мере перехода обслуживания звонка из одной 

стадии в другую запускался соответствующий процесс-обработчик и управление 

передавалось ему.

Сообщения передавались между этими службами через дисковые файлы. Теку-

щая выполняющаяся служба могла определить, какую службу запустить далее; 

записать необходимую информацию в дисковый файл; выполнить команду для 

запуска этой службы и затем завершиться.

Я впервые занимался созданием такой системы. В действительности это был 

первый раз, когда я выступал в роли главного архитектора продукта. Все, что 

имело отношение к программному обеспечению, было моим — и все работало 

как надо.

Я не могу сказать, что архитектура этой системы была «чистой» в том смысле, 

в каком предполагает эта книга; она не была архитектурой «сменных модулей» 

(плагинов). Однако в ней имелись явные признаки истинных границ. Службы 

развертывались независимо, и каждая отвечала за определенную предметную 

область. В системе имелись процессы высокого и низкого уровня, и многие за-

висимости простирались в правильном направлении.

Конец электронного секретаря

К сожалению, попытки продать этот продукт оказались неудачными. Компания 

Teradyne специализировалась на производстве контрольно-измерительного 

оборудования. Мы не представляли, как проникнуть на рынок конторского 

оборудования.

После неоднократных попыток, продолжавшихся в течение более двух лет, 

наш генеральный директор отказался от них и — к сожалению — отозвал за-

явку на патент. Патент был получен другой компанией, подавшей заявку через 

три месяца после нашей; так мы сдали рынок голосовой почты и электронной 

переадресации звонков.

Ой-ёй!

Зато теперь вы не сможете поставить мне в вину появление всех этих раздра-

жающих машин, отравляющих наше существование.

Система командирования ремонтников

Электронный секретарь потерпел неудачу как продукт, но у нас оставалось 

программное обеспечение и оборудование, которые мы могли бы использовать 

Система командирования ремонтников   337

для расширения линейки имеющихся продуктов. Кроме того, успех VRS на 

рынке убедил нас, что мы должны предложить систему с голосовым ответом 

для организации взаимодействий с ремонтниками, которые не зависят от наших 

систем тестирования.

Так родилась CDS — система командирования ремонтников (Craft Dispatch 

System). По сути, система CDS была электронным секретарем (ER), но ориенти-

рованным на решение узкого круга задач в области управления ремонтниками.

Когда в телефонной линии обнаруживалась проблема, в сервисный центр 

посылалась заявка. Заявки хранились в автоматизированной системе. Когда 

ремонтник, работающий в поле, завершал обслуживание заявки, он звонил 

в сервисный центр, чтобы получить следующее назначение. Оператор сервис-

ного центра извлекал следующую заявку и читал ее вслух ремонтнику.

Мы приступили к автоматизации этого процесса. Наша цель состояла в том, 

чтобы создать систему CDS, которой мог бы позвонить ремонтник, работающий 

в поле, и запросить следующее назначение. Система должна была обратиться 

к системе заявок и зачитать извлеченную из нее заявку. Система CDS могла бы 

следить за назначением заявок ремонтникам и информировать систему заявок 

о приеме заявки к исполнению.

Эта система имела немало интересных особенностей, связанных с взаимодей-

ствием с системой заявок, системой управления предприятием и системами 

автоматизированного тестирования.

Опыт разработки сервис-ориентированной архитектуры ER пробудил во мне 

желание еще раз опробовать эту идею. Машина состояний для обработки за-

явок оказалась намного сложнее, чем машина состояний для обработки звонков 

в электронном секретаре. Я приступил к созданию архитектуры, которая в наши 

дни называется архитектурой микрослужб.

Каждый переход между этапами обслуживания любого звонка, каким бы не-

значительным он ни был, вынуждал систему запускать новую службу. В дей-

ствительности все переходы описывались в текстовом файле, который читала 

система. Каждое событие, поступающее в систему по телефонной линии, вызы-

вало соответствующий переход между службами. Существующий процесс мог 

запускать для обработки события новый процесс, в соответствии с текущим со-

стоянием; затем существующий процесс мог завершиться или ждать в очереди.

Такое решение позволяло нам изменять порядок выполнения операций без из-

менения кода (принцип открытости/закрытости). Мы легко могли добавлять 

новые службы независимо от других и внедрять их в поток, просто изменяя 

текстовый файл с описаниями переходов. Мы могли делать это даже в процес-

се работы системы. Иными словами, у нас появился механизм горячей замены 

и эффективный язык выполнения бизнес-процессов (Business Process Execution 

Language; BPEL).

338   Приложение. Архитектурная археология

Старый прием использования дисковых файлов для взаимодействий между 

службами, реализованный в электронном секретаре, был слишком медленным 

для этих быстро сменяющих друг друга служб, поэтому мы изобрели механизм 

общей памяти, который назвали 3DBB1. Механизм 3DBB позволял обращаться 

к данным по именам; в качестве имен использовались названия, присвоенные 

экземплярам машины состояний.

Общая память прекрасно подходила для хранения строк и констант, но ее 

нельзя было использовать для хранения сложных структур данных. При-

чина была чисто технической. Каждый процесс в MP/M находился в соб-

ственном сегменте памяти. Указатели на данные в одном сегменте не 

имели смысла в другом. Как следствие, данные в общей памяти не могли 

содержать указатели. Строки можно хранить без ограничений, но деревья, 

связные списки и любые другие структуры данных с указателями — нет.

Система заявок получала заявки из разных источников. Некоторые добавля-

лись автоматически, некоторые — вручную. Заявки, добавляемые вручную, 

создавались операторами, общавшимися с клиентами. По мере того как клиент 

описывал проблему, оператор вводил жалобы и наблюдения в структурирован-

ный поток текста. Он выглядел примерно так:

/pno 8475551212 /noise /dropped-calls

Идея должна быть понятна. Символ / начинал новую тему. За этим символом 

следовал код, за кодом — параметры. Таких кодов были тысячи, а в описании 

каждой заявки их могло быть до нескольких десятков. Хуже того, операторы 

часто допускали опечатки или ошибались в форматировании. Люди прекрасно 

справлялись с интерпретацией таких заявок, но не машины.

Перед нами стояла задача — декодировать эти строки, интерпретировать, испра-

вить возможные ошибки и преобразовать их в голосовые сообщения, которые 

могли бы прослушивать ремонтники по телефону. Для этого кроме всего прочего 

требовалось реализовать очень гибкий анализ и формат представления данных. 

Данные в этом формате должны были передаваться через общую память, кото-

рая могла обслуживать только строки.

Итак, в короткие перерывы между посещениями клиентов я изобрел схему, 

которую назвал FLD: Field Labeled Data (данные с маркированными полями). 

В наши дни мы назвали бы этот формат XML или JSON. Формат представле-

ния отличался, но идея была той же. Схема FLD представляла данные в виде 

бинарного дерева, которые ассоциировали имена с данными в рекурсивной 

иерархии. Данные в формате FLD можно было получить с применением про-

1 Three-Dimensional Black Board — трехмерная черная доска. Если вы родились 

в 1950-х годах, вам наверняка более знакомой покажется фраза: Drizzle, Drazzle, 

Druzzle, Drone.

Система командирования ремонтников   339

стого API и преобразовать в строковое представление, идеально подходящее 

для передачи через общую память.

То есть уже в 1985 году микрослужбы обменивались информацией через общую 

память — аналог сокетов, — используя формат, аналогичный XML.

Ничто не ново под луной.

Clear Communications

В 1988 году группа сотрудников Teradyne покинула компанию, чтобы основать 

новую фирму под названием Clear Communications. Я присоединился к ним не-

сколькими месяцами позже. Нашей целью было создание программного обеспе-

чения для системы, осуществлявшей контроль качества связи по линиям T1 — 

цифровым линиям для междугородной связи по всей стране. Мы видели ее как 

огромный монитор с картой США и пересекающей ее сеткой линий T1, которые 

начинали мигать красным, если обнаруживались проблемы.

В 1988 году графические пользовательские интерфейсы только стали появлять-

ся. Модели Apple Macintosh было всего пять лет. Windows в ту пору не стоила 

доброго слова. Но компания Sun Microsystems строила станции Sparc, имевшие 

превосходный графический интерфейс X-Window. Поэтому мы пошли с Sun, 

а значит, с языком C и операционной системой UNIX.

Это был период становления новой компании. Мы работали по 70–80 часов 

в неделю. У нас было в�идение. У нас была мотивация. У нас была воля. У нас 

была энергия. У нас был опыт. Мы были равны. Мы мечтали стать миллионе-

рами. Мы были безрассудны.

Код на C лился из нас как из рога изобилия. Мы вталкивали и впихивали его то 

туда, то сюда. Мы строили огромные воздушные замки. У нас были процессы, оче-

реди сообщений и великолепные архитектуры. Мы написали семиуровневый ISO-

стек взаимодействий с нуля — вплоть до канального уровня передачи данных.

Мы писали код графического интерфейса. ГРЯЗНЫЙ КОД! Бог мой! Мы пи-

сали СЛИШКОМ ГРЯЗНЫЙ КОД.

Я лично написал на C функцию с именем gi() длиной в 3000 строк; ее имя рас-

шифровывалось как Graphic Interpreter (графический интерпретатор). Это был 

шедевр грязи. Это не единственный грязный код, который я написал в Clear, но 

этот был самым позорным.

Архитектура? Вы шутите? Это был период становления. У нас не было време-

ни на архитектуру. Только код, черт возьми! Код, от которого зависело наше 

будущее благополучие!

Поэтому мы писали, писали и писали код. А через три года мы прогорели. Нет, 

мы смогли продать один или два экземпляра системы. Но рынок не особенно 

340   Приложение. Архитектурная археология

интересовался нашим грандиозным видением, и наши инвесторы были уже 

сыты по горло.

В тот момент я ненавидел свою жизнь. Я видел, как прахом идут все мои усилия 

и рушатся мои мечты. У меня стали возникать конфликты на работе, конфликты 

дома из-за работы и конфликты с самим собой.

И тогда я принял телефонный звонок, который все изменил.

Обстановка

За два года до этого звонка произошло два важных события.

Во-первых, мне удалось настроить uucp-соединение с соседней компанией, 

имевшей uucp-соединение с другим объектом, подключенным к Интернету. Это, 

конечно же, были коммутируемые соединения. Наша основная Sparc-станция 

(стоявшая на моем рабочем столе) использовала модем со скоростью передачи 

1200 бит/с для соединения с нашим uucp-хостом дважды в день. Это дало нам 

электронную почту и доступ к Netnews (первой социальной сети, где люди об-

суждали разные интересные вопросы).

Во-вторых, Sun выпустила компилятор C++. Я интересовался языком C++ 

и объектно-ориентированным программированием начиная с 1983 года, но ком-

пилятор тогда было трудно найти. Поэтому, как только представилась возмож-

ность, я сразу же сменил язык. Я оставил функции на C из 3000 строк и начал 

писать код на C++ для Clear. И я учился...

Я читал книги. Конечно, я прочитал The C++ Programming Language1 и The 

Annotated C++ Reference Manua2 Бьёрна Страуструпа. Я прочитал прекрас-

ную книгу Ребекки Вирфс-Брок о проектировании, основанном на ответ-

ственности: Designing Object Oriented Software. Я прочитал OOA, OOD и OOP 

Петера Коуда. Я прочитал Smalltalk-80 Адель Голдберг. Я прочитал Advanced 

C++ Programming Styles and Idioms3 Джеймса О. Коплиена. Но самое глав-

ное, пожалуй, я прочитал Object Oriented Design with Applications4 Гради Буча.

Какое имя! Гради Буч. Как можно забыть такое имя. Более того, он был глав-

ным научным консультантом в компании с названием Rational! Как я хотел 

1 Страуструп Б. Язык программирования C++. М.: Бином, 2017. — Примеч. пер.

2 Эллис М., Строуструп Б. Справочное руководство по языку программирования С++ 

с комментариями. М.: Мир, 1992. — Примеч. пер.

3 Коплиен Д., Программирование на C++. Классика CS. СПб.: Питер, 2004. — Примеч. 

пер.

4 Гради Буч, Роберт А. Максимчук, Майкл У. Энгл, Бобби Дж. Янг, Джим Коналлен, Келли 

А. Хьюстон. Объектно-ориентированный анализ и проектирование с примерами при-

ложений. М.: Вильямс, 2010. — Примеч. пер.

Система командирования ремонтников   341

быть главным научным консультантом! И поэтому я читал его книгу. И учился, 

учился, учился...

Одновременно с учебой я начал вступать в дискуссии на Netnews, подобно 

тому, как ныне люди дискутируют в Facebook. Я участвовал в обсуждениях на 

тему C++ и ООП. В течение двух лет я освобождался от разочарований, кото-

рые приобретал на работе, обсуждая с сотнями пользователей Usenet лучшие 

особенности языка и принципы проектирования. Через какое-то время многое 

для меня стало проясняться.

Именно в одной из таких дискуссий были заложены принципы SOLID.

И все эти обсуждения и, возможно, даже некоторый смысл, который я вносил, 

сделали меня заметным...

Дядюшка Боб

В Clear работал один молодой инженер, Билли Фогель. Билли всем давал про-

звища. Меня он называл дядюшкой Бобом. Мое имя действительно Боб, но 

я подозреваю, что он намекал на Дж. Р. «Боба» Доббса (рис. П.9).

Рис. П.9. Дж. Р. «Боб» Доббс (J. R. «Bob» Dobbs)

Сначала я терпел это. Но проходили месяц за месяцем, и его непрекращающе-

еся: «дядюшка Боб... дядюшка Боб», — на фоне неудач и разочарования новой 

компанией стали вызывать раздражение.

А потом однажды зазвонил телефон.

Телефонный звонок

Это был сотрудник из кадрового агентства. Он узнал мое имя, подыскивая чело-

века, знающего C++ и принципы объектно-ориентированного проектирования. 

Я не знаю, как он его узнал, но предполагаю, что это как-то связано с моим при-

сутствием в Netnews.

342   Приложение. Архитектурная археология

Он сказал, что у него есть свободная вакансия в Кремниевой долине, в ком-

пании Rational. Они искали специалиста для помощи в разработке CASE-

инструмента1.

Кровь отхлынула от моего лица. Я знал, что это за компания. Не знаю, откуда 

я это узнал, но я знал. Это была компания Гради Буча. Я увидел возможность 

оказаться в одной команде с Гради Бучем!

ROSE

Я поступил на работу в компанию Rational, как программист по контракту, 

в 1990 году. Я работал над продуктом с названием ROSE. Это был инструмент, 

позволявший программистам рисовать диаграммы Буча — диаграммы, которые 

Гради использовал в книге Object-Oriented Analysis and Design with Applications 

(пример такой диаграммы изображен на рис. П.10).

Рис. П.10. Диаграмма Буча

Диаграммы Буча были очень выразительными. Они предвосхитили такие диа-

граммы, как UML.

1 Computer Aided Software Engineering — автоматизация разработки программного обес-

печения.

ROSE   343

Продукт ROSE имел архитектуру — настоящую архитектуру. Она состояла из 

истинных уровней, и все зависимости между уровнями были ориентированы 

как должно. Архитектура обеспечила этому продукту возможность раздельного 

выпуска, разработки и развертывания его компонентов.

О, он не был идеальным. Мы еще многого не понимали в архитектурных прин-

ципах. Например, мы не создали истинную структуру со сменными модулями 

(плагинами).

Мы также попались на одно из самых неудачных увлечений тех дней — мы ис-

пользовали так называемую объектно-ориентированную базу данных.

Но в целом опыт был отличным. Я проработал полтора прекрасных года с ко-

мандой из Rational над ROSE. Это был один из самых познавательных опытов 

в моей профессиональной жизни.

Продолжение дискуссий

Конечно, я не прекратил участвовать в обсуждениях на Netnews. В действитель-

ности я резко увеличил свое присутствие в сети. Я начал писать статьи для C++ 

Report. И с помощью Гради приступил к своей первой книге: Designing Object-

Oriented C++ Applications Using the Booch Method.

Одна мысль беспокоила меня. Пусть она была недостойной, но тем не менее. 

Никто не называл меня «дядюшкой Бобом». Я обнаружил, что мне этого не 

хватает. Поэтому я допустил ошибку, добавив подпись «Uncle Bob» (дядюшка 

Боб) в мои электронные письма и сообщения в Netnews. И это имя прилипло 

ко мне. В конце концов я понял, что это довольно неплохой бренд.

...Под любым другим именем

ROSE — это гигантское приложение на C++. Оно состояло из уровней со строго 

соблюдаемым правилом зависимости. Это не то правило, что я описал в данной 

книге. Мы ориентировали наши зависимости не в сторону политик более вы-

сокого уровня, а в более традиционном направлении — в направлении потока 

управления. Пользовательский интерфейс зависел от представления, которое 

зависело от правил выполнения операций с данными, которые зависели от базы 

данных. В результате эта, не совсем удачная ориентация зависимостей способ-

ствовала кончине продукта.

Архитектура ROSE была похожа на архитектуру хорошего компилятора. Гра-

фическая нотация «преобразовывалась» во внутреннее представление; затем 

это представление обрабатывалось правилами и сохранялось в объектно-ори-

ентированной базе данных.

Объектно-ориентированные базы данных были относительно новой идеей, 

и мир ОО был взволнован возможными перспективами. Каждый объектно-

344   Приложение. Архитектурная археология

ориентированный программист желал иметь объектно-ориентированную базу 

данных в своей системе. Идея была относительно простой и глубоко идеали-

стической. База данных хранила объекты, а не таблицы. База данных должна 

была выглядеть как ОЗУ. Когда производилось обращение к объекту, он просто 

возникал в памяти. Если этот объект ссылался на другой объект, тот другой 

объект тоже появлялся в памяти при первой попытке обратиться к нему. Это 

было похоже на волшебство.

Выбор этой базы данных стал, пожалуй, самой большой нашей ошибкой. 

Мы желали волшебства, а в результате получили большой, медленный, на-

вязчивый, дорогостоящий сторонний фреймворк, который превратил нашу 

жизнь в ад, препятствуя нашему движению вперед почти на всех уровнях.

Выбор базы данных был не единственной нашей ошибкой. Гораздо более 

серьезной ошибкой фактически стало излишнее усердие в отношении к про-

ектированию архитектуры. У нас получилось намного больше уровней, чем 

я описал здесь, и каждый привносил свои накладные расходы на взаимодей-

ствия. Это отрицательно сказалось также на продуктивности команды.

В итоге, после многих человеко-лет работы, тяжелой борьбы и выпуска двух 

слабых версий, весь инструмент был заменен маленьким приложением, напи-

санным небольшой командой из Висконсина.

Так я узнал, что великие архитектуры иногда приводят к великим провалам. 

Архитектура должна быть достаточно гибкой, чтобы подстраиваться под размер 

задачи. Разработка архитектуры для уровня предприятия, когда в действитель-

ности нужен маленький и удобный инструмент для настольного компьютера, — 

это верный рецепт провала.

Регистрационные экзамены 

для архитекторов

В начале 1990-х годов я стал настоящим консультантом. Я ездил по миру и обучал 

людей новым объектно-ориентированным подходам. В своих консультациях я стро-

го ограничивался дизайном и архитектурой объектно-ориентированных систем.

Одним из моих первых клиентов была компания Educational Testing Service 

(ETS). Она имела контракт с Национальным советом регистрационной кол-

легии по архитектуре (National Council of Architects Registry Board, NCARB) 

по проведению регистрационных экзаменов для новых кандидатов в архи-

текторы.

Любой желающий стать зарегистрированным архитектором (проектирующим 

здания) в США или Канаде должен сдать регистрационный экзамен. На этом 

экзамене кандидату предлагается решить несколько архитектурных задач, 

Регистрационные экзамены для архитекторов   345

связанных с проектированием зданий. Кандидату передается ряд требований 

для проектирования общественной библиотеки, ресторана или церкви и затем 

предлагается нарисовать комплект архитектурных схем.

Результаты собираются и сохраняются, пока не соберется комиссия ведущих 

архитекторов для оценки. Создание комиссии — большое, дорогостоящее со-

бытие и вечный источник задержек и недопонимания.

Совет NCARB хотел автоматизировать процесс и организовать сдачу экзаменов 

с использованием компьютера, а оценку поданных решений производить с помо-

щью другого компьютера. Совет NCARB предложил компании ETS разработать 

соответствующее программное обеспечение, а ETS наняла меня для создания 

коман ды разработчиков с целью разработки этого продукта.

Компания ETS разбила проблему на 18 экзаменационных заданий. Для каждого 

требовалось создать приложение с графическим интерфейсом в стиле систем 

автоматизированного проектирования, которое кандидат мог бы использовать 

для оформления своего решения. Анализ и оценку решений должны произво-

дить другие 18 приложений.

Мы с моим партнером Джимом Ньюкирком заметили, что эти 36 приложений 

имеют огромное сходство. Все 18 экзаменационных приложений с графиче-

ским интерфейсом должны реализовать схожие операции и использовать 

схожие механизмы. Другие 18 приложений, оценивающие решения, должны 

использовать один и тот же математический аппарат. Учитывая большое коли-

чество общих элементов, Джим и я решили разработать многократно исполь-

зуемую инфраструктуру, которая должна лечь в основу всех 36 приложений. 

Фактически мы продали эту идею компании ETS, заявив, что на разработку 

первого приложения потребуется много времени, зато все последующие будут 

выпущены в течение нескольких недель.

Прочитав эти строки, многие из вас могли бы выразить крайнее удивление. Но чи-

татели постарше наверняка помнят, как объектно-ориентированный подход обе-

щал «многократное использование». В ту пору мы все были убеждены, что если 

писать хороший, чистый, объектно-ориентированный код на C++, в результате 

получится много-много кода, пригодного для многократного использования.

Итак, мы приступили к разработке первого приложения — самого сложного 

в пакете. Мы назвали его Vignette Grande.

Мы вдвоем работали над Vignette Grande с прицелом на создание инфраструк-

туры многократного использования. Нам понадобился год. К концу этого года 

у нас были 45 000 строк инфраструктурного и 6000 строк прикладного кода. Мы 

принесли этот продукт в ETS, и они заключили с нами контракт на создание 

других 17 приложений в ограниченный срок.

Мы с Джимом наняли еще трех разработчиков и приступили к созданию сле-

дующих нескольких экзаменационных приложений.

346   Приложение. Архитектурная археология

Но что-то пошло не так. Мы обнаружили, что наша инфраструктура оказалась 

почти непригодна для многоразового использования. Она не вписывалась в но-

вые приложения. Имелись шероховатости, мешавшие работе.

Мы были сильно обескуражены, но считали, что знаем, как поступить с этим. 

Мы пришли в ETS и сказали, что задерживаемся — что 45 000-строчную инфра-

структуру требуется переписать или хотя бы скорректировать и что для этого 

потребуется еще много времени.

Я думаю, излишне говорить, что в ETS не очень обрадовались этой новости. 

Тем не менее мы начали все сначала. Мы отложили старую инфраструктуру 

и приступили к созданию сразу четырех новых экзаменационных приложе-

ний. Мы заимствовали некоторые идеи и код из старой инфраструктуры, но 

переделывали их так, чтобы они вписывались во все четыре приложения без 

изменений.

На это ушел еще один год. Мы написали другую инфраструктуру с 45 000 строк 

кода плюс четыре экзаменационных приложения, содержавших от 3000 до 

6000 строк каждое. Разумеется, отношения между приложениями и инфра-

структурой следовали правилу зависимости. Приложения были плагинами 

для инфраструктуры. Все высокоуровневые политики находились в инфра-

структуре. Прикладной код просто «склеивал» разные операции.

Отношения между инфраструктурой и приложениями оценки решений оказались 

намного сложнее. Высокоуровневая политика оценки находилась в приложении. 

Инфраструктура оценки подключалась как плагин к приложению оценки.

Конечно, приложения обоих видов компоновались статически, поэтому в на-

ших головах полностью отсутствовало понятие «плагин». И тем не менее за-

висимости были выстроены в полном соответствии с правилом зависимости.

Закончив эти четыре приложения, мы приступили к следующим четырем. На 

этот раз они были готовы через несколько недель, как мы и предсказывали. 

Непреду смотренная задержка отняла у нас почти год, поэтому, чтобы ускорить 

процесс и уложиться в график, мы наняли еще одного программиста.

Мы уложились в срок и выполнили свои обязательства. Наш клиент был счаст-

лив. Мы были счастливы. Жизнь была прекрасна.

Но мы получили хороший урок: нельзя создать универсальную инфраструк-

туру, не создав прежде работающую инфраструктуру. Универсальные инфра-

структуры должны создаваться одновременно с несколькими приложениями, 

использующими их.

Заключение   347

Заключение

Как я сказал вначале, это приложение несколько автобиографично. Я описал 

наиболее яркие моменты в проектах, которые, по моему мнению, имели большое 

архитектурное влияние. И конечно, я привел несколько эпизодов, не имеющих 

прямого отношения к технической стороне книги, но которые тем не менее 

имели большое значение.

Разумеется, это далеко не полная история. В моей карьере было много других 

проектов. Кроме того, я намеренно ограничил освещение истории началом 

1990-х годов, потому что у меня есть еще одна книга, посвященная событиям 

конца 1990-х годов.

Я надеюсь, что вам понравился этот небольшой экскурс по волнам моей памяти 

и вы смогли почерпнуть что-то новое из моего опыта. 

Послесловие

Моя профессиональная карьера разработчика началась в 1990-е годы — в те 

времена, когда миром правили динозавры от Большой Архитектуры. Что-

бы преуспеть в своей области, разработчик должен был изучать объекты 

и компоненты, паттерны проектирования и язык UML (а также его пред-

шественников).

Проекты — и кому только в голову пришло их так назвать? — начинались 

с долгих фаз проектирования, когда «старшие» программисты строили под-

робные планы наших систем, а «младшим» программистам полагалось этим 

планам следовать. Чего они, разумеется, не делали. Никогда.

И все шло к тому, что после перехода во влиятельные круги «специалиста 

по архитектуре ПО» — а потом и «ведущего специалиста по архитектуре», 

«главного специалиста по архитектуре», «лорда-специалиста по архитек-

туре при Тайном Совете» и всех прочих помпезных титулов, которыми мы 

награждали себя в те дни, — я буду обречен проводить свой век, соединяя 

прямоугольники стрелочками и «программируя» в PowerPoint, не оказывая 

сколько-нибудь заметного влияния на реальный код.

Все это выглядело крайне нелепо; ведь каждая строка кода подразумевает 

как минимум одно решение из области проектирования. А значит, каждый, 

кто пишет код, влияет на качество продукта намного сильнее, чем «оператор 

PowerPoint» вроде меня.

К счастью, потом произошла революция Гибкой Разработки Программного 

Обеспечения, которая положила конец страданиям специалистов по архи-

тектуре. Я — программист. Мне нравится программировать. А лучший из-

вестный мне способ оказать положительное влияние на код — написать его.

Динозавры Большой Архитектуры — которые обычно разгуливали по 

первобытным равнинам Больших Процессов — были уничтожены астеро-

идом Экстремального Программирования. И все вздохнули с облегчением.

Послесловие   349

Команды разработчиков могли спокойно сосредоточиться на том, что было 

действительно важно, и направить свои усилия на создание ценности про-

дукта. Вместо того чтобы неделями и месяцами дожидаться документа 

с Большой Архитектурой, который можно было спокойно проигнорировать 

и написать код так, как они считали нужным, команды просто решили про-

вести тестирование с заказчиком, устроить быструю встречу, чтобы сориен-

тироваться в происходящем, а потом написать код так, как они собирались 

его писать изначально.

Динозавры Большой Архитектуры вымерли, а на наше место пришли ма-

ленькие шустрые млекопитающие Минимального-Предварительного-

Проектирования-с-Обильным-Рефакторингом. Архитектура программного 

продукта стала реагировать на внешние воздействия.

Во всяком случае, это было в теории. 

К сожалению, когда вы поручаете архитектуру программистам, необхо-

димо, чтобы программисты были способны думать как архитекторы. Как 

оказалось, не всё, чему мы научились в эру Большой Архитектуры, было 

бесполезным. Структура программного продукта может серьезно повлиять 

на нашу способность адаптироваться и развивать продукт — даже в кратко-

срочной перспективе.

Каждое решение из области проектирования должно оставлять дверь откры-

той для будущих изменений. Это как в бильярде: ударом нужно не только 

загнать шар в лузу, но и подготовиться к следующему удару. Написание 

работоспособного кода, который не мешает будущему коду, — умение не-

тривиальное. На то, чтобы освоить его, уходят годы.

Итак, эра Большой Архитектуры уступила дорогу новой эре Непрочной 

Архитектуры: решения быстро росли и быстрее приносили пользу, но под-

держивать высокий темп инноваций было очень трудно.

Хорошо, конечно, говорить о «готовности к изменениям», но когда изме-

нение строки кода обходится в пятьсот долларов, изменений обычно не 

происходит.

Исходные статьи Боба Мартина о принципах объектно-ориентированного 

проектирования сильно повлияли на меня, начинающего разработчика. 

Я взглянул на свой код с новой стороны и заметил то, что до этого момента 

никогда не казалось мне проблемой.

Вы узнали, как писать код, приносящий пользу сегодня, но не блокирующий 

завтрашнюю пользу; теперь ваша задача — дополнить теорию практикой, 

чтобы применить эти принципы в своем коде.

350   Послесловие

Освоить проектирование программных продуктов только по книге невоз-

можно — подобно тому, как невозможно по книге научиться кататься на ве-

лосипеде. Чтобы извлечь максимальную пользу из такой книги, необходимо 

практиковаться. Проанализируйте свой код, найдите проблемы, о которых 

говорит Боб, а затем примените рефакторинг для исправления этих проблем. 

Если у вас еще недостаточно опыта в дисциплине рефакторинга, это будет 

вдвойне полезно.

Научитесь интегрировать принципы проектирования и Чистой Архитек-

туры в процессе разработки, чтобы снизить вероятность возникновения 

проблем в новом коде. Например, если вы практикуете разработку через 

тестирование, заведите привычку устраивать небольшой структурный 

анализ после прохождения каждого теста и чистите код на ходу. (Это обой-

дется намного дешевле, чем исправлять неудачные структурные решения 

позднее.) Возможно, перед фиксацией изменений кода стоит попросить 

коллегу проанализировать код вместе с вами. Также рассмотрите возмож-

ность включения кода «отслеживания качественных характеристик» в ваш 

процесс сборки как последней линии защиты от «нечистых» архитектур. 

(А если у вас еще нет процесса сборки, может, пора его создать?)

Очень важно говорить о Чистой Архитектуре. Говорите о ней со своей 

командой. Говорите о ней в более широком сообществе разработчиков. Ка-

чество касается каждого, и важно достичь консенсуса в различиях между 

хорошей и плохой архитектурой.

Учтите, что многие разработчики не особо задумываются об архитектуре, 

как это было со мной 25 лет назад. Более опытные разработчики указали 

мне на это. Когда вы разберетесь в Чистой Архитектуре, не жалейте времени 

и помогите разобраться в ней другим. Делитесь полученным опытом.

Хотя технологический ландшафт для разработчиков постоянно развивается, 

фундаментальные принципы — например, описанные в этой книге — редко 

меняются. Я не сомневаюсь, что эта книга останется на вашей полке еще 

много лет после того, как экземпляр «Lean JSON Cloud NoSQL для чайников» 

отправится в макулатуру. Надеюсь, книга станет для вашего мастерства про-

ектирования тем, чем стали для меня статьи Боба.

Настоящее путешествие только начинается.

Джейсон Горман, 26 января 2017 г.

 Роберт Мартин

Чистая архитектура. 

Искусство разработки программного обеспечения

Перевел с английского А. Киселев

 

Заведующая редакцией 

Ю. Сергиенко

 

Ведущий редактор 

Н. Римицан

 

Литературный редактор 

Е. Герасимова

 

Художественный редактор 

С. Заматевская

 

Корректоры 

С. Беляева, Н. Викторова

 

Верстка 

Л. Егорова

Изготовлено в России. Изготовитель: ООО «Прогресс книга». 

 Место нахождения и фактический адрес: 194044, Россия, г. Санкт-Петербург, 

 Б. Сампсониевский пр., д. 29А, пом. 52. Тел.: +78127037373. 

 Дата изготовления: 08.2020. Наименование: книжная продукция. Срок годности: не ограничен. 

Налоговая льгота — общероссийский классификатор продукции ОК 034-2014,  

58.11.12 — Книги печатные профессиональные, технические и научные. 

Импортер в Беларусь: ООО «ПИТЕР М», 220020, РБ, г. Минск, ул. Тимирязева,  

д. 121/3, к. 214, тел./факс: 208 80 01. 

Подписано в печать 12.08.20. Формат 70х100/16. Бумага офсетная. Усл. п. л. 28,380. Доп. тираж

 2000. Заказ 0000 

</p>
   </article>
</body>
</html>
