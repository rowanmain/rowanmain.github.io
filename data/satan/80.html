<!DOCTYPE html>
<html>
<head>
   <title>Моя статья</title>
   <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<style>
body {
   background-color: #f0f0f0;
   font-family: Arial, sans-serif;
}

header {
   background-color: #333;
   color: white;
   padding: 10px;
   text-align: center;
}

h1 {
   margin: 0;
}

article {
   margin: 20px;
}

h2 {
   color: #333;
}

p {
   line-height: 1.6;
}
</style>
<body>
   <header>
       <h1>статья</h1>
   </header>
   <article>
       <p>
Заключение

Диаграмма архитектуры на рис . 33 .2 включает разделение по двум измере-

ниям . Первое — разделение на основе действующих лиц согласно принципу 

единственной ответственности; второе соответствует правилу зависимости . 

Цель обоих — разделить компоненты, изменяющиеся по разным причинам 

и с разной скоростью . Причины в данном случае соответствуют действую-

щим лицам, а скорости — разным уровням политик .

После структуризации кода таким способом появляется возможность сме-

шивать и распределять его по единицам развертывания как угодно . Вы смо-

жете группировать компоненты в любые единицы развертывания, имеющие 

смысл, и менять правила группировки с изменением условий .

34 Недостающая глава

Автор: Симон Браун (Simon Brown), 2 марта 2017

Упаковка по уровням      289

Все советы, которые вы прочитали к настоящему моменту, безусловно, по-

могут вам проектировать замечательные приложения, состоящие из классов 

и компонентов с четко определенными границами, понятными обязан-

ностями и управляемыми зависимостями . Но как всегда, дьявол кроется 

в деталях реализации, и действительно, очень легко споткнуться о последнее 

препятствие, если не уделить ему должного внимания .

Представим, что мы строим книжный онлайн-магазин и один из вариантов 

использования, который нам предлагается внедрить, — возможность про-

смотра клиентами состояния своих заказов . Пример, следующий ниже, 

описывается с позиции языка Java, однако принципы в равной степени 

применимы к другим языкам программирования . Отложим пока чистую 

архитектуру в сторону и рассмотрим не-

сколько подходов к проектированию и ор-

ганизации кода .

Упаковка по уровням

Первый и самый простой, пожалуй, под-

ход — организация традиционной много-

уровневой архитектуры, в которой код раз-

деляется по функциональному признаку . 

Этот подход часто называют «упаковкой по 

уровням» . На рис . 34 .1 показано, как мог-

ла бы выглядеть соответствующая UML-

диаграмма классов .

В такой типичной многоуровневой архи-

тектуре один уровень выделяется для веб-

кода, один уровень — для «бизнес-логики» 

и один уровень — для работы с хранилищем 

данных . Иными словами, горизонтальные 

уровни используются как способ груп-

пировки по подобию . В «строгой много-

уровневой архитектуре» уровни должны 

зависеть только от следующего смежного 

уровня . В Java уровни обычно реализуются 

в виде пакетов . Как показано на рис . 34 .1, 

все зависимости между уровнями (пакета-

ми) направлены вниз . В этом примере у нас 

имеются следующие Java-типы:

<<использует>>

<<использует>>

<<интерфейс>>

<<интерфейс>>

Рис. 34.1. Упаковка по уровням

290   Глава 34. Недостающая глава

 

� OrdersController: веб-контроллер, иногда что-то вроде MVC-контроллера 

из Spring, обрабатывающего запросы из Веб .

 

� OrdersService: интерфейс, определяющий «бизнес-логику», связанную 

с заказами .

 

� OrdersServiceImpl: реализация службы заказов1 .

 

� OrdersRepository: интерфейс, определяющий порядок доступа к инфор-

мации о заказах в хранилище .

 

� JdbcOrdersRepository: реализация интерфейса хранилища .

В своей статье Presentation Domain Data Layering2 («Многоуровневая 

организация: представление, бизнес-логика, данные») Мартин Фаулер 

написал, что такая трехуровневая организация отлично подходит для на-

чального этапа . И он не одинок . Во многих книгах, руководствах, курсах 

и примерах кода демонстрируются способы создания многоуровневой 

архитектуры . Это очень быстрый способ без особых затруднений создать 

и запустить что-то . Проблема, как указывает Мартин, в том, что с ростом 

масштаба и сложности программного обеспечения трех больших слоев 

кода оказывается недостаточно и приходится задумываться о более дроб-

ной организации .

Другая проблема, как уже сказал «дядюшка Боб»3, — многоуровневая архи-

тектура не кричит о своем практическом назначении . Поместите рядом код 

двух многоуровневых архитектур из разных предметных областей, и они 

почти наверняка будут выглядеть пугающе похожими: веб-интерфейсы, 

службы и хранилища . Многоуровневые архитектуры страдают еще от одного 

большого недостатка, но мы поговорим о нем позже .

Упаковка по особенностям

Другой вариант организации кода — «упаковка по особенностям» . Это 

разделение по вертикали, основанное на объединении связанных особен-

ностей, предметных понятий и общих корней (если использовать терми-

нологию предметно-ориентированного проектирования) . В типичных 

реализациях, которые мне доводилось видеть, все типы помещаются в один 

1 Это ужасное имя для класса, но, как будет показано ниже, в действительности это не 

имеет большого значения .

2 https://martinfowler.com/bliki/PresentationDomainDataLayering.html .

3 Псевдоним «дядюшка Боб» (Uncle Bob) принадлежит автору этой книги Роберту 

Мартину . — Примеч. пер.

Порты и адаптеры      291

Java-пакет, имя которого отражает идею 

группировки .

</p>
   </article>
</body>
</html>
