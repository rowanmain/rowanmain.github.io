<!DOCTYPE html>
<html>
<head>
   <title>Моя статья</title>
   <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<style>
body {
   background-color: #f0f0f0;
   font-family: Arial, sans-serif;
}

header {
   background-color: #333;
   color: white;
   padding: 10px;
   text-align: center;
}

h1 {
   margin: 0;
}

article {
   margin: 20px;
}

h2 {
   color: #333;
}

p {
   line-height: 1.6;
}
</style>
<body>
   <header>
       <h1>статья</h1>
   </header>
   <article>
       <p>
только направлением потока управления . Неважно, какой модуль вызыва-

ет и какой модуль вызывается, архитектор может определить зависимость 

в исходном коде в любом направлении .

Какая возможность! И эту возможность открывает ОО . Собственно, это все, 

что дает ОО, — по крайней мере с точки зрения архитектора .

Что можно сделать, обладая этой возможностью? Можно, например, пере-

упорядочить зависимости в исходном коде так, что база данных и пользова-

тельский интерфейс (ПИ) в вашей системе будут зависеть от бизнес-правил 

(рис . 5 .3), а не наоборот .

ПИ

Рис. 5.3. База данных и пользовательский интерфейс зависят от бизнес-правил

Это означает, что ПИ и база данных могут быть плагинами к бизнес-прави-

лам . То есть в исходном коде с реализацией бизнес-правил могут отсутство-

вать любые ссылки на ПИ или базу данных .

Как следствие, бизнес-правила, ПИ и базу данных можно скомпилировать 

в три разных компонента или единицы развертывания (например, jar-

файлы, библиотеки DLL или файлы Gem), имеющих те же зависимости, 

как в исходном коде . Компонент с бизнес-правилами не будет зависеть от 

компонентов, реализующих ПИ и базу данных .

Как результат, появляется возможность развертывать бизнес-правила неза-

висимо от ПИ и базы данных . Изменения в ПИ или в базе данных не должны 

оказывать никакого влияния на бизнес-правила . То есть компоненты можно 

развертывать отдельно и независимо .

Проще говоря, когда реализация компонента изменится, достаточно повтор-

но развернуть только этот компонент . Это независимость развертывания .

Если система состоит из модулей, которые можно развертывать независимо, 

их можно разрабатывать независимо, разными командами . Это независи-

мость разработки .

66   Глава 5. Объектно-ориентированное программирование  

Заключение

Что такое ОО? Существует много взглядов и ответов на этот вопрос . Од-

нако для программного архитектора ответ очевиден: ОО дает, посредством 

поддержки полиморфизма, абсолютный контроль над всеми зависимостя-

ми в исходном коде . Это позволяет архитектору создать архитектуру со 

сменными модулями (плагинами), в которой модули верхнего уровня не 

зависят от модулей нижнего уровня . Низкоуровневые детали не выходят 

за рамки модулей плагинов, которые можно развертывать и разрабатывать 

независимо от модулей верхнего уровня .

6

Функциональное 

программирование

68   Глава 6. Функциональное программирование

Многие идеи функционального программирования появились задолго 

до появления самого программирования . Эта парадигма в значитель-

ной мере основана на λ-исчислении, изобретенном Алонзо Чёрчем 

в 1930-х годах .

Квадраты целых чисел

Суть функционального программирования проще объяснить на примерах . 

С этой целью исследуем решение простой задачи: вывод квадратов первых 

25 целых чисел (то есть от 0 до 24) .

В языках, подобных Java, эту задачу можно решить так:

public class Squint {

  public static void main(String args[]) {

    for (int i=0; i<25; i++)

      System.out.println(i*i);

  }

}

В Clojure, функциональном языке и производном от языка Lisp, аналогич-

ную программу можно записать так:

(println (take 25 (map (fn [x] (* x x)) (range))))

Этот код может показаться немного странным, если вы не знакомы с Lisp . 

Поэтому я, с вашего позволения, немного переоформлю его и добавлю не-

сколько комментариев .

(println ;___________________ Вывести

  (take 25 ;_________________ первые 25

    (map (fn [x] (* x x)) ;__ квадратов

      (range)))) ;___________ целых чисел

Совершенно понятно, что println, take, map и range — это функции . В языке 

Lisp вызов функции производится помещением ее имени в круглые скобки . 

Например, (range) — это вызов функции range .

Выражение (fn [x] (* x x)) — это анонимная функция, которая, в свою 

очередь, вызывает функцию умножения и передает ей две копии входного 

аргумента . Иными словами, она вычисляет квадрат заданного числа .

Взглянем на эту программу еще раз, начав с самого внутреннего вызова 

функции:

Неизменяемость и архитектура      69

 

� функция range возвращает бесконечный список целых чисел, начи-

ная с 0;

 

� этот список передается функции map, которая вызывает анонимную 

функцию для вычисления квадрата каждого элемента и производит бес-

конечный список квадратов;

 

� список квадратов передается функции take, которая возвращает новый 

список, содержащий только первые 25 элементов;

 

� функция println выводит этот самый список квадратов первых 25 целых 

чисел .

Если вас напугало упоминание бесконечных списков, не волнуйтесь . В дей-

ствительности программа создаст только первые 25 элементов этих беско-

нечных списков . Дело в том, что новые элементы бесконечных списков не 

создаются, пока программа не обратится к ним .

Если все вышесказанное показалось вам запутанным и непонятным, тогда 

можете отложить эту книгу и прекрасно провести время, изучая функцио-

нальное программирование и язык Clojure . В этой книге я не буду рассма-

тривать эти темы, так как не это является моей целью .

Моя цель — показать важнейшее отличие между программами на Clojure 

и Java . В программе на Java используется изменяемая переменная — пере-

менная, состояние которой изменяется в ходе выполнения программы . Это 

</p>
   </article>
</body>
</html>
