<!DOCTYPE html>
<html>
<head>
   <title>Моя статья</title>
   <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<style>
body {
   background-color: #f0f0f0;
   font-family: Arial, sans-serif;
}

header {
   background-color: #333;
   color: white;
   padding: 10px;
   text-align: center;
}

h1 {
   margin: 0;
}

article {
   margin: 20px;
}

h2 {
   color: #333;
}

p {
   line-height: 1.6;
}
</style>
<body>
   <header>
       <h1>статья</h1>
   </header>
   <article>
       <p>
Обратите внимание, что поток управления пересекает извилистую линию 

в направлении, обратном направлению зависимостей в исходном коде . 

104   Глава 11. Принцип инверсии зависимости

Зависимости следуют в направлении, противоположном направлению по-

тока управления — именно поэтому принцип получил название принципа 

инверсии зависимости .

Конкретные компоненты

Конкретный компонент ConcreteImpl на рис . 11 .1 имеет единственную за-

висимость, то есть он нарушает принцип DIP . Это нормально . Полностью 

устранить любые нарушения принципа инверсии зависимости невозможно, 

но их можно сосредоточить в узком круге конкретных компонентов и изо-

лировать от остальной системы .

Большинство систем будет содержать хотя бы один такой конкретный ком-

понент — часто с именем main, потому что включает функцию main1 . В схеме, 

изображенной на рис . 11 .1, функция main могла бы создавать экземпляр 

ServiceFactoryImpl и сохранять ссылку на него в глобальной переменной 

типа ServiceFactory . Благодаря этому приложение Application сможет ис-

пользовать данную глобальную переменную для обращения к фабрике .

Заключение

По мере продвижения вперед и знакомства с высокоуровневыми архитек-

турными принципами мы снова и снова будем сталкиваться с принципом 

инверсии зависимостей . Он будет самым заметным организационным прин-

ципом в наших архитектурных диаграммах . Извилистая линия на рис . 11 .1 

часто будет обозначать архитектурные границы в последующих главах . 

Зависимости будут пересекать эту извилистую линию в одном направле-

нии, в сторону более абстрактных сущностей, и это станет для нас новым 

правилом, которое мы будем называть правилом зависимостей .

1 То есть функцию, которая вызывается операционной системой в момент запуска при-

ложения .

IV 

Принципы 

организации 

компонентов

Принципы SOLID определяют, как выкладывать кирпичами стены, обра-

зующие комнаты, а принципы организации компонентов — как размещать 

комнаты в зданиях . Большие программные системы, подобно большим 

зданиям, строятся из меньших компонентов .

В части IV мы познакомимся с программными компонентами, узнаем, из 

каких элементов они состоят и как конструировать системы из них .

12 Компоненты

Краткая история компонентов      107

Компоненты — это единицы развертывания . Они представляют наименьшие 

сущности, которые можно развертывать в составе системы . В Java — это jar-

файлы . В Ruby — gem-файлы . В  .Net — библиотеки DLL . В компилирующих 

языках — комплексы двоичных файлов . В интерпретирующих языках — 

комплексы файлов с исходным кодом . Во всех языках — элементарная 

единица развертывания .

Компоненты могут объединяться в один выполняемый файл, собираться 

в один архив, например файл .war, или развертываться независимо, как 

отдельные плагины, загружаемые динамически, такие как файлы .jar, .dll 

или .exe . Но независимо от способа развертывания, правильно спроекти-

рованные компоненты всегда сохраняют возможность независимого раз-

вертывания и, соответственно, могут разрабатываться независимо .

Краткая история компонентов

На заре разработки программного обеспечения программисты сами опреде-

ляли организацию памяти в своих программах . В первых строках кода часто 

присутствовала инструкция origin, объявлявшая начальный адрес в памяти 

для загрузки программы .

Взгляните не следующую простую программу для PDP-8 . Она состоит 

из подпрограммы с именем GETSTR, которая принимает ввод с клавиатуры 

в виде строки и сохраняет его в буфер . В ней также имеется короткий мо-

дульный тест для проверки GETSTR .

        *200

        TLS

START,   CLA

        TAD BUFR

        JMS GETSTR

        CLA

        TAD BUFR

        JMS PUTSTR

        JMP START

BUFR,   3000

GETSTR, 0

        DCA PTR

NXTCH,  KSF

        JMP -1

        KRB

        DCA I PTR

        TAD I PTR

108   Глава 12. Компоненты

        AND K177

        ISZ PTR

        TAD MCR

        SZA

        JMP NXTCH

K177,   177

MCR,    -15

Обратите внимание на команду *200 в начале программы . Она сообщает 

компилятору, что сгенерированный им код будет загружаться в память, на-

чиная с адреса 2008 (в восьмеричной системе счисления) .

Такой способ программирования чужд современным программистам . Они 

редко задумываются, в какую область памяти будет загружаться программа . 

Но давным-давно это было одним из первых решений, которые программист 

должен был принять . В ту пору программы были неперемещаемыми .

Как осуществлялся доступ к библиотечным функциям в те дни? Это ил-

люстрирует предыдущий пример . Программисты включали исходный код 

библиотек в свои программы и компилировали их как одно целое1 . Библио-

теки хранились в исходном коде, а не в двоичном .

Проблема такого подхода в ту эпоху состояла в том, что устройства были 

медленными, а память стоила дорого, и поэтому ее объем был ограничен . 

</p>
   </article>
</body>
</html>
