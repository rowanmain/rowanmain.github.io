<!DOCTYPE html>
<html>
<head>
   <title>Моя статья</title>
   <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<style>
body {
   background-color: #f0f0f0;
   font-family: Arial, sans-serif;
}

header {
   background-color: #333;
   color: white;
   padding: 10px;
   text-align: center;
}

h1 {
   margin: 0;
}

article {
   margin: 20px;
}

h2 {
   color: #333;
}

p {
   line-height: 1.6;
}
</style>
<body>
   <header>
       <h1>статья</h1>
   </header>
   <article>
       <p>
переменная i — переменная цикла . В программе на Clojure, напротив, нет 

изменяемых переменных . В ней присутствуют инициализируемые пере-

менные, такие как x, но они никогда не изменяются .

В результате мы пришли к удивительному утверждению: переменные 

в функциональных языках не изменяются .

Неизменяемость и архитектура

Почему этот аспект важен с архитектурной точки зрения? Почему архитек-

тора должна волновать изменчивость переменных? Ответ на этот вопрос до 

нелепого прост: все состояния гонки (race condition), взаимоблокировки 

(deadlocks) и проблемы параллельного обновления обусловлены изменя-

емостью переменных . Если в программе нет изменяемых переменных, она 

никогда не окажется в состоянии гонки и никогда не столкнется с пробле-

мами одновременного изменения . В отсутствие изменяемых блокировок 

программа не может попасть в состояние взаимоблокировки .

70   Глава 6. Функциональное программирование

Иными словами, все проблемы, характерные для приложений с конкури-

рующими вычислениями, — с которыми нам приходится сталкиваться, 

когда требуется организовать многопоточное выполнение и задействовать 

вычислительную мощность нескольких процессоров, исчезают сами собой 

в отсутствие изменяемых переменных .

Вы, как архитектор, обязаны интересоваться проблемами конкуренции . Вы 

должны гарантировать надежность и устойчивость проектируемых вами си-

стем в многопоточном и многопроцессорном окружении . И один из главных 

вопросов, которые вы должны задать себе: достижима ли неизменяемость 

на практике?

Ответ на этот вопрос таков: да, если у вас есть неограниченный объем па-

мяти и процессор с неограниченной скоростью вычислений . В отсутствие 

этих бесконечных ресурсов ответ выглядит не так однозначно . Да, неизме-

няемость достижима, но при определенных компромиссах .

Рассмотрим некоторые из этих компромиссов .

Ограничение изменяемости

Один из самых общих компромиссов, на которые приходится идти ради 

неизменяемости, — деление приложения или служб внутри приложения 

на изменяемые и неизменяемые компоненты . Неизменяемые компоненты 

решают свои задачи исключительно функциональным способом, без ис-

пользования изменяемых переменных . Они взаимодействуют с другими 

компонентами, не являющимися чисто функциональными и допускающими 

изменение состояний переменных (рис . 6 .1) .

Изменяемое состояние этих других компонентов открыто всем проблемам 

многопоточного выполнения, поэтому для защиты изменяемых переменных 

от конкурирующих обновлений и состояния гонки часто используется не-

которая разновидность транзакционной памяти .

Транзакционная память интерпретирует переменные в оперативной памяти 

подобно тому, как база данных интерпретирует записи на диске . Она защи-

щает переменные, применяя механизм транзакций с повторениями .

Простым примером могут служить атомы в Clojure:

(def counter (atom 0)) ; инициализировать счетчик нулем

(swap! counter inc)    ; безопасно увеличить счетчик counter.

Ограничение изменяемости      71

Рис. 6.1. Изменяемое состояние и транзакционная память

В этом фрагменте переменная counter определяется как атом (с помощью 

функции atom) . Атом в языке Clojure — это особая переменная, способная 

изменяться при очень ограниченных условиях, соблюдение которых гаран-

тирует функция swap! .

Функция swap!, показанная в предыдущем фрагменте, принимает два ар-

гумента: атом, подлежащий изменению, и функцию, вычисляющую новое 

значение для сохранения в атоме . В данном примере атом counter получит 

значение, вычисленное функцией inc, которая просто увеличивает свой 

аргумент на единицу .

Функция swap! реализует традиционный алгоритм сравнить и присвоить . 

Она читает значение counter и передает его функции inc . Когда inc вернет 

управление, доступ к переменной counter блокируется и ее значение сравни-

вается со значением, переданным в inc . Если они равны, в counter записыва-

ется значение, которое вернула функция inc, и блокировка освобождается . 

Иначе блокировка освобождается и попытка повторяется .

Механизм атомов эффективен для простых приложений . Но, к сожалению, 

он не гарантирует абсолютную защищенность от конкурирующих обновле-

ний и взаимоблокировок, когда в игру вступает несколько взаимозависимых 

изменяемых переменных . В таких ситуациях предпочтительнее использо-

вать более надежные средства .

Суть в том, что правильно организованные приложения должны делиться 

на компоненты, имеющие и не имеющие изменяемых переменных . Такое 

72   Глава 6. Функциональное программирование

деление обеспечивается использованием подходящих дисциплин для за-

щиты изменяемых переменных .

Со стороны архитекторов было бы разумно как можно больше кода поме-

стить в неизменяемые компоненты и как можно меньше — в компоненты, 

допускающие возможность изменения .

Регистрация событий

Проблема ограниченности объема памяти и конечной вычислительной 

мощности процессоров очень быстро теряет свою актуальность . В настоя-

щее время обычными стали компьютеры с процессорами, выполняющими 

миллиарды инструкций в секунду, и имеющие объем оперативной памяти 

в несколько миллиардов байтов . Чем больше памяти, тем быстрее работает 

компьютер и тем меньше потребность в изменяемом состоянии .

Как простой пример, представьте банковское приложение, управляющее 

счетами клиентов . Оно изменяет счета, когда выполняются операции за-

числения или списания средств .

Теперь вообразите, что вместо сумм на счетах мы сохраняем только ин-

формацию об операциях . Всякий раз, когда кто-то пожелает узнать баланс 

своего счета, мы просто выполняем все транзакции с состоянием счета от 

момента его открытия . Эта схема не требует изменяемых переменных .

Очевидно, такой подход кажется абсурдным . С течением времени коли-

чество транзакций растет и в какой-то момент объем вычислений, необ-

ходимый для определения баланса счета, станет недопустимо большим . 

Чтобы такая схема могла работать всегда, мы должны иметь неограни-

ченный объем памяти и процессор с бесконечно высокой скоростью вы-

числений .

Но иногда не требуется, чтобы эта схема работала всегда . Иногда у нас доста-

точно памяти и вычислительной мощности, чтобы подобная схема работала 

</p>
   </article>
</body>
</html>
