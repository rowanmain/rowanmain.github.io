<!DOCTYPE html>
<html>
<head>
   <title>Моя статья</title>
   <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<style>
body {
   background-color: #f0f0f0;
   font-family: Arial, sans-serif;
}

header {
   background-color: #333;
   color: white;
   padding: 10px;
   text-align: center;
}

h1 {
   margin: 0;
}

article {
   margin: 20px;
}

h2 {
   color: #333;
}

p {
   line-height: 1.6;
}
</style>
<body>
   <header>
       <h1>статья</h1>
   </header>
   <article>
       <p>
      }

    String playerCavern = anyCavern();

    game.setPlayerCavern(playerCavern);

    game.setWumpusCavern(anyOther(playerCavern));

    game.addBatCavern(anyOther(playerCavern));

    game.addBatCavern(anyOther(playerCavern));

    game.addBatCavern(anyOther(playerCavern));

    game.addPitCavern(anyOther(playerCavern));

    game.addPitCavern(anyOther(playerCavern));

    game.addPitCavern(anyOther(playerCavern));

    game.setQuiver(5);

  }

  // здесь следует еще много кода... 

}

Компонент Main — самый грязный низкоуровневый модуль, находящийся 

во внешнем круге чистой архитектуры . Он загружает все, что потребуется 

системе более высокого уровня, а затем передает ей управление .

Заключение

Представьте, что Main является плагином для приложения — плагином, ко-

торый настраивает начальное окружение, загружает все внешние ресурсы 

и затем передает управление политике верхнего уровня . Так как это плагин, 

может иметься множество компонентов Main, по одному для каждой конфи-

гурации приложения .

Например, у нас может иметься плагин Main для разработки, еще один для 

тестирования и третий для эксплуатации . Можно также создать по плагину 

Main для каждой страны, или каждой юрисдикции, или каждого клиента .

Когда вы начинаете думать о компоненте Main как о плагине, находящемся 

за архитектурной границей, проблемы настройки решаются намного проще .

27

Службы: 

большие и малые

234   Глава 27. Службы: большие и малые

Сервис-ориентированные «архитектуры» и микросервисные «архитектуры» 

приобрели особую популярность в последнее время . Эта популярность обу-

словлена, в том числе, следующими причинами:

 

� Службы выглядят полностью независимыми друг от друга . Но, как мы 

увидим далее, это верно лишь отчасти .

 

� Службы, похоже, можно разрабатывать и развертывать независимо . 

И снова, как мы увидим далее, это верно лишь отчасти .

Сервисная архитектура?

Прежде всего уточним, что утверждение, будто использование служб по 

своей природе является архитектурой, в принципе неверно . Архитектура 

системы определяется границами, отделяющими высокоуровневые по-

литики от низкоуровневых деталей, и следованием правилу зависимостей . 

Службы, просто делящие приложение на функциональные элементы, по 

сути, являются лишь функциями, вызовы которых обходятся довольно до-

рого и не обязательно имеют важное архитектурное значение .

То есть не все службы должны быть архитектурно значимыми . Часто бывает 

выгодно создавать службы, распределяющие функциональные возможности 

по разным процессам и платформам, независимо от того, подчиняются ли 

они правилу зависимостей . Службы сами по себе не определяют архитек-

туру .

Наглядной аналогией является организация функций . Архитектура моно-

литной или компонентной системы определяется некоторыми вызовами 

функций, пересекающими архитектурные границы и следующими правилу 

зависимостей . Однако многие другие функции в системе просто отделяют 

одно поведение от другого и не являются архитектурно значимыми .

То же верно в отношении служб . Службы, в конечном счете, — это всего 

лишь вызовы функций через границы процессов и/или платформ . Неко-

торые из этих служб действительно являются архитектурно значимыми, 

а другие — нет . Основной интерес для нас в этой главе представляют первые .

Преимущества служб?

Знак вопроса в заголовке указывает, что в этом разделе мы поставим под со-

мнение популярное мнение о сервис-ориентированной архитектуре . Давайте 

рассмотрим предполагаемые преимущества по одному .

Преимущества служб?      235

Заблуждение о независимости

Одно из самых больших предполагаемых преимуществ деления системы 

на службы заключается в полной независимости их друг от друга . В конце 

концов, каждая служба выполняется в отдельном процессе или даже на дру-

гой машине; поэтому службы не имеют доступа к переменным друг друга . 

Более того, для каждой службы должен быть четко определен ее интерфейс .

Все это верно до определенной степени, но не до конца . Да, службы незави-

симы на уровне отдельных переменных . Но они все еще могут быть связаны 

вместе общими ресурсами на одной машине или в сети . Более того, они 

тесно связаны общими данными .

Например, чтобы добавить новое поле в запись, которая передается между 

службами, придется изменить все службы, использующие это новое поле . 

Службы должны также согласовать интерпретацию данных в этом поле . 

То есть службы тесно связаны с записью и, соответственно, косвенно свя-

заны друг с другом .

Утверждение о необходимости четко определять интерфейс тоже верно, но 

оно в той же мере относится к функциям . Интерфейсы служб не являются 

более формальными, строгими и четкими, чем интерфейсы функций . Как 

видите, это преимущество довольно иллюзорно .

Заблуждение о возможности независимой 

разработки и развертывания

Другое предполагаемое преимущество — возможность передачи служб во 

владение отдельным командам . Каждая такая команда может отвечать за 

разработку, сопровождение и эксплуатацию службы, как это предполагает 

стратегия интеграции разработки и эксплуатации (DevOps) . Такая не-

зависимость разработки и развертывания, как предполагается, является 

масштабируемой . Считается, что крупные корпоративные системы могут 

состоять из десятков, сотен и даже тысяч служб, разрабатываемых и раз-

вертываемых независимо . Разработку, сопровождение и эксплуатацию 

системы можно разделить между аналогичным количеством независимых 

команд .

Это утверждение верно, но лишь отчасти . Во-первых, как показывает исто-

</p>
   </article>
</body>
</html>
