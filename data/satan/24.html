<!DOCTYPE html>
<html>
<head>
   <title>Моя статья</title>
   <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<style>
body {
   background-color: #f0f0f0;
   font-family: Arial, sans-serif;
}

header {
   background-color: #333;
   color: white;
   padding: 10px;
   text-align: center;
}

h1 {
   margin: 0;
}

article {
   margin: 20px;
}

h2 {
   color: #333;
}

p {
   line-height: 1.6;
}
</style>
<body>
   <header>
       <h1>статья</h1>
   </header>
   <article>
       <p>
Принцип открытости/

закрытости

86   Глава 8. Принцип открытости/закрытости

Принцип открытости/закрытости (Open-Closed Principle; OCP) был сфор-

мулирован Бертраном Мейером в 1988 году .1 Он гласит:

Программные сущности должны быть открыты для расширения и закрыты 

для изменения.

Иными словами, должна иметься возможность расширять поведение про-

граммных сущностей без их изменения .

Это одна из основных причин, почему мы изучаем архитектуру программ-

ного обеспечения . Очевидно, если простое расширение требований ведет 

к значительным изменениям в программном обеспечении, значит, архитек-

торы этой программной системы потерпели сокрушительное фиаско .

Большинство студентов, изучающих проектирование программного обе-

спечения, признают принцип OCP как руководство по проектированию 

классов и модулей . Но на уровне архитектурных компонентов этот принцип 

приобретает еще большую значимость .

Увидеть это поможет простой мысленный эксперимент .

Мысленный эксперимент

Представьте, что у нас есть финансовая сводка . Содержимое страницы про-

кручивается, и отрицательные значения выводятся красным цветом .

Теперь допустим, что заинтересованные лица попросили нас представить 

ту же информацию в виде отчета, распечатанного на черно-белом принтере . 

Отчет должен быть разбит на страницы, включать соответствующие верхний 

и нижний колонтитулы на каждой странице и колонку меток . Отрицатель-

ные значения должны заключаться в круглые скобки .

Очевидно, что для этого придется написать новый код . Но как много старого 

кода придется изменить?

В программном обеспечении с хорошо проработанной архитектурой таких 

изменений должно быть очень немного . В идеале их вообще не должно быть .

Как? Правильно разделяя сущности, которые изменяются по разным причи-

нам (принцип единственной ответственности), и затем правильно организуя 

зависимости между этими сущностями (принцип инверсии зависимостей) .

1 Bertrand Meyer . Object Oriented Software Construction, Prentice Hall, 1988, p . 23 (Бертран 

Мейер. Объектно-ориентированное конструирование программных систем . Русская 

редакция, 2005 . — Примеч. пер.) .

Мысленный эксперимент      87

Применяя принцип единственной ответственности, можно прийти к пото-

ку данных, изображенному на рис . 8 .1 . Некоторая процедура анализирует 

финансовые данные и производит данные для отчета, которые затем фор-

матируются двумя процедурами формирования отчетов .

Рис. 8.1. Результат применения принципа единственной ответственности

Самое важное, что нужно понять, — в данном примере в создание отчета 

вовлечены две отдельные ответственности: вычисление данных для отчета 

и представление этих данных в форме веб-отчета или распечатанного отчета .

Сделав такое разделение, мы должны организовать зависимости в исходном 

коде так, чтобы изменения в одной из ответственностей не вызывали не-

обходимости изменений в другой . Кроме того, новая организация должна 

гарантировать возможность расширения поведения без отмены изменений .

Этого можно добиться, выделив процессы в классы, а классы в компоненты, 

ограниченные двойными линиями на рис . 8 .2 . Компонент в левом верхнем 

углу на этом рисунке — контроллер . В правом верхнем углу — интерактор, 

или посредник . В правом нижнем углу — база данных . Наконец, в левом ниж-

нем углу изображены четыре компонента — презентаторы и представления .

Классы, отмеченные символами <I>, — это интерфейсы; отмеченные сим-

волами <DS> — это структуры данных (data structures) . Простые стрелки 

соответствуют отношениям использования . Стрелки с треугольным нако-

нечником соответствуют отношениям реализации или наследования .

Первое, на что следует обратить внимание, — все зависимости определены 

на уровне исходного кода . Стрелка, направленная от класса A к классу B, 

означает, что в исходном коде класса A упоминается имя класса B, но в коде 

класса B не упоминается имя класса A . Так, на рис . 8 .2 диспетчер финан-

совых данных знает о существовании шлюза через отношение реализации, 

а шлюз финансовых данных ничего не знает о диспетчере .

88   Глава 8. Принцип открытости/закрытости

Контроллер

финансового

отчета

Контроллер

Презентатор

финансового

отчета

Интерактор

Запрос

финансового

отчета

Заказчик

финансового

отчета

Возвращаемый

финансовый

отчет

Генератор

финансового

отчета

Шлюз

финансовых

данных

Финансовые

сущности

Диспетчер

финансовых

данных

Финансовая

база данных

База

данных

Экранный

презентатор

Экранный

</p>
   </article>
</body>
</html>
