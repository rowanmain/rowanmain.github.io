<!DOCTYPE html>
<html>
<head>
   <title>Моя статья</title>
   <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<style>
body {
   background-color: #f0f0f0;
   font-family: Arial, sans-serif;
}

header {
   background-color: #333;
   color: white;
   padding: 10px;
   text-align: center;
}

h1 {
   margin: 0;
}

article {
   margin: 20px;
}

h2 {
   color: #333;
}

p {
   line-height: 1.6;
}
</style>
<body>
   <header>
       <h1>статья</h1>
   </header>
   <article>
       <p>
рушать правило зависимостей .

Например, многие фреймворки для работы с базами данных возвращают 

ответы на запросы в удобном формате . Их можно назвать «представлением 

записей» . Такие представления записей не должны передаваться через гра-

ницы внутрь . Это нарушает правило зависимостей, потому что заставляет 

внутренний круг знать что-то о внешнем круге .

Итак, при передаче через границу данные всегда должны принимать форму, 

наиболее удобную для внутреннего круга .

Типичный сценарий

Диаграмма на рис . 22 .2 показывает типичный сценарий работы веб-системы 

на Java, использующей базу данных . Веб-сервер принимает исходные дан-

ные от пользователя и передает их контроллеру Controller в левом верхнем 

Рис. 22.2. Типичный сценарий работы веб-системы на Java, использующей базу 

данных

Заключение      209

углу . Контроллер упаковывает данные в простой Java-объект InputData и пе-

редает его через интерфейс InputBoundary классу UseCaseInteractor . Класс 

UseCaseInteractor интерпретирует данные и использует их для управления 

действиями сущностей Entities . Он также переносит данные из базы данных 

Database в память сущностей Entities через интерфейс DataAccessInterface . 

По завершении UseCaseInteractor забирает данные из сущностей Entities 

и конструирует из них другой простой Java-объект OutputData . Затем объ-

ект OutputData передается через интерфейс OutputBoundary презентатору 

Presenter .

Презентатор Presenter переупаковывает данные из объекта OutputData в объ-

ект ViewModel, еще один простой Java-объект, содержащий в основном строки 

и флаги, используемые представлением View для отображения данных . Объ-

ект OutputData мог бы содержать объекты типа Date, но Presenter преобразует 

их в процессе формирования ViewModel в строковые значения, пригодные 

для отображения . То же произойдет с объектами типа Currency и любыми 

другими бизнес-данными . Имена кнопок Button и пунктов меню MenuItem по-

мещаются в ViewModel вместе с флагами, сообщающими представлению View, 

следует ли отобразить эти кнопки и пункты меню в неактивном состоянии .

В результате представлению View практически ничего не приходится делать, 

кроме как перенести данные из ViewModel в HTML-страницу .

Обратите внимание на направления зависимостей . Все они пересекают 

линии границ только в направлении внутрь, следуя правилу зависимостей .

Заключение

Следование этим простым правилам не требует больших усилий и поможет 

сохранить душевный покой в будущем . Разделив программное обеспечение 

на уровни и соблюдая правило зависимостей, вы создадите систему, которую 

легко протестировать — со всеми вытекающими из этого преимуществами . 

Когда какой-либо из внешних элементов системы, например база данных 

или веб-фреймворк, устареет, вы сможете без всякой суеты заменить его .

23

Презентаторы 

и скромные объекты

Презентаторы и представления      211

В главе 22 мы познакомились с понятием презентатора (presenter) . Пре-

зентаторы являются разновидностью шаблона проектирования «Скромный 

объект» (Humble Object), помогающего выявлять и защищать архитектур-

ные границы . Фактически чистая архитектура в предыдущей главе полна 

реализациями шаблона «Скромный объект» .

Шаблон «Скромный объект»

Шаблон проектирования «Скромный объект»1 первоначально предлагался 

для использования в модульном тестировании как способ отделения поведе-

ния, легко поддающегося тестированию, от поведения, с трудом поддающе-

гося тестированию . Идея очень проста: разделить поведение на два модуля 

или класса . Один из модулей, который называется «скромным», содержит 

все, что с трудом поддается тестированию, в виде, упрощенном до предела . 

Второй — все, что было выброшено из «скромного» модуля .

Например, графические пользовательские интерфейсы сложны для мо-

дульного тестирования, потому что трудно писать тесты, которые могут 

видеть изображение на экране и проверять присутствие соответствующих 

элементов . Однако в действительности большая часть поведения пользо-

вательского интерфейса легко тестируется . Используя шаблон «Скромный 

объект», можно разделить два вида поведения на два разных класса, которые 

называют Презентатором (Presenter) и Представлением (View) .

Презентаторы и представления

Представление (View) — это «скромный» объект, сложный для тестиро-

вания . Код в этом объекте упрощается до предела . Он просто переносит 

данные в графический интерфейс, никак не обрабатывая их .

Презентатор (Presenter) — это легко тестируемый объект . Его задача — полу-

чить данные от приложения и преобразовать их так, чтобы Представление 

(View) могло просто переместить их на экран . Например, если приложе-

нию потребуется отобразить дату в некотором поле, оно должно передать 

Презентатору объект Date . Презентатор затем должен преобразовать дату 

в строку и поместить ее в простую структуру данных, которую называют 

Моделью представления (View Model), где Представление сможет найти ее .

1 xUnit Patterns, Meszaros, Addison-Wesley, 2007, p . 695 . (Джерард Месарош. Шаблоны 

тестирования xUnit: рефакторинг кода тестов . М .: Вильямс, 2017 . — Примеч. пер.) .

212   Глава 23. Презентаторы и скромные объекты

Если приложению потребуется отобразить на экране денежную сумму, оно 

может передать Презентатору объект Currency . Презентатор должен преоб-

разовать этот объект в строковое представление десятичного числа с соот-

ветствующим количеством десятичных знаков и знаком валюты и поместить 

полученную строку в Модель представления . Если отрицательные суммы 

должны отображаться красным цветом, тогда в Модели представления дол-

жен устанавливаться соответствующий флаг .

Каждая кнопка на экране имеет имя . Это имя является строкой в Модели 

представления, помещаемой туда Презентатором . Если кнопка должна ото-

бражаться как неактивная, Презентатор установит соответствующий логиче-

ский флаг в Модели представления . Имя каждого пункта меню представлено 

строкой в Модели представления, помещаемой туда Презентатором . Имена 

всех радиокнопок, флажков и текстовых полей и соответствующих логи-

ческих флагов устанавливаются Презентатором в Модели представления . 

Таблицы чисел, которые должны отображаться на экране, преобразуются 

Презентатором в таблицы форматированных строк в Модели представления .

Все, что отображается на экране и чем так или иначе управляет приложение, 

представлено в Модели представления строкой, или логическим значением, 

</p>
   </article>
</body>
</html>
