<!DOCTYPE html>
<html>
<head>
   <title>Моя статья</title>
   <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<style>
body {
   background-color: #f0f0f0;
   font-family: Arial, sans-serif;
}

header {
   background-color: #333;
   color: white;
   padding: 10px;
   text-align: center;
}

h1 {
   margin: 0;
}

article {
   margin: 20px;
}

h2 {
   color: #333;
}

p {
   line-height: 1.6;
}
</style>
<body>
   <header>
       <h1>статья</h1>
   </header>
   <article>
       <p>
компиляции/компоновки оставался узким местом .

Мы на практике испытывали действие закона Мерфи о размере про-

граммы:

Любая программа растет, пока не заполнит все доступное время на компи-

ляцию и компоновку.

112   Глава 12. Компоненты

Но Мерфи не был единственным на этом ринге . Вскоре появился Мур1, 

и в конце 1980-х годов они схлестнулись . Мур вышел из этой схватки по-

бедителем . Диски начали уменьшаться в размерах и стали намного быстрее . 

Компьютерная память стала настолько дешевой, что большую часть данных 

на диске можно было уместить в кэше, в оперативной памяти . Тактовая 

частота процессоров выросла с 1 до 100 МГц .

К середине 1990-х годов время, необходимое на компоновку, сокращалось 

быстрее, чем росли наши программы . Во многих случаях время на компонов-

ку сократилось до нескольких секунд . Для маленьких заданий вновь обрела 

жизнеспособность идея связывающего загрузчика .

Это была эпоха Active-X, динамических библиотек и первых файлов .jar . 

Компьютеры и периферийные устройства стали настолько быстрыми, что 

мы снова получили возможность выполнять компоновку (связывание) во 

время загрузки . Мы можем связать несколько файлов .jar или несколько 

динамических библиотек за секунды и выполнить получившуюся програм-

му . Так родилась архитектура сменных компонентов (плагинов) .

Сегодня мы обычно поставляем файлы .jar или динамические библиотеки 

как плагины к существующим приложениям . Чтобы создать новую модель 

для Minecraft, достаточно просто включить свои файлы .jar в определенную 

папку . Чтобы подключить плагин Resharper к среде разработки Visual Studio, 

достаточно добавить соответствующие библиотеки DLL .

Заключение

Динамически связываемые файлы, которые можно подключать во время 

выполнения, являются программными компонентами в наших архитекту-

рах . Потребовалось 50 лет, но мы достигли такой степени развития, когда 

архитектура сменных плагинов стала применяться по умолчанию и без 

титанических усилий, как когда-то .

1 Закон Мура: быстродействие компьютеров, объем памяти и компактность удваиваются 

каждые 18 месяцев . Этот закон удерживался с 1950-х до 2000 годов, но затем утратил 

силу, по крайней мере в отношении роста тактовой частоты .

13

Связность 

компонентов

114   Глава 13. Связность компонентов

К какому компоненту отнести тот или иной класс? Это важное решение 

должно приниматься в соответствии с зарекомендовавшими себя прин-

ципами разработки программного обеспечения . К сожалению, подобные 

решения носят особый характер и принимаются почти исключительно ис-

ходя из контекста .

В этой главе мы обсудим три принципа, определяющих связность компо-

нентов:

 

� REP: Reuse/Release Equivalence Principle — принцип эквивалентности 

повторного использования и выпусков;

 

� CCP: Common Closure Principle — принцип согласованного изменения;

 

� CRP: Common Reuse Principle — принцип совместного повторного ис-

пользования .

Принцип эквивалентности повторного 

использования и выпусков

Единица повторного использования есть единица выпуска.

За последнее десятилетие появилось множество инструментов управления 

модулями, таких как Maven, Leiningen и RVM . Эти инструменты приобрели 

особую важность, потому что за это же время создано огромное количество 

многократно используемых компонентов и библиотек компонентов . Сейчас 

мы живем в эпоху программного обеспечения многократного использова-

ния, когда исполнилось одно из самых древних обещаний объектно-ориен-

тированной модели .

Принцип эквивалентности повторного использования и выпусков (Reuse/

Release Equivalence Principle; REP) выглядит очевидным, по крайней мере 

сейчас . Люди, нуждающиеся в программных компонентах многократного 

использования, не смогут и не будут пользоваться компонентами, не про-

шедшими процесс выпуска и не получившими номер версии .

И совсем не потому, что без номера версии невозможно гарантировать со-

вместимость всех повторно используемых компонентов . А потому, что раз-

работчики программного обеспечения желают знать, когда появится новая 

версия и какие изменения в этой версии произойдут .

Нередко разработчики, знающие о приближающемся выпуске новой версии, 

оценивают грядущие изменения и принимают решение о продолжении 

Принцип согласованного изменения      115

использования старой версии или переходе на новую . Поэтому в процессе 

выпуска создатели компонента должны рассылать соответствующие изве-

щения и описание новой версии, чтобы пользователи могли принимать обо-

снованные решения о том, когда и следует ли переходить на новую версию .

С точки зрения архитектуры и дизайна этот принцип означает, что классы 

и модули, составляющие компонент, должны принадлежать связной группе . 

Компонент не может просто включать случайную смесь классов и модулей; 

должна быть какая-то тема или цель, общая для всех модулей .

Все это, безусловно, очевидно . Однако есть еще один аспект, возможно, не 

такой очевидный . Классы и модули, объединяемые в компонент, должны 

выпускаться вместе . Объединение их в один выпуск и включение в общую 

документацию с описанием этой версии должны иметь смысл для автора 

и пользователей .

Впрочем, говорить, что что-то должно «иметь смысл» — это все равно, что 

размахивать руками и пытаться выглядеть авторитетно . Это не самый луч-

ший совет, потому что сложно точно описать, что объединяет классы и моду-

ли в единый компонент . Однако слабость совета не умаляет важности самого 

принципа, потому что его нарушение легко определяется по «отсутствию 

смысла» . Если вы нарушите принцип REP, ваши пользователи узнают об 

этом и усомнятся в вашей компетентности как архитектора .

Слабость этого принципа с лихвой компенсируется силой двух следующих 

принципов . В действительности принципы CCP CRP строго определяют 

этот принцип, хотя и в негативном ключе .

</p>
   </article>
</body>
</html>
