<!DOCTYPE html>
<html>
<head>
   <title>Моя статья</title>
   <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<style>
body {
   background-color: #f0f0f0;
   font-family: Arial, sans-serif;
}

header {
   background-color: #333;
   color: white;
   padding: 10px;
   text-align: center;
}

h1 {
   margin: 0;
}

article {
   margin: 20px;
}

h2 {
   color: #333;
}

p {
   line-height: 1.6;
}
</style>
<body>
   <header>
       <h1>статья</h1>
   </header>
   <article>
       <p>
При такой организации, изображенной 

на рис . 34 .2, имеются те же интерфей-

сы и классы, но они помещаются в еди-

ный Java-пакет . Ее легко получить про-

стым рефакторингом из «упаковки по 

уровням», но теперь верхнеуровневая 

структура кричит о предметной области . 

Теперь видно, что кодовая база имеет 

какое-то отношение к заказам, а не к Веб, 

не к службам и не к хранилищам . Другим 

преимуществом является относитель-

ная простота поиска кода для изменения, 

например, когда потребуется изменить 

вариант использования «просмотр зака-

зов» . Весь код сосредоточен вместе, а не 

разбросан по разным Java-пакетам1 .

Мне часто встречаются команды раз-

работчиков, испытывающие трудности 

с разделением на горизонтальные уров-

ни («упаковка по уровням») и переклю-

чающиеся на разделение по вертикали 

(«упаковка по особенностям») . По моему 

мнению, оба подхода не оптимальны . До-

читав книгу до этого места, многие из 

вас подумают, что можно сделать лучше, 

и они будут правы .

Порты и адаптеры

Как говорил «дядюшка Боб», подходы, 

такие как «порты и адаптеры», «гексаго-

нальная архитектура», «граница, управление, сущность» и др ., придуманы 

с целью создания архитектур, в которых прикладной/предметный код неза-

1 Ценность этого преимущества нивелируется навигационными возможностями совре-

менных IDE, но, похоже, в последнее время наблюдается возрождение популярности 

легковесных текстовых редакторов, причины которого я, в силу возраста, не могу понять .

<<использует>>

<<использует>>

<<интерфейс>>

<<интерфейс>>

Рис. 34.2. Упаковка  

по особенностям

292   Глава 34. Недостающая глава

висим и отделен от технических деталей реализации, таких как фреймворки 

и базы данных . Такие базы кода часто состоят из двух областей: «внутрен-

няя» (предметная) и «внешняя» (инфраструктура), как показано на рис . 

34 .3 .

Инфраструктура

Предметная область

Рис. 34.3. Кодовая база с внутренней и внешней областями

«Внутренняя» область включает все предметные понятия, а «внешняя» 

отвечает за взаимодействия с внешним миром (то есть содержит пользова-

тельские интерфейсы, базы данных, механизмы интеграции со сторонними 

продуктами) . Главное правило при такой организации: «внешняя» область 

зависит от «внутренней», но никогда наоборот . На рис . 34 .4 изображена 

версия реализации случая использования «просмотр заказов» .

Пакет com.mycompany.myapp.domain в этой версии — «внутренний», а другие 

пакеты — «внешние» . Обратите внимание, что зависимости указывают 

в сторону «внутренней» области . Внимательный читатель наверняка за-

метит, что класс OrdersRepository переименован в Orders . Это объясняется 

влиянием правил предметно-ориентированного проектирования, которые 

требуют всему, что находится «внутри», давать простые имена из словаря 

«универсального предметного языка» . Так, в предметных дискуссиях мы 

говорим «заказы», а не «хранилище заказов» .

Также стоит отметить, что это существенно упрощенная версия UML-диа-

граммы классов, потому что в ней отсутствуют такие элементы, как интерак-

торы и объекты для передачи данных через границы зависимостей .

Упаковка по компонентам      293

Упаковка по 

компонентам

В целом я согласен с рассуждениями 

о принципах SOLID, эквивалентности 

повторного использования (REP), согла-

сованного изменения (CCP) и совмест-

ного повторного использования (CRP) 

и большинством советов в этой книге, но 

я пришел к немного другим выводам, ка-

сающимся организации кода . Поэтому 

я представлю еще один вариант, который 

я называю «упаковка по компонентам» . 

Прежде всего, в своей карьере я много 

лет посвятил созданию корпоративного 

программного обеспечения, в основном 

на Java, во многих прикладных областях . 

Эти программные системы сильно от-

личались . Подавляющее их число были 

основаны на Веб, но имелись также кли-

ент-серверные1, распределенные, основан-

ные на обмене сообщениями и некоторые 

другие системы . Хотя технологии отлича-

лись, всех их объединяла традиционная 

многоуровневая архитектура .

Я уже упоминал пару причин, почему 

многоуровневую архитектуру следует 

считать неудовлетворительной, но это 

еще не все . Цель многоуровневой архи-

тектуры — отделить код, выполняющий 

схожие функции . Веб-интерфейс отде-

ляется от бизнес-логики, которая, в свою 

очередь, отделяется от механизмов 

1 На первой работе, после окончания университета в 1996 году, я занимался создани-

ем клиент-серверных приложений для настольных компьютеров с использованием 

технологии PowerBuilder и суперпродуктивного языка 4GL, прекрасно подходящего 

для создания приложений баз данных . Спустя пару лет я создавал клиент-серверные 

приложения на Java, в которых мне приходилось создавать собственные подключения 

к базе данных (это было еще до появления JDBC) и наши собственные инструменты 

с графическим интерфейсом поверх AWT . Для вас это «прогресс»!

<<использует>>

<<интерфейс>>

<<интерфейс>>

<<использует>>

Рис. 34.4. Случай использования  

«просмотр заказов»

294   Глава 34. Недостающая глава

 доступа к данным . Как было показано на UML-диаграмме классов, с точки 

зрения реализации уровень примерно соответствует пакету . С точки зре-

ния доступности кода, чтобы OrdersController мог зависеть от интерфейса 

OrdersService, последний должен быть объявлен общедоступным, потому 

что класс и интерфейс находятся в разных пакетах . Аналогично общедо-

ступным должен быть объявлен интерфейс OrdersRepository, так как он 

используется классом OrdersServiceImpl, находящимся за пределами пакета, 

определяющего функции доступа к хранилищу .

В настоящей многоуровневой архитектуре стрелки зависимостей всегда 

должны быть направлены вниз . Уровни должны зависеть только от соседне-

го, нижележащего уровня . В результате введения некоторых правил, опреде-

ляющих, как должны зависеть элементы в базе кода, получается красивый, 

чистый, ациклический граф зависимостей . Большая проблема в том, что мы 

можем хитрить, вводя некоторые нежелательные зависимости, и при этом 

получать замечательный ациклический граф зависимостей .

Предположим, что на работу был нанят новый специалист, он присоеди-

нился к вашей команде и вы поручаете ему реализовать другой вариант 

использования, связанный с заказами . Как всякий новичок, этот человек 

хочет произвести впечатление и реализовать порученное ему задание макси-

мально быстро . Посидев несколько минут с чашкой кофе, новичок замечает 

существующий класс OrdersController и решает, что это именно тот код, 

который должен использоваться новой веб-страницей, порученной ему . Но 

ему нужны некоторые данные о заказах из базы данных . Новичка озаряет: 

«О, здесь уже есть интерфейс OrdersRepository . Я могу просто внедрить ре-

ализацию в мой контроллер . Отлично!» Спустя несколько минут он создает 

действующую веб-страницу . Но получившаяся UML-диаграмма выглядит, 

как показано на рис . 34 .5 .

Стрелки зависимостей все еще направлены вниз, но теперь для некоторых 

вариантов использования OrdersController минует OrdersService . Такую ор-

ганизацию часто называют нестрогой многоуровневой архитектурой, так как 

уровням позволено перепрыгивать через смежные, соседние уровни . В не-

которых ситуациях это делается намеренно, например, если вы пытаетесь 

следовать шаблону CQRS1 . Во многих других случаях нежелательно пере-

прыгивать через уровень бизнес-логики, особенно если эта бизнес-логика 

отвечает за авторизацию доступа к отдельным записям, например .

1 В шаблоне CQRS (Command Query Responsibility Segregation — разделение ответ-

ственности команд и запросов) для чтения и изменения данных используются разные 

шаблоны .

Упаковка по компонентам      295

<<использует>>

<<интерфейс>>

<<интерфейс>>

<<использует>>

<<использует>>

Рис. 34.5. Нестрогая многоуровневая архитектура

Новый вариант использования работает, но наверняка реализован не так, 

как вам хотелось бы . Нечто подобное я видел во многих командах, которые 

посещал как консультант, и обычно это проявляется, когда команды начи-

нают выяснять, как выглядит база кода, часто в первый раз .

В такой ситуации необходимо установить правило — архитектурный прин-

цип, — которое гласит, например: «Веб-контроллеры никогда не должны об-

296   Глава 34. Недостающая глава

ращаться к хранилищу непосредственно» . Проблема, конечно, заключается 

в исполнении правила . Многие команды, с которыми я встречался, заявля-

ли: «Мы обеспечиваем соблюдение этого принципа строгой дисциплиной 

и обзорами кода, потому что доверяем нашим разработчикам» . Это хорошо, 

что есть такая уверенность, но все мы знаем, что происходит, когда бюджет 

и сроки начинают приближаться к концу .

Намного меньше команд сообщали мне, что они используют инструменты 

статического анализа (например, NDepend, Structure101, Checkstyle) для 

автоматической проверки и выявления архитектурных нарушений во время 

сборки . Возможно, вы уже видели такие правила; обычно они имеют форму 

регулярных выражений или строк с шаблонными символами, которые ука-

зывают: «типы в пакете **/web не должны использоваться типами в **/data» 

и проверяются после этапа компиляции .

Это немного грубоватый подход, но он может помочь, сообщая о наруше-

ниях архитектурных принципов, которые (по вашему мнению) должны по-

мешать вашей команде разработчиков выполнить сборку . Проблема обоих 

подходов в том, что они чреваты ошибками и цикл обратной связи дольше, 

чем хотелось бы . Если отключить проверку, в результате код может превра-

титься в «большой ком грязи»1 . Лично я хотел бы, чтобы за соблюдением 

архитектурных принципов следил компилятор .

Это ведет нас к варианту «упаковка по компонентам» . Цель этого гибрид-

ного подхода, обсуждавшегося до сих пор, — упаковать все обязанности, 

связанные с одним крупным компонентом, в единый Java-пакет . Речь идет 

о сервис-ориентированном представлении программной системы, что, 

собственно, мы наблюдаем в архитектурах микрослужб . Подобно портам 

и адаптерам, интерпретирующим Веб как всего лишь еще один механизм 

доставки, методика «упаковка по компонентам» помогает отделить пользо-

вательский интерфейс от этих крупных компонентов . На рис . 34 .6 показано, 

как мог бы выглядеть вариант «просмотр заказов» .

По сути, этот подход связывает «бизнес-логику» и код для работы с хра-

нилищем в единое нечто, что мы называем «компонентом» . Выше в книге 

дядюшка Боб дал такое определение компонента:

Компоненты — это единицы развертывания. Они представляют наименьшие 

сущности, которые можно развертывать в составе системы. В Java — это 

jar-файлы. 

1 http://www.laputan.org/mud/ .

Упаковка по компонентам      297

<<использует>>

<<использует>>

<<интерфейс>>

<<интерфейс>>

Рис. 34.6. Вариант использования «просмотр заказов»

Мое определение компонента немного отличается: «Группа функциональ-

ных возможностей, находящихся за общим чистым интерфейсом, которые 

постоянно находятся внутри среды выполнения, такой как приложение» . 

Это определение взято из описания модели C4 программной архитектуры 

298   Глава 34. Недостающая глава

(«C4 software architecture model»)1, которая определяет простую иерархиче-

скую организацию статических структур программной системы в терминах 

контейнеров, компонентов и классов (или кода) . В этом описании говорится, 

что программная система состоит из одного или нескольких контейнеров 

(например, веб-приложений, мобильных приложений, обычных прило-

жений, баз данных, файловых систем), каждый из которых содержит один 

или несколько компонентов, которые, в свою очередь, реализуются одним 

или несколькими классами (или кодом) . Находится ли каждый компонент 

в отдельном jar-файле — это уже второстепенный вопрос .

Ключевое преимущество подхода «упаковки по компонентам» заключает-

ся в размещении всего кода, например, имеющего отношение к обработке 

заказов, в одном месте — в компоненте OrdersComponent . Задачи внутри 

компонента все еще разделены, то есть бизнес-логика отделена от функций 

доступа к хранилищу, но это разделение является уже деталью реализации 

компонентов, о которой потребителям знать не обязательно . Это напоми-

нает организацию микрослужб или сервис-ориентированную архитектуру, 

когда имеется отдельная служба OrdersService, инкапсулирующая все, что 

связано с обработкой заказов, отличаясь лишь режимом разделения . 

Организацию монолитного приложения в виде набора тщательно про-

работанных компонентов можно рассматривать как шаг в направлении 

архитектуры микрослужб .

Дьявол в деталях реализации

На первый взгляд кажется, что все четыре подхода представляют собой 

разные способы организации кода и поэтому могут считаться разными ар-

хитектурными стилями . Это ощущение начинает быстро укрепляться, если 

нет понимания деталей реализации .

Я постоянно наблюдаю чересчур свободное использование модификатора 

доступа public в таких языках, как Java . Похоже, что разработчики использу-

ют ключевое слово public инстинктивно, не думая . Этот инстинкт хранится 

в нашей мышечной памяти . Если не верите, взгляните на примеры кода 

в книгах, руководствах и открытых фреймворках на сайте GitHub . Эта тен-

денция, похоже, никак не связана с архитектурным стилем, используемым 

для организации кода, будь то горизонтальные уровни, порты и адаптеры 

или что-то еще .

1 Дополнительные сведения можно найти по адресу https://www.structurizr.com/help/c4 .

Организация и инкапсуляция      299

Объявление всех типов общедоступными означает отказ от возможностей 

инкапсуляции, предлагаемых языком программирования . Как результат, это 

открывает возможность любому написать код с реализацией конкретного 

класса, нарушающий используемый архитектурный стиль .

Организация и инкапсуляция

Взглянем на эту проблему с другой стороны . Если все типы в Java-прило-

жении объявить общедоступными, пакеты превратятся в простой механизм 

организации (в группировки, как папки), утратив свойства инкапсуляции . 

Так как общедоступные типы могут беспрепятственно использоваться в лю-

бой точке приложения, вы фактически можете игнорировать пакеты, потому 

что они практически не несут никакой ценности . В результате, если вы иг-

норируете пакеты (потому что они не имеют никаких средств инкапсуляции 

и сокрытия), становится совершенно неважно, какой архитектурный стиль 

вы пытаетесь воплотить . Если все типы объявить общедоступными, пакеты 

Java на UML-диаграммах, представленных выше, превращаются в ненужную 

деталь . По сути, при злоупотреблении подобными объявлениями все четы-

ре архитектурных подхода, представленные выше в этой главе, становятся 

практически неотличимыми друг от друга (рис . 34 .7) .

<<использует>>

<<использует>>

<<использует>>

<<использует>>

<<использует>>

<<использует>>

<<использует>>

<<использует>>

<<интерфейс>>

<<интерфейс>>

<<интерфейс>>

<<интерфейс>>

<<интерфейс>>

<<интерфейс>>

<<интерфейс>>

<<интерфейс>>

Рис. 34.7. Все четыре архитектурных стиля идентичны

300   Глава 34. Недостающая глава

Обратите внимание на стрелки между типами на рис . 34 .7: они не зависят 

от архитектурного стиля, который вы пытаетесь воплотить . Концепту-

ально стили очень разные, но синтаксически они идентичны . Кроме того, 

можно даже утверждать, что после объявления всех типов общедоступ-

ными эти четыре стиля превращаются лишь в четыре способа описания 

традиционной архитектуры с горизонтальными уровнями . Это ловкий 

фокус, и, конечно же, никто не будет объявлять все свои Java-типы обще-

доступными . За исключением случаев, когда это действительно делается . 

И я видел их .

Модификаторы доступа в Java не идеальны1, но их игнорирование может 

вызывать проблемы . Порядок распределения типов Java по пакетам факти-

чески может иметь большое значение для доступности (или недоступности) 

этих типов, когда модификаторы доступа применяются соответственно . 

Если вернуть пакеты и отметить те типы (сделав их бледнее на диаграмме), 

которым можно дать более ограничивающий модификатор, картина станет 

интереснее (рис . 34 .8) .

Двигаясь слева направо в подходе «упаковка по уровням», интерфейсы 

OrdersService и OrdersRepository должны быть объявлены общедоступными, 

потому что имеют входящие зависимости от классов, находящихся за преде-

лами пакета, в котором объявлены эти интерфейсы . Классам с реализациями 

(OrdersServiceImpl и JdbcOrdersRepository), напротив, можно придать более 

ограниченную видимость (на уровне пакета) . Никто не должен знать об их 

существовании; они являются деталями реализации .

В подходе «упаковка по особенностям» единственной точкой входа в пакет 

является OrdersController, поэтому доступ ко всему остальному можно 

ограничить рамками пакета . Важно отметить, что в такой ситуации никакой 

другой код, находящийся за пределами этого пакета, не сможет получить 

никакой информации о заказах в обход контроллера . Иногда это может 

быть нежелательно .

В подходе с портами и адаптерами интерфейсы OrdersService и Orders име-

ют входящие зависимости из других пакетов, поэтому они должны быть 

объявлены общедоступными . И снова, доступность классов реализации 

1 Например, в Java невозможно ограничить доступ на основе отношений пакетов и под-

пакетов, хотя все мы привыкли считать пакеты иерархическими структурами . Любые 

создаваемые иерархии отражаются только на именах пакетов и структуре каталогов 

на диске .

Организация и инкапсуляция      301

<<использует>>

<<использует>>

<<использует>>

<<использует>>

<<использует>>

<<использует>>

<<использует>>

<<использует>>

<<интерфейс>>

<<интерфейс>>

<<интерфейс>>

<<интерфейс>>

<<интерфейс>>

Рис. 34.8. Бледно-серым цветом выделены типы с более ограничивающим 

модификатором доступа

можно ограничить рамками пакета и внедрять зависимости во время вы-

полнения .

Наконец, в подходе «упаковка по компонентам» интерфейс OrdersCompo-

nent имеет входящую зависимость от контроллера, но доступ ко всему 

остальному можно ограничить рамками пакета . Чем меньше общедоступ-

ных типов, тем меньше число потенциальных зависимостей . В данном 

случае код за пределами этого пакета не имеет возможности1 напрямую 

использовать интерфейс OrdersRepository или его реализацию, поэтому 

соблюдение архитектурного принципа можно переложить на компиля-

тор . То же самое можно проделать в  .NET с помощью ключевого слова 

internal, но при этом придется создать отдельные сборки для всех ком-

понентов .

1 Можно, конечно, схитрить и воспользоваться механизмом рефлексии в Java, но не 

делайте так, пожалуйста!

302   Глава 34. Недостающая глава

Для большей ясности отмечу, что все, о чем рассказывалось здесь, относит-

ся к монолитному приложению, когда весь код находится в едином дереве 

исходных текстов . Если вы создаете такое приложение, я рекомендовал бы 

проводить в жизнь архитектурные принципы, опираясь на компилятор, 

а не полагаться на самодисциплину и инструменты, выполняющиеся после 

компиляции .

Другие режимы разделения

Кроме средств, поддерживаемых языком программирования, часто су-

ществуют другие способы разделения зависимостей в исходном коде . 

Для Java имеются свои инфраструктуры, такие как OSGi, и новейшая 

система модулей в Java 9 . При правильном использовании системы мо-

дулей позволяют разделить типы, объявленные как public, и публикуемые 

(published) типы . Например, можно создать модуль Orders, в котором все 

типы объявлены как public, но опубликовать только ограниченное число 

этих типов для внешних потребителей . Это долгожданное нововведение, 

и я с энтузиазмом воспринимаю появление новой системы модулей Java 9, 

которая даст нам еще один инструмент для создания хорошего программ-

ного обеспечения и вновь разбудит в людях интерес к дизайнерскому 

мышлению .

Другая возможность разделить зависимости на уровне исходного кода — 

создать несколько разных деревьев с исходным кодом . Для портов и адаптеров, 

например, можно было бы создать три таких дерева:

 

� Исходный код с предметной и бизнес-логикой (то есть все, что не зависит 

от выбора технологии и фреймворков): OrdersService, OrdersServiceImpl 

и Orders .

 

� Исходный код веб-интерфейса: OrdersController .

 

� Исходный код, реализующий хранение данных: JdbcOrdersRepository .

Последние два дерева имеют зависимости времени компиляции от кода 

с предметной и бизнес-логикой, который сам по себе ничего не знает о веб-

интерфейсе и особенностях хранения данных . С точки зрения реализации 

это можно сделать, настроив отдельные модули или проекты в конфигура-

ции инструмента сборки (например, Maven, Gradle, MSBuild) . В идеале этот 

шаблон можно применить для отделения деревьев с исходным кодом всех 

компонентов приложения .

Другие режимы разделения      303

Однако это слишком идеалистическое решение, потому что такое разбиение 

исходного кода влечет за собой проблемы производительности, сложности 

и сопровождения .

Более простой подход, используемый теми, кто реализует архитектуру пор-

тов и адаптеров, заключается в создании двух деревьев с исходным кодом:

 

� Предметный код («внутренняя» область) .

 

� Инфраструктурный код («внешняя» область) .

Его хорошо иллюстрирует диаграмма (рис . 34 .9), которую многие исполь-

зуют для обобщения архитектуры портов и адаптеров с ее зависимостью 

времени компиляции инфраструктурного кода от предметного .

Инфраструктура

Предметная область

Рис. 34.9. Предметный и инфраструктурный код

Такой подход к организации исходного кода тоже дает положительные ре-

зультаты, но вы должны помнить о потенциальных компромиссах . Это то, 

что я называю «окружным антишаблоном портов и адаптеров» . В Париже 

(Франция) имеется окружная автодорога с названием Boulevard Périphérique 

(бульвар Периферик), позволяющая обогнуть Париж, не утруждая себя 

сложностями движения внутри города . Включение всего инфраструктурного 

кода в единое дерево подразумевает потенциальную возможность для кода из 

304   Глава 34. Недостающая глава

любой части приложения (например, веб-контроллера) напрямую вызывать 

код из другой части приложения (например, функции для работы с базой дан-

ных), без пересечения предметной области . Это особенно верно, если забыть 

применить в том коде соответствующие модификаторы доступа .

Заключение: недостающий совет

Основная цель этой главы — подчеркнуть, что любые, самые лучшие дизай-

нерские намерения можно уничтожить в мгновение ока, если не учитывать 

тонкости стратегии реализации . Подумайте, как ваш дизайн должен ото-

бражаться в структуру кода, как организовать этот код и какие режимы 

разделения применять во время выполнения и компиляции . Старайтесь 

оставлять открытыми любые возможности, но будьте прагматичными и учи-

тывайте численность вашей команды, навыки ее членов, сложность решения 

и ограничения по времени и бюджету . Также подумайте, как использовать 

компилятор для принудительного соблюдения выбранного архитектурного 

стиля, и следите за связями в других областях, таких как модели данных . 

Дьявол кроется в деталях реализации .

VII 

Приложение

Архитектурная археология

Профсоюзная система учета   307

Чтобы определить принципы хорошей архитектуры, совершим путешествие по 

последним 45 годам и познакомимся с некоторыми проектами, над которыми 

я работал начиная с 1970 года. Некоторые из этих проектов представляют 

определенный интерес с архитектурной точки зрения. Другие интересны из-

влеченными уроками, повлиявшими на последующие проекты.

Это приложение несколько автобиографично. Я старался придерживаться темы 

обсуждения архитектуры, но, как в любой автобиографической истории, иногда 

в нее вторгаются другие факторы. ;-)

Профсоюзная система учета

В конце 1960-х годов компания ASC Tabulating подписала контракт с местным 

профсоюзом водителей грузовиков на разработку системы учета. Компания 

ASC решила реализовать эту систему на машине GE Datanet 30, изображенной 

на рис. П.1.

Рис. П.1. GE Datanet 30 

(фотографию предоставил Эд Телен (Ed Thelen), ed-thelen.org)

308   Приложение. Архитектурная археология

Как можно видеть на фотографии, это была огромная1 машина. Она занимала 

целую комнату и требовала поддержания определенного микроклимата.

Эта ЭВМ была построена еще до появления интегральных микросхем. Она 

была собрана на дискретных транзисторах, и в ней имелось даже несколько 

радиоламп (хотя они использовались только в усилителях для управления 

ленточными накопителями).

По сегодняшним меркам машина была огромная, медлительная и примитивная. 

В ней имелось 16 К × 18 бит оперативной памяти с временем цикла порядка 

7 микросекунд2. Она занимала большую комнату с климатической установкой. 

Имела приводы для магнитной ленты с семью дорожками и жесткий диск ем-

костью около 20 Мбайт.

Этот диск был настоящим монстром. Вы можете увидеть его на рис. П.2, но эта 

фотография не позволяет оценить размеры чудовища. Он был выше моего роста. 

Пластины были 36 дюймов (примерно 91 сантиметр) в диаметре и 3/8 дюйма 

(9,5 миллиметра) в толщину. Одна из пластин изображена на рис. П.3.

Теперь подсчитайте пластины на первой фотографии. Их было более десятка. 

Для каждой имелась своя лапа с головкой, приводившаяся в движение пневма-

тическим приводом. В процессе работы можно было видеть, как головки пере-

мещаются поперек пластин. Время позиционирования головки колебалось от 

половины секунды до секунды.

Когда этот зверь включался, он рычал, как самолет. Пол ходил ходуном, пока 

тот набирал скорость3.

ЭВМ Datanet 30 была знаменита своей возможностью асинхронно управлять 

большим количеством терминалов с относительно высокой скоростью. Именно 

это требовалось компании ASC.

Компания ASC находилась в Лейк Блафф, штат Иллинойс, в 30 милях к северу 

от Чикаго. Офис профсоюза размещался в центре Чикаго. Проф союз нанял 

примерно десять человек для ввода данных в систему через терминалы CRT4 

(рис. П.4). Они также могли печатать отчеты на телетайпах ASR35 (рис. П.5).

1 В ASC нам рассказали историю, как транспортировалась эта ЭВМ. Ее везли на боль-

шом грузовике с полуприцепом вместе с мебелью. По пути грузовик, двигаясь на вы-

сокой скорости, зацепил крышей мост. ЭВМ не пострадала, но она сместилась вперед 

и вдребезги раздавила мебель.

2 Сегодня мы могли бы сказать, что она работала с тактовой частотой 142 КГц.

3 Представьте массу диска, какой кинетической энергией он обладал! Однажды мы заме-

тили металлическую стружку, вылетевшую из корпуса диска. Мы вызвали ремонтника, 

и он тут же попросил выключить диск. Закончив ремонт, он сказал, что износился один 

из подшипников. Затем он рассказал нам, как однажды вовремя не отремонтированный 

диск сорвался с креплений, пробил бетонную стену и застрял в автомобиле на стоянке 

рядом.

4 С электронно-лучевыми трубками зеленого свечения, способные отображать только 

символы ASCII.

Профсоюзная система учета   309

Рис. П.2. Жесткий диск с пластинами 

(фотографию предоставил Эд Телен (Ed Thelen), ed-thelen.org)

Рис. П.3. Одна из пластин диска: 3/8 дюйма толщиной, 36 дюймов в диаметре 

(фотографию предоставил Эд Телен (Ed Thelen), ed-thelen.org)

310   Приложение. Архитектурная археология

Рис. П.4. Терминал CRT

(фотографию предоставил Эд Телен (Ed Thelen), ed-thelen.org)

Терминалы CRT поддерживали скорость обмена 30 символов в секунду. Это 

была хорошая скорость для конца 1960-х, потому что модемы в те дни были 

очень простенькими.

ASC арендовала у телефонной компании с десяток выделенных телефонных 

линий и вдвое больше 300-бодовых модемов для соединения Datanet 30 с этими 

терминалами.

В те времена компьютеры поставлялись без операционной системы. Они не 

имели даже файловых систем. У вас имелся только ассемблер.

Если вам нужно было сохранить данные на диске, вы записывали их на диск. Не 

в файл. Не в каталог. Вы должны были определить дорожку, пластину и сектор 

для сохраняемых данных и затем управлять диском, чтобы записать туда дан-

ные. Да, это означало необходимость писать свой драйвер диска.

В системе учета имелось три вида записей с информацией об агентах, работо-

дателях и членах профсоюза. Для этих записей поддерживались все четыре 

CRUD-операции1, но кроме этого система включала операции для рассылки 

квитанций на уплату взносов, определения изменений в общем реестре и другие.

1 CRUD — аббревиатура, обозначающая набор основных операций с данными: Create 

(создание), Read (чтение), Update (изменение) и Delete (удаление). — Примеч. пер.

Профсоюзная система учета   311

Первоначальная версия системы была написана на ассемблере консультантом, 

которому чудом удалось впихнуть ее в 16 К.

Как нетрудно догадаться, такая большая ЭВМ, как Datanet 30, была очень до-

рогой в обслуживании и эксплуатации. Услуги консультанта, поддерживавшего 

программное обеспечение, тоже обходились очень дорого. Более того, на рынке 

уже появились и стали набирать популярность более дешевые мини-компьютеры.

Рис. П.5. Телетайп ASR35 (с разрешения Джо Мейбла (Joe Mabel))

В 1971 году, когда мне было 18, компания ASC наняла меня и двух моих дру-

зей-гиков, чтобы переписать систему учета для мини-компьютера Varian 620/f 

(рис. П.6). Компьютер стоил недорого. Наши услуги стоили недорого. Для ASC 

это было отличной сделкой.

Машина Varian имела 16-битную шину и 32 К × 16 оперативной памяти. Дли-

тельность цикла составляла примерно 1 микросекунду. Эта машина была на-

много мощнее, чем Datanet 30. В ней использовалась дико успешная дисковая 

технология 2314, разработанная в IBM, позволявшая хранить 30 мегабайт на 

пластинах, имевших всего 14 дюймов в диаметре, которые уже не могли про-

бивать бетонные стены!

Конечно, у нас все еще не было операционной системы. Не было файловой си-

стемы. Не было и высокоуровневого языка программирования. У нас имелся 

только ассемблер. Но мы справились с заданием.

Вместо попытки втиснуть всю систему в 32 К, мы создали систему оверлеев. 

Приложения могли загружаться с диска в блок памяти, выделенной для овер-

леев. Они могли выполняться в этой памяти и вытесняться со своими данными 

в памяти обратно на диск, чтобы дать возможность поработать другим про-

граммам.

312   Приложение. Архитектурная археология

Рис. П.6. Мини-компьютер Varian 620/f 

(взято с сайта The Minicomputer Orphanage)

Программы могли загружаться в область оверлеев, выполняться ровно столь-

ко, сколько необходимо для заполнения выходных буферов, и затем выгру-

жаться на диск, чтобы освободить память для следующей программы.

Конечно, когда пользовательский интерфейс работает со скоростью 30 симво-

лов в секунду, программы тратят массу времени на ожидание. У нас в запасе 

оставалось достаточно времени, чтобы программы могли загружаться и запи-

сываться на диск, обеспечивая максимальную скорость обмена с терминалами. 

Никто и никогда не жаловался на проблемы с  временем отклика.

Мы написали вытесняющего диспетчера задач, управляющего прерываниями 

и вводом/выводом. Мы написали приложения; мы написали драйверы дис-

ка и драйверы терминалов, драйверы накопителей на магнитной ленте и все 

остальное в этой системе. В этой системе не было ни одного бита, написанного 

не нами. Это был тяжелый труд в течение множества 80-часовых недель, но мы 

запустили этого зверя за 8 или 9 месяцев.

Система имела простую архитектуру (рис. П.7). Когда приложение запускалось, 

оно генерировало данные до заполнения выходного буфера заданного терми-

нала. Затем диспетчер задач выгружал это приложение и загружал новое. При 

этом диспетчер продолжал выводить информацию со скоростью 30 символов 

в секунду почти до его опустошения. Затем он вновь загружал приложение, 

чтобы снова заполнить буфер.

Профсоюзная система учета   313

В этой системе есть две границы. Первая — вывод символов. Приложения не 

знали, что их вывод посылается терминалам со скоростью 30 символов в се-

кунду. В действительности для приложений вывод символов был полностью 

абстрагирован. Приложения просто передавали строки диспетчеру задач, а тот 

заботился о загрузке их в буферы, отправке символов терминалам и загрузке 

приложений в память и выгрузке их из памяти.

Память системы

Буферы терминалов

Оверлей

Терминалы

Диск

Выгрузка/загрузка

Диспетчер задач

Рис. П.7. Архитектура системы

Зависимости пересекали эту границу в прямом направлении, то есть их направлен-

ность совпадала с направленностью потока управления. Приложения имели зави-

симости времени компиляции от диспетчера задач, и поток управления следовал от 

приложений в сторону диспетчера. Граница оберегает приложения от просачивания 

в них информации о типе устройства, в который производится вывод.

Вторая граница пересекалась зависимостями в обратном направлении. Дис-

петчер задач мог запускать приложения, но не имел зависимости времени 

компиляции от них. Поток управления следовал от диспетчера к приложениям. 

Полиморфный интерфейс, инвертирующий зависимость, был прост: каждое 

приложение запускалось переходом по одному и тому же адресу в области 

оверлея. Граница оберегает диспетчера от просачивания в него информации об 

устройстве приложений, кроме адреса точки запуска.

314   Приложение. Архитектурная археология

Laser Trim

В 1973 году я поступил на работу в компанию Teradyne Applied Systems (TAS) 

в Чикаго. Это было подразделение корпорации Teradyne Inc. со штаб-квартирой 

в Бостоне. Мы занимались системой, управлявшей довольно мощными лазера-

ми для обработки электронных компонентов с высокой точностью.

В ту пору производители электронных компонентов использовали метод шел-

котрафаретной печати на керамической подложке. Подложки имели размер 

примерно 1 квадратный дюйм. Компонентами были обычные резисторы — 

устройства, создающие сопротивление электрическому току.

Величина сопротивления резистора зависела от множества факторов, включая 

состав и геометрию. Чем шире был резистор, тем меньшее сопротивление он 

оказывал.

Наша система позиционировала керамическую подложку в жгуте проводов, 

соединяющих датчики с резисторами. Система должна была измерять сопро-

тивление и затем с помощью лазера отсекать части резистора, делая его тоньше 

и тоньше, пока не будет достигнута желаемая величина сопротивления с точ-

ностью до десяти процентов.

Мы продавали эти системы производителям, а также использовали некоторые 

свои системы для производства небольших партий по заказам менее крупных 

производителей.

Система работала на компьютере M365. Это было время, когда многие компании 

строили свои компьютеры: корпорация Teradyne строила M365 и передавала 

их своим подразделениям. M365 был усовершенствованной версией PDP-8 — 

популяр ного в те дни мини-компьютера.

M365 управлял координатным столом, который перемещал керамические под-

ложки между датчиками. Также он управлял системой измерения и лазером. 

Позиционирование лазера осуществлялось посредством вращающихся X-Y 

зеркал. Компьютер также управлял мощностью лазера.

Среда разработки для M365 была довольно примитивной. Этот компьютер не 

имел диска. Данные сохранялись на картриджах с магнитной лентой, которые 

выглядели как старые 8-дорожечные аудиокассеты. Лента и приводы произво-

дились компанией Tri-Data.

Так же как 8-дорожечные аудиокассеты того времени, лента была склеена в петлю. 

Привод мог прокручивать ее только в одном направлении — в них не было функ-

ции перемотки! Если требовалось установить ленту в начальную позицию, нужно 

было прокручивать ее вперед до достижения «точки загрузки».

Лента прокручивалась со скоростью примерно 1 фут в секунду (примерно 

30 сантиметров в секунду). То есть петля из ленты длиной 25 футов (чуть боль-

Laser Trim   315

ше 7,5 мет ра) перематывалась до точки загрузки самое большее за 25 секунд. По 

этой причине Tri-Data выпускала картриджи с лентой разной длины, от 10 до 

100 футов (примерно от 3 до 30 метров).

На передней панели M365 имелась кнопка, по нажатии которой производилась 

загрузка начальной программы в память и ее запуск. Эта программа могла про-

читать первый блок с ленты и запустить его. Обычно в этом блоке хранился 

загрузчик, загружавший операционную систему, хранящуюся в остальных 

блоках на ленте.

Операционная система запрашивала у пользователя имя программы для запу-

ска. Эти программы хранились на ленте, сразу вслед за операционной системой. 

Пользователь мог ввести имя программы — например, ED-402 Editor, — а опе-

рационная система отыскивала ее на ленте, загружала и запускала.

Консолью служил ASCII CRT терминал с зеленым свечением, шириной 72 сим-

вола1 и высотой 24 строки. Он мог отображать только символы верхнего регистра.

Чтобы отредактировать программу, нужно было загрузить редактор ED-402 

Editor и затем вставить ленту с исходным кодом. Редактор позволял прочитать 

с ленты в память один блок с исходным кодом и вывести его на экран. В одном 

блоке можно было сохранить до 50 строк кода. Для внесения изменений нужно 

было переместить курсор в требуемую строку и ввести текст, примерно так, 

как это делается в редакторе vi. По завершении требовалось записать блок на 

другую ленту и прочитать следующий блок с исходной ленты. Вы должны были 

продолжать эти манипуляции, пока не закончите.

Не было никакой возможности прокрутить блоки в обратном направлении. 

Правка программы производилась линейно, от начала до конца. Чтобы вернуть-

ся в начало, нужно было закончить копирование исходного кода на выходную 

ленту и затем начать новый сеанс редактирования уже с этой лентой в качестве 

исходной. Неудивительно, что при таких ограничениях мы сначала писали 

свои программы на бумаге, вносили все правки вручную красным карандашом 

и только потом правили программу блок за блоком, сверяясь с пометками в ли-

стинге на бумаге.

Закончив правку программы, мы возвращались в операционную систему и вы-

зывали ассемблер. Ассемблер читал код с исходной ленты и записывал двоич-

ный код на другую ленту, при этом выводил листинг на наш последовательный 

принтер.

Ленты не были на 100% надежными, поэтому мы выполняли запись сразу на 

две ленты. Это увеличивало вероятность, что хотя бы одна из них не будет со-

держать ошибок.

1 Магическое число 72 пришло из эпохи перфокарт Hollerith, содержавших по 80 сим-

волов каждая. Последние 8 символов «резервировались» под порядковый номер на 

случай, если вы уроните и рассыплете колоду.

316   Приложение. Архитектурная археология

Наша программа состояла примерно из 20 000 строк кода, а ее компиляция зани-

мала примерно 30 минут. Шансы получить в это время ошибку чтения с ленты 

были 1 : 10. Если ассемблер сталкивался с такой ошибкой, он издавал сигнал 

на консоли и затем начинал выводить поток ошибок на принтер. Этот сигнал 

можно было услышать во всей лаборатории. Также можно было услышать 

проклятия несчастного программиста, только что узнавшего, что ему придется 

вновь запустить 30-минутный процесс компиляции.

Программа имела типичную для тех дней архитектуру. У нас имелась главная 

операционная программа (Master Operating Program), которую мы называли 

«the MOP». Она осуществляла управление базовыми функциями ввода/вы-

вода и предоставляла рудиментарную «командную оболочку» для консоли. 

Многие подразделения Teradyne использовали общий исходный код MOP, 

адаптируя его под собственные нужды. Как следствие, мы пересылали друг 

другу изменения в исходном коде в форме бумажных листингов с поправка-

ми, которые затем (очень тщательно) вносили вручную.

Измеряющим оборудованием, координатными столами и лазером управляла 

специальная утилита. Граница между этим уровнем и MOP была запутанной. 

Уровень утилиты часто вызывал уровень MOP, а специально модифицирован-

ная версия MOP часто вызывала утилиту. В действительности мы не разделяли 

их на два уровня. Для нас это был лишь некоторый код, добавляемый нами 

в MOP и создающий тесные связи.

Затем появился уровень изоляции. Этот уровень поддерживал интерфейс 

виртуальной машины для прикладных программ, которые писались на совер-

шенно другом, предметно-ориентированном языке (Domain-Specific Language; 

DSL). Язык включал операции перемещения лазера и координатного стола, 

выполнения реза и измерений и т. д. Наши клиенты писали на этом языке свои 

программы управления лазером, а изолирующий уровень выполнял их.

Этот подход не предусматривал создания машинно-независимого языка про-

граммирования для управления лазером. В действительности язык имел множе-

ство связей с уровнями, лежащими ниже. Скорее этот подход дал прикладным 

программистам более «простой» язык, чем ассемблер M356, на котором они 

описывали свои задания для лазерной обработки.

Система могла загружать такие программы с ленты и выполнять их. По сути, 

наша система была операционной системой для приложений лазерной обработки.

Система была написана на ассемблере M365 и компилировалась в единственную 

единицу компиляции с абсолютным двоичным кодом.

Границы в этом приложении в лучшем случае были мягкими. Даже граница 

между системным кодом и приложениями на DSL не имела строгой силы. По-

всюду были связи.

Но это было типично для программного обеспечения начала 1970-х.

Контроль алюминиевого литья под давлением   317

Контроль алюминиевого литья 

под давлением

В середине 1970-х годов, когда организация ОПЕК вводила эмбарго на поставки 

нефти, а дефицит бензина провоцировал на заправочных станциях драки между 

озлобленными водителями, я поступил на работу в Outboard Marine Corporation 

(OMC). Это была головная компания, объединившая Johnson Motors и Lawnboy 

Lawnmowers.

OMC имела большое производство в Уокигане, штат Иллинойс, по произ-

водству литых алюминиевых деталей для всех видов двигателей и изделий, 

изготавливаемых компанией. Алюминий расплавлялся в огромных печах и за-

тем в ковшах перевозился к десяткам и десяткам машин для литья. Каждой 

машиной управлял человек-оператор, отвечавший за установку изложниц, 

выполнение цикла литья и извлечение готовых деталей. Зарплата операторов 

зависела от количества отлитых деталей.

Меня наняли для разработки проекта по автоматизации цеха. OMC приобрела 

ЭВМ IBM System/7, которая была ответом IBM на появление мини-компьюте-

ров. Они связали этот компьютер со всеми машинами для литья в цехе, чтобы 

мы могли подсчитать время работы и количество циклов каждой машины. Наша 

задача заключалась в том, чтобы собрать всю эту информацию и вывести ее на 

зеленые экраны терминалов 3270.

Программы для этой машины писались на языке ассемблера. И снова весь 

код, выполнявшийся на этом компьютере, был написан нами до последнего 

бита. У нас не было ни операционной системы, ни библиотек подпрограмм, ни 

фреймворков. Это был просто код.

Причем это был код, управляемый прерываниями и действующий в режиме 

реального времени. Каждый раз, когда какая-то машина завершала цикл, мы 

обновляли пакет статистических данных и посылали сообщение большой ЭВМ 

IBM 370, где работала программа на CICS-COBOL, выводившая эти данные на 

зеленые экраны.

Я ненавидел эту работу. Боже, как я ее ненавидел. Нет, сама работа была ин-

тересной! Но культура... Достаточно сказать, что я был обязан носить галстук.

Я старался. Я очень старался. Но я был очень недоволен этой работой, и мои 

коллеги знали об этом. Они понимали это, потому что я забывал важные даты 

или просыпал в дни, когда надо было рано вставать, чтобы прийти на важное 

совещание. Это была единственная работа, связанная с программированием, 

с которой меня уволили, — и поделом.

С архитектурной точки зрения в этой системе нет ничего поучительного, кро-

ме одного. ЭВМ System/7 имела очень интересную инструкцию установки 

программного прерывания SPI (Set Program Interrupt). Она позволяла вызвать 

318   Приложение. Архитектурная археология

прерывание процессора, чтобы обработать любые другие низкоприоритетные 

прерывания, стоящие в очереди. В современном языке Java имеется схожий 

аналог, который называется Thread.yield().

4-TEL

В октябре 1976 года, после увольнения из OMC, я вернулся в Teradyne, но 

в другое подразделение, где я проработал следующие 12 лет. Там я занимался 

проектом под названием 4-TEL. Его целью было еженощное тестирование всех 

телефонных линий, обслуживаемых компанией, и создание отчета с перечисле-

нием всех линий, требующих ремонта. Это позволяло сосредоточить внимание 

обслуживающего персонала на конкретных телефонных линиях.

Эта система начинала свой путь с той же архитектуры, что и система Laser Trim. 

Это было монолитное приложение, написанное на языке ассемблера и не имев-

шее каких-то значительных границ. Но в то время, когда я вернулся в компанию, 

все должно было измениться.

Система использовалась сотрудниками сервисного центра (Service Center; 

SC). Сервисный центр охватывал несколько телефонных станций (Central 

Offices; CO), каждый из которых мог обслуживать до 10 000 телефонных ли-

ний. Аппаратура переключения линий и измерения уровня сигнала должна 

была размещаться в телефонных станциях (CO). Поэтому мы установили там 

компьютеры M365. Мы называли их тестерами линий в телефонных станциях 

(Central Office Line Testers; COLTs). Еще один M365 находился в сервисном 

центре (SC); он назывался компьютером зоны обслуживания (Service Area 

Computer; SAC). К компьютеру SAC было подключено несколько модемов для 

обмена данными с несколькими компьютерами COLT на скорости 300 бод (30 

символов в секунду).

Сначала всю работу выполняли компьютеры COLT, включая все взаимодей-

ствия с консолями, обслуживание меню и составление отчетов. Компьютер 

SAC играл роль простого мультиплексора, получавшего данные от компьютеров 

COLT и выводившего их на экран.

Проблема такой организации состояла в том, что скорость 30 символов в секун-

ду действительно была слишком маленькой. Работникам не очень нравилось 

наблюдать, как появляются символы на экране, особенно если учесть, что их 

интересовал небольшой объем ключевых данных. Кроме того, в те дни опера-

тивная память в M365 стоила очень дорого, а программа была большой.

Поэтому было решено отделить часть программы, осуществляющую тести-

рование линий, от части, анализирующей результаты и печатающей отчеты. 

Последнюю предполагалось перенести на компьютер SAC, а первая должна 

была продолжать работать на компьютерах COLT. Это должно было позво-

4-TEL   319

лить использовать в качестве COLT машины поменьше, с меньшим объемом 

памяти, и значительно повысить скорость вывода информации на терминал, 

потому что отчеты должны были генерироваться на компьютере SAC.

Результат превзошел самые смелые ожидания. Информация на экране обнов-

лялась очень быстро (после соединения с соответствующим компьютером 

COLT), а объем памяти в компьютерах COLT значительно уменьшился.

Граница получилась очень четкой и надежной. Компьютеры SAC и COLT обме-

нивались очень короткими пакетами. Эти пакеты были очень простой формой 

предметно-ориентированного языка с такими командами, как «DIAL XXXX» 

или «MEASURE».

Загрузка M365 осуществлялась с магнитной ленты. Накопители на магнитной 

ленте были дорогими и не очень надежными, особенно в промышленном окру-

жении телефонных станций. Кроме того, сама машина M365 стоила довольно 

дорого в сравнении с остальной электроникой в компьютерах COLT. Поэтому 

мы приступили к реализации проекта по замене M365 микрокомпьютером на 

базе микропроцессора 8085.

Новый компьютер состоял из процессорной платы с микропроцессором 8085, 

платы ОЗУ с 32 Кбайт памяти и трех плат с ПЗУ, содержащих 12 Кбайт памяти, 

доступной только для чтения. Все эти платы помещались в шасси с измеритель-

ным оборудованием, благодаря чему можно было убрать громоздкое шасси, 

в котором размещалась ЭВМ M365.

Платы ПЗУ содержали по 12 микросхем Intel 2708 EPROM (Erasable 

Programmable Read-Only Memory — стираемое программируемое постоянное 

запоминающее устройство, СППЗУ)1. На рис. П.8 показано, как выглядела такая 

микросхема. Мы записывали программы в эти микросхемы, вставляя их в спе-

циальное устройство, которое назвалось программатором ППЗУ и управлялось 

нашей средой разработки. Информацию на микросхемах можно было стирать, 

подвергая их облучению ультрафиолетовым светом большой интенсивности2.

Мой друг и я занялись переводом программ для COLT с языка ассемблера 

M365 на язык ассемблера 8085. Перевод выполнялся вручную и занял почти 

6 месяцев. В результате получилось около 30 Кбайт кода 8085.

Наша среда разработки имела 64 Кбайт ОЗУ и не имела ПЗУ, поэтому скомпи-

лированный двоичный код мы могли быстро загрузить в ОЗУ и протестировать.

Получив работоспособную программу, мы переключались на использование 

СППЗУ (EPROM). Мы программировали 30 микросхем и вставляли их в со-

1 Да, я понимаю, что это оксюморон.

2 Для этого в микросхемах имелись прозрачные пластиковые окошки, через которые 

можно было видеть кремниевые кристаллы внутри и стирать данные ультрафиолетом.

320   Приложение. Архитектурная археология

ответствующие гнезда в трех платах ПЗУ. Каждая микросхема подписывалась, 

поэтому мы точно знали, какую из них в какое гнездо нужно вставить.

30 Кбайт программного кода — это был единый двоичный блок длиной 30 Кбайт. 

Чтобы записать этот код в микросхемы ПЗУ, мы просто делили двоичный образ 

на 30 сегментов по 1 Кбайт и записывали каждый сегмент в микросхему с соот-

ветствующей надписью.

Рис. П.8. Микросхема СППЗУ (EPROM)

Эта схема прекрасно работала, и мы начали массовое производство оборудова-

ния и развертывание системы в поле.

Но программное обеспечение в первую очередь является программным1. Тре-

бовалось добавлять новые возможности, исправлять ошибки. А так как базовая 

система разрасталась, логистика обновления программного обеспечения путем 

программирования 30 микросхем на каждый экземпляр и замены всех 30 микро-

схем в каждом офисе превращалась в кошмар.

Возможны были все виды проблем. Иногда микросхемы подписывались не-

правильно или наклейки с подписями отваливались. Иногда инженер службы 

эксплуатации мог по ошибке заменить не ту микросхему или поломать один из 

выводов новой микросхемы. Как следствие, инженерам приходилось носить 

с собой все 30 микросхем.

1 Да, я знаю, что после записи программного обеспечения в ПЗУ оно превращается 

в микропрограмму, но микропрограмма не перестает быть программным обеспечением.

4-TEL   321

Зачем менять все 30 микросхем? Каждый раз, когда добавлялся или удалялся 

код из 30-килобайтного блока выполняемого кода, изменялись адреса всех 

машинных инструкций. Изменялись также адреса подпрограмм и функций. То 

есть затрагивалась каждая микросхема, каким бы простым ни было изменение.

Однажды ко мне зашел мой начальник и попросил решить эту проблему. Он 

сказал, что нужно найти какой-то способ изменения микропрограммы без 

замены всех 30 микросхем ПЗУ. Мы в коллективе обсудили эту проблему 

и приступили к проекту «Векторизация». На его реализацию ушло 3 месяца.

Идея была до смешного простой. Мы разбили 30 Кбайт программного кода на 

32 файла с исходным кодом, компилирующихся независимо в блоки меньше одно-

го 1 Кбайт. В начало каждого файла с исходным кодом мы вставили инструкцию, 

сообщающую компилятору, в какой адрес должен компилироваться данный код 

(например, ORG C400 для микросхемы ПЗУ, вставляемой в гнездо C4).

Также в начало каждого файла с исходным кодом мы добавили структуру 

фиксированного размера с адресами всех подпрограмм в этом блоке (вектор 

переходов). Эта структура имела размер 40 байт, поэтому могла хранить до 

20 адресов. Это означало, что блок для одной микросхемы не мог содержать 

более 20 подпрограмм.

Затем мы создали особую область в ОЗУ, которую называли массивом векто-

ров. Она содержала 32 таблицы по 40 байт — достаточный объем для хранения 

указателей на начало каждого блока в отдельных микросхемах.

Наконец, мы заменили вызовы подпрограмм в каждом блоке косвенными вы-

зовами через соответствующий вектор в ОЗУ.

Когда происходила загрузка программы, в массив векторов в ОЗУ загружались 

векторы переходов из всех микросхем ПЗУ, а затем осуществлялся переход 

в точку запуска главной программы.

У нас все получилось. Теперь, когда исправлялась ошибка или добавлялось что-

то новое, мы могли перекомпилировать только один или два файла, записать их 

на соответствующие микросхемы и передать только эти микросхемы инженеру 

службы эксплуатации для замены.

Мы сделали блоки кода независимо развертываемыми. Мы изобрели полиморф-

ную диспетчеризацию. Мы изобрели объекты.

Это была архитектура с подключаемыми модулями (плагинами). Мы подклю-

чали микросхемы. Мы разработали ее так, чтобы новые возможности можно 

было включать в наши продукты установкой микросхем с этими возможностями 

в соответствующие гнезда. Управляющее меню появлялось автоматически, и так 

же автоматически происходила привязка новых возможностей к приложению.

Конечно, тогда мы не знали о принципах объектно-ориентированного програм-

мирования и также ничего не знали об отделении пользовательского интерфейса 

322   Приложение. Архитектурная археология

от бизнес-правил. Но кое-какие основы были заложены, и они здорово нам 

помогли.

Описанный подход дал одно неожиданное преимущество: мы получили воз-

можность обновлять микропрограмму через модемное соединение. Обнаружив 

ошибку, мы могли через модемное соединение связаться с устройством и посред-

ством специальной программы-монитора изменить вектор в ОЗУ, ссылающийся 

на подпрограмму с ошибкой, подставив адрес в пустой области ОЗУ, и затем 

загрузить в эту область ОЗУ исправленную подпрограмму, вводя машинные 

коды в шестнадцатеричном формате.

Это было большим благом для службы эксплуатации и для наших клиентов. 

Если у них возникала проблема, им не требовалось заказывать у нас срочную 

отправку микросхем с исправленным кодом. Систему можно было исправить не-

медленно, а новые микросхемы установить в ближайший период обслуживания.

Компьютер зоны обслуживания

Роль компьютера зоны обслуживания (Service Area Computer; SAC) в 4-TEL 

играл мини-компьютер M365. Эта система взаимодействовала со всеми компью-

терами COLT посредством выделенных или коммутируемых линий. Она могла 

отдавать компьютерам COLT команды на выполнение проверки телефонных ли-

ний, принимать результаты и анализировать их для выявления любых проблем.

Выбор ремонтников для отправки

Одним из экономических обоснований для создания этой системы было эффек-

тивное распределение ремонтников. Ремонтники делились на три категории 

согласно требованиям профсоюза: обслуживающие телефонные станции, кабе-

ли и точки подключения. Ремонтники, обслуживающие телефонные станции, 

исправляли проблемы в телефонных станциях. Ремонтники, обслуживающие 

кабели, исправляли проблемы, связанные с нарушением целостности кабелей, 

соединяющих телефонные станции с клиентами. Ремонтники, обслуживающие 

точки подключения, исправляли проблемы в помещениях клиентов и в линиях, 

соединяющих внешний кабель с этими помещениями.

Когда клиент сообщал о проблеме, наша система могла диагностировать ее 

и определить, каких ремонтников следует направить на ее исправление. Это 

экономило телефонным компаниям уйму денег, потому что выбор не того 

ремонтника означал задержку для клиента и впустую потраченное время на 

поездку ремонтника.

Код, делающий выбор, был разработан и написан талантливым программистом, 

но жутким собеседником. Процесс создания этого кода можно описать так: «Три 

Компьютер зоны обслуживания   323

недели он смотрел в потолок, потом два дня из него, как из рога изобилия, лился 

код, а потом он уволился».

Никто не понимал этот код. Каждый раз, пытаясь добавить что-то новое или ис-

править ошибку, мы что-то да ломали в нем. А поскольку этот код был одним из 

основных экономических преимуществ нашей системы, каждая новая найденная 

ошибка вызывала глубокое замешательство.

В конце концов наше руководство предложило нам просто «заморозить» 

этот код и никогда не менять его. Этот код официально стал незыблемым.

Этот опыт показал мне, насколько ценным может быть хороший, чистый код.

Архитектура

Система была написана в 1976 году на ассемблере M365. Это была единая 

монолитная программа, состоявшая примерно из 60 000 строк кода. Операци-

онная система была собственной разработки. Она реализовала невытесняющую 

многозадачность на основе опроса. Мы назвали ее MPS, от Multiprocessing System 

(многозадачная система). Процессор M365 не имел встроенного стека, поэтому 

локальные переменные задач хранились в специальной области памяти и копи-

ровались при каждом переключении контекста. Доступ к общим переменным 

регулировался с применением блокировок и семафоров. Проблемы реентера-

бельности и состояния гонки преследовали нас постоянно.

Бизнес-правила системы не были изолированы ни от логики управления 

устройствами, ни от логики пользовательского интерфейса. Например, код 

управления модемом можно было найти повсюду в бизнес-правилах и в поль-

зовательском интерфейсе. В системе не было даже намека на попытку собрать 

код в модули или использовать абстрактные интерфейсы. Модемы управлялись 

на уровне битов кодом, разбросанным по всей системе.

То же можно сказать о пользовательском интерфейсе и управлении термина-

лами. Код, управляющий сообщениями и форматированием текста, не был 

изолирован. Его можно было найти повсюду в кодовой базе из 60 000 строк.

Модемные модули, которые мы использовали, были предназначены для монта-

жа на печатных платах. Мы закупали их у сторонней компании и монтировали 

на наши собственные платы. Они стоили очень дорого. Поэтому, спустя не-

сколько лет, мы решили спроектировать свой модем. Мы, члены группы про-

граммирования, попросили конструктора использовать те же битовые форматы 

для управления новым модемом. Мы объяснили, что код управления модемом 

разбросан по всей системе и что в будущем этой системе предстоит работать 

с обоими типами модемов. Мы умоляли и умоляли его: «Пожалуйста, скон-

струируй новый модем так, чтобы с точки зрения программного управления он 

ничем не отличался от старого».

324   Приложение. Архитектурная археология

Но когда мы получили новый модем, управление им было структурировано 

иначе. Не просто чуть-чуть иначе, а совершенно иначе.

Спасибо тебе, конструктор.

И что же нам было делать? Мы могли просто взять и заменить все старые 

модемы новыми. Мы должны были организовать в своих системах управле-

ние модемами обоих видов. Программное обеспечение должно было работать 

с обоими типами модемов одновременно. Мы были обречены окружать код, 

управляющий модемами, флагами и специальными случаями. Но количество 

таких мест исчислялось сотнями!

В конечном итоге мы выбрали еще более плохое решение.

Запись данных в последовательную шину, управлявшую всеми нашими устрой-

ствами, включая модемы, осуществляла единственная подпрограмма. Мы изме-

нили ее так, чтобы она распознавала битовые шаблоны для управления старым 

модемом и транслировала их в битовые шаблоны управления новым модемом.

Это было непросто. Команды управления модемами состояли из последова-

тельностей операций записи в разные адреса ввода/вывода в последовательной 

шине. Новая подпрограмма должна была интерпретировать последовательности 

этих команд и транслировать их в другие последовательности, с другими адре-

сами ввода/вывода, другими временными задержками и иным расположением 

установленных и сброшенных битов.

Мы реализовали это решение, но это было самое худшее из всего, что только 

можно представить. Но благодаря этому я понял ценность абстрактных интер-

фейсов и изоляции аппаратуры от бизнес-правил.

Великая модернизация

К началу 1980-х годов идея создания собственных мини-компьютеров и соб-

ственных компьютерных архитектур стала выходить из моды. На рынке появи-

лось много более стандартных микрокомпьютеров, использовать которые было 

проще и дешевле, чем продолжать полагаться на компьютерные архитектуры 

из конца 1960-х годов. Это, а также жуткая архитектура программного обеспе-

чения SAC вынудили наше техническое руководство инициировать полную 

реорганизацию системы SAC.

</p>
   </article>
</body>
</html>
