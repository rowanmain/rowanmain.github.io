<!DOCTYPE html>
<html>
<head>
   <title>Моя статья</title>
   <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<style>
body {
   background-color: #f0f0f0;
   font-family: Arial, sans-serif;
}

header {
   background-color: #333;
   color: white;
   padding: 10px;
   text-align: center;
}

h1 {
   margin: 0;
}

article {
   margin: 20px;
}

h2 {
   color: #333;
}

p {
   line-height: 1.6;
}
</style>
<body>
   <header>
       <h1>статья</h1>
   </header>
   <article>
       <p>
Рис. 25.1. Одни и те же игровые правила могут использоваться любым числом 

компонентов пользовательского интерфейса

Игровые правила не должны ничего знать о разных видах хранилищ, по-

этому зависимости должны быть направлены в соответствии с правилом 

зависимостей, как показано на рис . 25 .2 .

Английский

интерфейс

Испанский

интерфейс

Правила игры

Данные

на флешке

Данные

в облаке

Рис. 25.2. Следование правилу зависимостей

Чистая архитектура?

Очевидно, что в этом контексте мы легко смогли бы применить приемы соз-

дания чистой архитектуры1 со всеми вариантами использования, границами, 

сущностями и соответствующими структурами данных . Но действительно 

ли мы нашли все важнейшие архитектурные границы?

Например, язык не является единственной осью изменения для пользо-

вательского интерфейса . Также может измениться механизм ввода текста . 

Например, мы можем использовать обычное окно командной оболочки, 

текстовые сообщения или приложение чата . Возможности в этом плане 

бесчисленны .

1 Также должно быть ясно, что мы не будем применять приемы создания чистой архи-

тектуры для таких тривиальных программ, как эта игра . В конце концов, программу 

целиком можно уместить в 200 строк кода и даже меньше . В этом случае мы исполь-

зуем простую программу как прокси для более крупной системы со значимыми архи-

тектурными границами .

222   Глава 25. Уровни и границы

Это означает, что существует потенциальная архитектурная граница, опре-

деляемая этой осью изменения . Возможно, нам следует сконструировать 

API, пересекающий границу и отделяющий язык от механизма ввода; эта 

идея показана на рис . 25 .3 .

Рис. 25.3. Следующая версия диаграммы

Диаграмма на рис . 25 .3 стала сложнее, но не содержит никаких сюрпризов . 

Пунктиром обведены абстрактные компоненты, определяющие API, реали-

зуемый компонентами, стоящими выше или ниже их . Например, Language 

API реализуют компоненты English и Spanish .

GameRules взаимодействует с компонентом Language через API, который опре-

деляет GameRules и реализует Language . Также компонент Language взаимодей-

ствует с компонентом TextDelivery посредством API, который определяется 

в Language и реализуется в TextDelivery . Как видите, API определяется и при-

надлежит компоненту-пользователю, но не реализующему его .

Если заглянуть в GameRules, можно увидеть полиморфные пограничные ин-

терфейсы, используемые внутри GameRules и реализованные в компоненте 

Language . Имеются также полиморфные пограничные интерфейсы, исполь-

зуемые компонентом Language и реализованные в GameRules .

Заглянув в Language, мы увидели бы то же самое: полиморфные погра-

ничные интерфейсы, используемые кодом в Language и реализованные 

в TextDelivery, и полиморфные пограничные интерфейсы, используемые 

кодом в TextDelivery и реализованные в Language .

В каждом случае API определяется пограничными интерфейсами, принад-

лежащими компоненту, находящемуся уровнем выше .

Варианты, такие как English, SMS и CloudData, предоставляются полиморф-

ными интерфейсами, определяемыми в API абстрактных компонентов 

и реализуемыми конкретными компонентами, которые обслуживают их . 

Чистая архитектура?      223

Например, предполагается, что полиморфные интерфейсы, объявленные 

в Language, будут реализованы в English и Spanish .

Эту диаграмму можно упростить, устранив все варианты и сосредоточив-

шись исключительно на API компонентов, как показано на рис . 25 .4 .

Рис. 25.4. Упрощенная диаграмма

Обратите внимание, что диаграмма на рис . 25 .4 ориентирована так, чтобы 

все стрелки указывали вверх . В результате компонент GameRules оказался 

вверху . Такая ориентация имеет определенный смысл, потому что GameRules 

содержит политики высшего уровня .

Рассмотрим направление движения информации . Ввод от пользователя пе-

редается через компонент TextDelivery снизу слева . Она поднимается вверх 

до компонента Language, где транслируется в команды, понятные GameRules . 

GameRules обрабатывает ввод пользователя и посылает соответствующие 

данные вниз, в компонент DataStorage справа внизу .

Затем GameRules посылает ответ обратно в компонент Language, который 

переводит его на соответствующий язык и возвращает пользователю через 

компонент TextDelivery .

Такая организация эффективно делит поток данных на два потока1 . Поток 

слева соответствует взаимодействию с пользователем, а поток справа — 

1 Если вас взволновало несоответствие направлений стрелок на рис . 25 .4, напомню, что 

они соответствуют зависимостям в исходном коде, но не движению потоков данных .

224   Глава 25. Уровни и границы

с хранилищем данных . Оба потока встречаются на вершине1, в компоненте 

GameRules — конечном обработчике данных, через который проходят оба 

потока .

Пересечение потоков

Всегда ли существует только два потока данных, как в данном примере? Нет, 

не всегда . Представьте, что мы захотели реализовать сетевой вариант игры 

«Охота на Вампуса», в которой участвует несколько игроков . В этом случае 

нам потребуется сетевой компонент, как показано на рис . 25 .5 . В данном 

случае поток данных делится на три потока, управляемых компонентом 

GameRules .

Рис. 25.5. Добавление сетевого компонента

То есть с ростом сложности системы структура компонентов может разби-

ваться на несколько потоков .

Разбиение потоков

Сейчас вы наверняка подумали, что все потоки в конечном счете встреча-

ются на вершине диаграммы, в единственном компоненте . Ах, если бы все 

было так просто! Увы, действительность намного сложнее .

Рассмотрим компонент GameRules для игры «Охота на Вампуса» . Часть игро-

вых правил связана с механикой карты . Они знают, как соединены пещеры 

1 В далеком прошлом мы назвали бы компонент на вершине центральным преобразова-

телем (Central Transform) . Подробности см . в книге Meilir Page-Jones, Practical Guide 

to Structured Systems Design», 2nd ed ., 1988 .

Разбиение потоков      225

и какие объекты находятся в каждой пещере . Они знают, как переместить 

игрока из пещеры в пещеру и как генерировать события для игрока .

Но есть еще ряд политик на еще более высоком уровне — политик, которые 

управляют здоровьем персонажа и действием определенных событий . Эти 

политики могут вызывать ухудшение здоровья у персонажа или улучшать 

его, давая персонажу еду и питье . Низкоуровневые политики, отвечающие за 

механику перемещений, могут определять события для этой высокоуровне-

вой политики, такие как FoundFood или FellInPit . А высокоуровневая поли-

тика могла бы управлять состоянием персонажа (как показано на рис . 25 .6) . 

В конечном итоге эта политика могла бы определять окончательный итог — 

победу или проигрыш в игре .

Рис. 25.6. Высокоуровневая политика управляет состоянием персонажа

Является ли это архитектурной границей? Нужно ли нам определить API, 

отделяющий MoveManagement от PlayerManagement? А давайте сделаем ситуа-

цию еще интереснее и добавим микрослужбы .

Допустим, что мы получили массивную многопользовательскую вер-

сию игры «Охота на Вампуса» . Компонент MoveManagement действует ло-

кально, на компьютере игрока, а PlayerManagement действует на сервере . 

PlayerManagement предлагает API микрослужбы для всех подключенных 

компонентов MoveManagement .

Диаграмма на рис . 25 .7 представляет несколько упрощенное отражение 

этого сценария . Элементы Network в действительности немного сложнее, 

чем показано на диаграмме, но сама идея должна быть понятна . В данном 

226   Глава 25. Уровни и границы

случае между MoveManagement и PlayerManagement пролегает полноценная 

архитектурная граница .

Рис. 25.7. Добавление API микрослужб

Заключение

Что из всего этого следует? Почему я взял эту до абсурда простую програм-

му, которую можно уместить в 200 строк кода на языке оболочки Kornshell, 

и развил ее до огромных размеров со всеми этими сумасшедшими архитек-

турными границами?

Этот пример призван был показать, что архитектурные границы существуют 

повсюду . Мы как архитекторы должны проявлять осторожность и проводить 

их, только когда они действительно нужны . Мы также должны помнить, что 

полная реализация границ обходится дорого .

В то же время мы должны помнить, что игнорирование границ может вы-

звать сложности в будущем — даже при наличии всеобъемлющего набора 

тестов и жесткой дисциплины рефакторинга .

Итак, что мы должны делать как архитекторы? Ответ едва ли удовлетворит 

вас . С одной стороны, некоторые очень умные люди много лет говорили нам, 

что мы не должны испытывать потребности в абстракциях . Это философия 

YAGNI: «You Aren’t Going to Need It» («Вам это не понадобится») . В этом 

есть определенная мудрость, поскольку излишнее усложнение конструк-

ции часто намного хуже ее упрощения . С другой стороны, когда обнару-

живается, что в том или ином месте действительно необходимо провести 

архитектурную границу, стоимость и риск ее добавления могут оказаться 

очень высокими .

Заключение      227

Вот так-то, Архитектор Программного Обеспечения, вы должны предви-

деть будущее . Вы должны предугадывать с пониманием дела . Вы должны 

взвесить все за и против, определить, где пролегают архитектурные границы 

и какие из них должны быть реализованы полностью, какие частично, а ка-

кие можно вообще игнорировать .

Но это не единовременное решение . Невозможно раз и навсегда решить на 

ранних этапах проектирования, какие границы реализовать, а какие игно-

рировать . Вы должны наблюдать за развитием системы, отмечать места, где 

может потребоваться провести новую границу, и затем внимательно следить 

за появлением первых трений, возникающих из-за отсутствия границ .

В этот момент нужно взвесить затраты на реализацию границ и цену их 

игнорирования и принять решение . Ваша цель — создать границу прямо 

в точке перегиба, когда реализовать ее окажется дешевле, чем продолжать 

игнорировать .

Для этого вы должны наблюдать очень внимательно .

26 Главный компонент

Конечная деталь      229

В каждой системе имеется хотя бы один компонент, который создает другие 

компоненты, наблюдает за ними и координирует их действия . Я называю 

такой компонент главным (Main) .

Конечная деталь

Компонент Main — это конечная деталь, политика самого низкого уровня . 

Он является точкой входа в систему . От него ничего не зависит, кроме ра-

ботоспособности системы . Его задача — создать все Фабрики, Стратегии 

и другие глобальные средства и затем передать управление высокоуровне-

вым абстракциям в системе .

Именно в компоненте Main должны внедряться все зависимости с использо-

ванием инфраструктуры внедрения зависимостей . После этого компонент 

Main должен распространить эти зависимости, обычно без использования 

инфраструктуры .

Компонент Main можно считать самым грязным из всех грязных компонен-

тов .

Рассмотрим следующий компонент Main из последней версии игры «Охота 

на Вампуса» . Обратите внимание, как он загружает все строки, о которых 

не должен знать основной код .

public class Main implements HtwMessageReceiver {

  private static HuntTheWumpus game;

  private static int hitPoints = 10;

  private static final List<String> caverns = 

      new ArrayList<>();

  private static final String[] environments = new String[]{

    "bright",

    "humid",

    "dry",

    "creepy",

    "ugly",

    "foggy",

    "hot",

    "cold",

    "drafty",

    "dreadful"

  };

  private static final String[] shapes = new String[] {

    "round",

230   Глава 26. Главный компонент

    "square",

    "oval",

    "irregular",

    "long",

    "craggy",

    "rough",

    "tall",

    "narrow"

  };

  private static final String[] cavernTypes = new String[] {

    "cavern",

    "room",

    "chamber",

    "catacomb",

    "crevasse",

    "cell",

    "tunnel",

    "passageway",

    "hall",

    "expanse"

  };

  private static final String[] adornments = new String[] {

    "smelling of sulfur",

    "with engravings on the walls",

    "with a bumpy floor",

    "",

    "littered with garbage",

    "spattered with guano",

    "with piles of Wumpus droppings",

    "with bones scattered around",

    "with a corpse on the floor",

    "that seems to vibrate",

    "that feels stuffy",

    "that fills you with dread"

  };

Далее следует функция main . Обратите внимание, как она использу-

ет HtwFactory для создания игры . Она передает имя класса, htw.game.

HuntTheWumpusFacade, потому что этот класс даже грязнее, чем Main . Это 

предотвращает изменения в данном классе из-за повторной компиляции/

развертывания Main .

public static void main(String[] args) throws IOException {

  game = HtwFactory.makeGame("htw.game.HuntTheWumpusFacade",

                             new Main());

Конечная деталь      231

  createMap();

  BufferedReader br =

    new BufferedReader(new InputStreamReader(System.in));

  game.makeRestCommand().execute();

  while (true) {

    System.out.println(game.getPlayerCavern());

    System.out.println("Health: " + hitPoints + " arrows: " +

                       game.getQuiver());

    HuntTheWumpus.Command c = game.makeRestCommand();

    System.out.println(">");

    String command = br.readLine();

    if (command.equalsIgnoreCase("e"))

      c = game.makeMoveCommand(EAST);

    else if (command.equalsIgnoreCase("w"))

      c = game.makeMoveCommand(WEST);

    else if (command.equalsIgnoreCase("n"))

      c = game.makeMoveCommand(NORTH);

    else if (command.equalsIgnoreCase("s"))

      c = game.makeMoveCommand(SOUTH);

    else if (command.equalsIgnoreCase("r"))

      c = game.makeRestCommand();

    else if (command.equalsIgnoreCase("sw"))

      c = game.makeShootCommand(WEST);

    else if (command.equalsIgnoreCase("se"))

      c = game.makeShootCommand(EAST);

    else if (command.equalsIgnoreCase("sn"))

      c = game.makeShootCommand(NORTH);

    else if (command.equalsIgnoreCase("ss"))

      c = game.makeShootCommand(SOUTH);

    else if (command.equalsIgnoreCase("q"))

      return;

    c.execute();

  }

}

Отметьте также, что функция main создает поток ввода и содержит главный 

цикл игры, в котором происходит интерпретация простых команд, но их 

обработка поручается другим, высокоуровневым компонентам .

Наконец, посмотрите, как main создает карту подземелий .

  private static void createMap() {

    int nCaverns = (int) (Math.random() * 30.0 + 10.0);

    while (nCaverns-- > 0)

      caverns.add(makeName());

      for (String cavern : caverns) {

        maybeConnectCavern(cavern, NORTH);

232   Глава 26. Главный компонент

        maybeConnectCavern(cavern, SOUTH);

        maybeConnectCavern(cavern, EAST);

        maybeConnectCavern(cavern, WEST);

      }

    String playerCavern = anyCavern();

    game.setPlayerCavern(playerCavern);

    game.setWumpusCavern(anyOther(playerCavern));

    game.addBatCavern(anyOther(playerCavern));

    game.addBatCavern(anyOther(playerCavern));

    game.addBatCavern(anyOther(playerCavern));

    game.addPitCavern(anyOther(playerCavern));

    game.addPitCavern(anyOther(playerCavern));

    game.addPitCavern(anyOther(playerCavern));

    game.setQuiver(5);

  }

  // здесь следует еще много кода... 

}

Компонент Main — самый грязный низкоуровневый модуль, находящийся 

во внешнем круге чистой архитектуры . Он загружает все, что потребуется 

системе более высокого уровня, а затем передает ей управление .

Заключение

Представьте, что Main является плагином для приложения — плагином, ко-

торый настраивает начальное окружение, загружает все внешние ресурсы 

и затем передает управление политике верхнего уровня . Так как это плагин, 

может иметься множество компонентов Main, по одному для каждой конфи-

гурации приложения .

Например, у нас может иметься плагин Main для разработки, еще один для 

тестирования и третий для эксплуатации . Можно также создать по плагину 

Main для каждой страны, или каждой юрисдикции, или каждого клиента .

Когда вы начинаете думать о компоненте Main как о плагине, находящемся 

за архитектурной границей, проблемы настройки решаются намного проще .

27

Службы: 

большие и малые

234   Глава 27. Службы: большие и малые

Сервис-ориентированные «архитектуры» и микросервисные «архитектуры» 

приобрели особую популярность в последнее время . Эта популярность обу-

словлена, в том числе, следующими причинами:

 

� Службы выглядят полностью независимыми друг от друга . Но, как мы 

увидим далее, это верно лишь отчасти .

 

� Службы, похоже, можно разрабатывать и развертывать независимо . 

И снова, как мы увидим далее, это верно лишь отчасти .

Сервисная архитектура?

Прежде всего уточним, что утверждение, будто использование служб по 

своей природе является архитектурой, в принципе неверно . Архитектура 

системы определяется границами, отделяющими высокоуровневые по-

литики от низкоуровневых деталей, и следованием правилу зависимостей . 

Службы, просто делящие приложение на функциональные элементы, по 

сути, являются лишь функциями, вызовы которых обходятся довольно до-

рого и не обязательно имеют важное архитектурное значение .

То есть не все службы должны быть архитектурно значимыми . Часто бывает 

выгодно создавать службы, распределяющие функциональные возможности 

по разным процессам и платформам, независимо от того, подчиняются ли 

они правилу зависимостей . Службы сами по себе не определяют архитек-

туру .

Наглядной аналогией является организация функций . Архитектура моно-

литной или компонентной системы определяется некоторыми вызовами 

функций, пересекающими архитектурные границы и следующими правилу 

зависимостей . Однако многие другие функции в системе просто отделяют 

одно поведение от другого и не являются архитектурно значимыми .

То же верно в отношении служб . Службы, в конечном счете, — это всего 

лишь вызовы функций через границы процессов и/или платформ . Неко-

торые из этих служб действительно являются архитектурно значимыми, 

а другие — нет . Основной интерес для нас в этой главе представляют первые .

Преимущества служб?

Знак вопроса в заголовке указывает, что в этом разделе мы поставим под со-

мнение популярное мнение о сервис-ориентированной архитектуре . Давайте 

рассмотрим предполагаемые преимущества по одному .

Преимущества служб?      235

Заблуждение о независимости

Одно из самых больших предполагаемых преимуществ деления системы 

на службы заключается в полной независимости их друг от друга . В конце 

концов, каждая служба выполняется в отдельном процессе или даже на дру-

гой машине; поэтому службы не имеют доступа к переменным друг друга . 

Более того, для каждой службы должен быть четко определен ее интерфейс .

Все это верно до определенной степени, но не до конца . Да, службы незави-

симы на уровне отдельных переменных . Но они все еще могут быть связаны 

вместе общими ресурсами на одной машине или в сети . Более того, они 

тесно связаны общими данными .

Например, чтобы добавить новое поле в запись, которая передается между 

службами, придется изменить все службы, использующие это новое поле . 

Службы должны также согласовать интерпретацию данных в этом поле . 

То есть службы тесно связаны с записью и, соответственно, косвенно свя-

заны друг с другом .

Утверждение о необходимости четко определять интерфейс тоже верно, но 

оно в той же мере относится к функциям . Интерфейсы служб не являются 

более формальными, строгими и четкими, чем интерфейсы функций . Как 

видите, это преимущество довольно иллюзорно .

Заблуждение о возможности независимой 

разработки и развертывания

Другое предполагаемое преимущество — возможность передачи служб во 

владение отдельным командам . Каждая такая команда может отвечать за 

разработку, сопровождение и эксплуатацию службы, как это предполагает 

стратегия интеграции разработки и эксплуатации (DevOps) . Такая не-

зависимость разработки и развертывания, как предполагается, является 

масштабируемой . Считается, что крупные корпоративные системы могут 

состоять из десятков, сотен и даже тысяч служб, разрабатываемых и раз-

вертываемых независимо . Разработку, сопровождение и эксплуатацию 

системы можно разделить между аналогичным количеством независимых 

команд .

Это утверждение верно, но лишь отчасти . Во-первых, как показывает исто-

рия, крупные корпоративные системы могут состоять из монолитных и ком-

понентных систем, а также из систем, состоящих из служб . То есть службы 

не единственный способ построения масштабируемых систем .

236   Глава 27. Службы: большие и малые

Во-вторых, как было показано в разделе «Заблуждение о независимости», 

службы не всегда могут разрабатываться, развертываться и эксплуатиро-

ваться независимо . Их разработку приходится координировать в той же 

мере, в какой они связаны данными или поведением .

Проблема с животными

Чтобы рассмотреть эти два заблуждения на примере, вернемся снова к на-

шей системе агрегатора такси . Как вы помните, эта система знает о несколь-

ких компаниях, предоставляющих услуги такси в данном городе, и позво-

ляет клиентам заказывать поездки . Представим, что клиенты выбирают 

такси по ряду критериев, таких как время ожидания, стоимость, комфорт 

и опытность водителя .

Мы решили для большей масштабируемости реализовать ее в виде мно-

жества маленьких микрослужб . Мы разделили большой коллектив раз-

работчиков на множество маленьких команд и каждой поручили раз-

работку, сопровождение и эксплуатацию соответствующего1 количества 

микрослужб .

Схема на рис . 27 .1 демонстрирует, как наши предполагаемые архитекторы 

распределили ответственность приложения между микрослужбами . Служба 

TaxiUI взаимодействует непосредственно с клиентом, заказывающим такси 

с помощью своего мобильного устройства . Служба TaxiFinder исследует 

параметры разных поставщиков услуг TaxiSupplier и выбирает возможных 

Список кандидатов

Рис. 27.1. Организация системы-агрегатора услуг такси в виде комплекса служб

1 Примерно по числу программистов в команде .

Проблема с животными      237

кандидатов для обслуживания клиента . Она собирает их во временной запи-

си, прикрепленной к данному пользователю . Служба TaxiSelector получает 

критерии, обозначенные пользователем, касающиеся стоимости, времени, 

комфорта и т . д ., и выбирает наиболее походящий вариант из списка кан-

дидатов . Затем она передает выбранный вариант службе TaxiDispatcher, 

которая оформляет заказ .

Теперь представим, что эта система работает уже больше года . Наши раз-

работчики успешно добавляют новые возможности, сопровождают и экс-

плуатируют все эти службы .

В один прекрасный солнечный день сотрудники отдела маркетинга орга-

низовали встречу с разработчиками . На этой встрече они объявили о своем 

решении организовать услугу по доставке котят . Как предполагается, кли-

енты смогут заказать доставку котят себе домой или на работу .

Компания создаст несколько пунктов сбора котят по всему городу, и когда 

поступит заказ, ближайшее такси заберет котенка в одном из пунктов сбора 

и доставит по указанному адресу .

Один из поставщиков услуг согласился участвовать в этой программе . 

Другие, скорее всего, последуют его примеру, а третьи могут отклонить 

предложение .

У некоторых водителей, как вы понимаете, может быть аллергия на кошек, 

поэтому их нельзя выбирать для выполнения таких заказов . Кроме того, 

у некоторых клиентов тоже может быть аллергия на кошек, поэтому для 

обслуживания тех, кто заявил об аллергии на кошек, не должны выбираться 

машины, осуществлявшие доставку котят в последние три дня .

А теперь взгляните на диаграмму служб и скажите, сколько из них придется 

изменить, чтобы реализовать описанную услугу? Все! Совершенно понятно, 

что разработка и развертывание услуги доставки котят должны быть тща-

тельно скоординированы .

Иными словами, все службы тесно связаны между собой и не могут разра-

батываться, развертываться и сопровождаться независимо .

Эта проблема свойственна всем сквозным задачам . С этой проблемой 

приходится сталкиваться любой системе, независимо от того, органи-

зована она в виде комплекса служб или нет . Системы, разделенные на 

службы по функциональному признаку, как показано на рис . 27 .1, очень 

уязвимы для новых особенностей, пересекающих все эти функциональные 

уровни .

238   Глава 27. Службы: большие и малые

Спасение в объектах

Как бы мы решили эту проблему в архитектуре, состоящей из компонентов? 

Неуклонное следование принципам проектирования SOLID вынудило бы 

нас создать набор классов, которые можно было бы полиморфно расширять 

под потребности новых возможностей .

Схема на рис . 27 .2 демонстрирует эту стратегию . Классы на этой схеме 

примерно соответствуют службам на рис . 27 .1 . Но обратите внимание на 

границы . Отметьте также, что все зависимости оформлены в соответствии 

с правилом зависимостей .

Фабрики

компонентов

Рис. 27.2. Использование объектно-ориентированного подхода для преодоления 

проблемы сквозных задач

Службы на основе компонентов      239

Большая часть логики оригинальных служб сосредоточена в базовых клас-

сах объектной модели . Однако часть логики, связанная с поездками, выде-

лена в компонент Rides . Реализация новой услуги по доставке котят поме-

щена в отдельный компонент Kittens . Эти два компонента переопределяют 

абстрактные базовые классы из оригинальных компонентов с применением 

шаблонов, таких как «Шаблонный метод» или «Стратегия» .

Отметим еще раз, что два новых компонента, Rides и Kittens, подчиняются 

правилу зависимостей . Обратите также внимание, что классы, реализующие 

эти возможности, создаются фабриками под управлением пользовательского 

интерфейса .

Ясно, что в этой схеме после реализации Kittens придется изменить TaxiUI . 

Но все остальное останется в прежнем виде . В систему добавится лишь 

новый файл jar, Gem или DLL, который будет динамически загружаться во 

время выполнения системы .

То есть компонент Kittens существует отдельно от других и может разраба-

тываться и развертываться независимо .

Службы на основе компонентов

Возникает резонный вопрос: можно ли реализовать нечто подобное 

для служб? И ответ, конечно, да! Службы не обязательно должны быть 

маленькими монолитами . Службы также могут проектироваться в соот-

ветствии с принципами SOLID и данной структурой компонентов, чтобы 

иметь возможность добавлять в них новые компоненты, не изменяя су-

ществующие .

Представьте службу на Java как набор абстрактных классов в одном или 

нескольких jar-файлах . Каждую новую возможность или расширение су-

ществующей возможности можно реализовать как отдельный jar-файл, 

содержащий классы, наследующие абстрактные классы из уже имеющихся 

jar-файлов . Для развертывания новой возможности в этом случае больше 

не потребуется повторно развертывать службы, достаточно лишь добавить 

новые jar-файлы в пути загрузки этих служб . Иными словами, добавление 

новой возможности выполняется в соответствии с принципом открытости/

закрытости (Open-Closed Principle; OCP) .

Схема на рис . 27 .3 демонстрирует такую организацию служб . На ней пред-

ставлены все те же службы, только на этот раз каждая состоит из ком-

понентов, что позволяет добавлять новые возможности, реализованные 

240   Глава 27. Службы: большие и малые

в виде новых производных классов . Эти производные классы находятся 

в собственных компонентах .

Список кандидатов

Рис. 27.3. Каждая служба состоит из компонентов, что позволяет добавлять новые 

возможности, реализованные в виде новых производных классов

Сквозные задачи

Теперь мы знаем, что архитектурные границы не всегда совпадают с грани-

цами между службами . Часто эти границы проходят через службы, деля их 

на компоненты .

Для преодоления проблем, связанных со сквозными задачами, с которыми 

сталкиваются все достаточно крупные системы, службы должны иметь ком-

понентные архитектуры, следующие правилу зависимостей, как показано 

на рис . 27 .4 . Эти службы не определяют архитектурные границы в системе; 

границы определяются компонентами в службах .

Заключение      241

Рис. 27.4. Службы должны иметь компонентные архитектуры,  

следующие правилу зависимостей

Заключение

Несмотря на все преимущества масштабируемости и удобства разработки 

системы, службы не являются архитектурно значимыми элементами . Ар-

хитектура системы определяется границами, проводимыми внутри этой 

системы, и зависимостями, пересекающими эти границы . Архитектура не 

определяется физическими механизмами, посредством которых элементы 

взаимодействуют и выполняются .

Служба может быть единственным компонентом, полностью окруженным 

архитектурной границей . Но точно так же служба может состоять из не-

скольких компонентов, разделенных архитектурными границами . В редких1 

случаях клиенты и службы могут быть настолько связаны, что не могут 

иметь архитектурной значимости .

1 Хотелось бы надеяться, что в очень редких, но опыт показывает, что это не так .

28 Границы тестов

Тесты как компоненты системы      243

Да, все правильно: тесты являются частью системы и занимают свое место 

в архитектуре, как любые другие части системы . В одних случаях это вполне 

нормальное явление . В других оно может быть уникальным .

Тесты как компоненты системы

С тестами связано много неясностей . Являются ли они частью системы? 

Должны ли они отделяться от системы? Какие виды тестов бывают? Яв-

ляются ли модульные и интеграционные тесты разными тестами? Какое 

место во всем этом занимают приемочные тесты, функциональные тесты, 

тесты для фреймворка Cucumber, тесты TDD, тесты BDD, тесты для ком-

понентов и т . д .?

Обсуждение данной конкретной темы не является целью этой книги, 

и, к счастью, этого не требуется . С архитектурной точки зрения все тесты 

одинаковы . Будь то маленькие тесты TDD, или большие тесты FitNesse, 

Cucumber, SpecFlow, или JBehave — все они архитектурно эквивалентны .

Тесты по самой своей природе следуют правилу зависимостей; они очень де-

тальны и конкретны; и они всегда зависят от тестируемого кода . Фактически 

тесты можно считать самым внешним кругом архитектуры . Ничто в системе 

не зависит от тестов, но тесты всегда зависят от внутренних компонентов 

системы .

Тесты также можно развертывать независимо . Фактически в большинстве 

случаев они развертываются в тестовых системах, но не развертываются 

в производственных системах . То есть даже в системах, где независи-

мое развертывание не требуется, тесты все равно развертываются неза-

висимо .

Тесты являются наиболее изолированными компонентами системы . Они 

не нужны системе для нормального функционирования . Пользователи не 

зависят от них . Их роль — поддержать разработку, но не работу . И все же 

они являются не менее важным системным компонентом, чем любые дру-

гие . Фактически они представляют модель, которой должны следовать все 

остальные компоненты .

244   Глава 28. Границы тестов

Проектирование для простоты 

тестирования

Крайняя степень изоляции тестов в сочетании с тем фактом, что они 

обычно не развертываются, часто заставляет разработчиков думать, что 

тесты выходят за рамки дизайна системы. Это абсолютно неверная точка 

зрения. Тесты, недостаточно хорошо интегрированные в дизайн системы, 

обычно оказываются хрупкими и делают систему жесткой и неудобной 

для изменения.

Проблема, конечно, заключается в тесной зависимости. Тесты, тесно связан-

ные с системой, должны изменяться вместе с системой. Даже самые безо-

бидные изменения в системном компоненте могут нарушить нормальную 

работу многих связанных тестов или потребовать их изменения.

Эта ситуация может приобретать особую остроту. Изменения в общих си-

стемных компонентах могут нарушить работу сотен и даже тысяч тестов. 

Эта ситуация известна как «проблема хрупких тестов».

Нетрудно понять, как это может произойти. Представьте, например, на-

бор тестов, использующих графический интерфейс для проверки биз-

нес-правил. Такие тесты могут начинать работу на странице авторизации 

и затем последовательно переходить от страницы к странице, проверяя 

определенные бизнес-правила. Любое изменение в странице авторизации 

или в структуре навигации может нарушить работу большого количества 

тестов.

Хрупкие тесты часто оказывают отрицательное влияние, делая систему 

жесткой. Когда разработчики замечают, что простые изменения в системе 

вызывают массовые отказы тестов, они могут противиться таким изме-

нениям. Например, представьте диалог между командой разработчиков 

и сотрудниками отдела маркетинга, просящими внести простое изменение 

в структуру навигации, которое нарушит работу 1000 тестов.

Решение заключается в том, чтобы закладывать возможность тестирования 

в проект. Первое правило проектирования программного обеспечения — 

идет ли речь о тестируемости или о чем-то еще — всегда одно: не зависеть 

ни от чего, что может часто меняться. Пользовательские интерфейсы 

переменчивы. Наборы тестов, осуществляющие проверки посредством 

пользовательского интерфейса, должны быть хрупкими. Поэтому система 

и тесты должны проектироваться так, чтобы работу бизнес-правил можно 

было проверить без пользовательского интерфейса.

Безопасность      245

Программный интерфейс 

для тестирования

Для достижения этой цели следует создать специальный программный 

интерфейс для тестов, чтобы дать им возможность проверить все бизнес-

правила . Этот API должен защищать тесты от проблем с ограничениями 

безопасности, не использовать дорогостоящие ресурсы (таких, как базы дан-

ных) и заставлять систему входить в особые тестируемые состояния . Такой 

API должен быть надмножеством интеракторов и адаптеров интерфейсов, 

которые используются пользовательским интерфейсом .

Цель API тестирования — отделить тесты от приложения . Под отделением 

подра зумевается не только отделение тестов от пользовательского интер-

фейса: цель — отделить структуру тестов от структуры приложения .

Структурная зависимость

Структурная зависимость — одна из самых сильных и наиболее коварных 

форм зависимости тестов . Представьте набор тестов, в котором имеются те-

стовые классы для всех прикладных классов и тестовые методы для всех при-

кладных методов . Такой набор очень тесно связан со структурой приложения .

Изменение в одном из прикладных методов или классов может повлечь не-

обходимость изменить большое количество тестов . Следовательно, тесты 

слишком хрупкие и могут сделать прикладной код слишком жестким .

Роль API тестирования — скрыть структуру приложения от тестов . Это по-

зволит развивать прикладной код, не влияя на тесты . Это также позволит 

развивать тесты, не влияя на прикладной код .

Такая возможность независимого развития абсолютно необходима, потому 

что с течением времени тесты становятся все более конкретными, а при-

кладной код, напротив, — все более абстрактным и обобщенным . Тесная 

структурная зависимость препятствует такому развитию — или, по меньшей 

мере, затрудняет его — и мешает прикладному коду становиться все более 

обобщенным и гибким .

Безопасность

Открытость API тестирования может представлять опасность, если раз-

вернуть его в производственной системе . Если это действительно так, API 

246   Глава 28. Границы тестов

тестирования и небезопасные части его реализации должны находиться 

в отдельном компоненте, устанавливаемом независимо .

Заключение

Тесты не находятся вне системы; они — часть системы, и к их проектиро-

ванию следует подходить с неменьшим вниманием, чтобы получить от них 

выгоды в виде стабильности и защищенности от регрессий . Тесты, которые 

не проектируются как часть системы, получаются хрупкими и сложными 

в сопровождении . Такие тесты часто заканчивают свое существование в ком-

нате персонала, осуществляющего сопровождение, потому что их слишком 

тяжело поддерживать .

29

Чистая встраиваемая 

архитектура

Автор: Джеймс Греннинг  

(James Grenning)

248   Глава 29. Чистая встраиваемая архитектура

Некоторое время тому назад я прочитал статью The Growing Importance of 

Sustaining Software for the DoD1 («Растущее значение устойчивого программ-

ного обеспечения для министерства обороны») в блоге Дуга Шмидта . В ней 

Дуг сделал следующее заявление:

Несмотря на то что программное обеспечение не изнашивается, встроенные 

микропрограммы и оборудование устаревают, что требует модификации 

программного обеспечения.

Этот момент кое-что прояснил для меня . Дуг упомянул два термина, кото-

рые я мог или не мог бы счесть очевидными . Программное обеспечение — 

это то, что имеет долгий срок службы, но встроенные микропрограммы 

(firmware) устаревают в процессе развития аппаратного обеспечения . Если 

у вас есть опыт разработки встраиваемых систем, вы должны знать, что 

оборудование постоянно совершенствуется . В то же время добавляются 

новые функции в «программное обеспечение», и его сложность постоянно 

растет .

Я хотел бы добавить к заявлению Дуга:

Несмотря на то что программное обеспечение не изнашивается, оно может 

быть разрушено неуправляемыми зависимостями от микропрограмм и обо-

рудования.

Нередко встроенному программному обеспечению может быть отказано 

в долгой жизни из-за заражения зависимостями от аппаратного обеспече-

ния .

Мне нравится, как Дуг охарактеризовал микропрограммы, но давайте посмо-

трим, какие еще определения можно дать . Я, например, нашел следующие 

варианты:

 

� «Микропрограммы хранятся в энергонезависимых запоминаю-

щих устройствах, таких как ПЗУ, ППЗУ или флеш-память» (https://

ru.wikipedia.org/wiki/Встроенное_программное_обеспечение) .

 

� «Микропрограмма — это программа, или набор инструкций, заключенная 

в аппаратном устройстве» (https://techterms.com/definition/firmware) .

 

� «Микропрограмма — это программное обеспечение, встроенное в устрой-

ство» (https://www.lifewire.com/what-is-firmware-2625881) .

1 https://insights.sei.cmu.edu/sei_blog/2011/08/the-growing-importance-of-sustaining-

software-for-thedod.html

Чистая встраиваемая архитектура      249

 

� Микропрограмма — это «программное обеспечение (программа или 

данные), записанное в постоянное запоминающее устройство (ПЗУ)» 

(http://www.webopedia.com/TERM/F/firmware.html) .

Заявление Дуга помогло мне заметить ошибочность всех этих общеприня-

тых определений микропрограмм или, по крайней мере, их неактуальность . 

Название «микропрограмма» не подразумевает, что код хранится в ПЗУ . 

Принадлежность к категории микропрограмм не зависит от места хранения; 

в большей степени она зависит от сложности изменения в процессе совер-

шенствования оборудования . Оборудование действительно совершенству-

ется (приостановитесь и взгляните на свой телефон), поэтому мы должны 

структурировать свой встраиваемый код с учетом этой данности .

Я ничего не имею против микропрограмм или разработчиков микропро-

грамм (я сам занимался созданием микропрограмм) . Но мы действительно 

должны меньше писать микропрограммы и больше — программное обеспе-

чение . На самом деле я разочарован тем, что разработчики микропрограмм 

пишут их как микропрограммы!

Инженеры, не занимающиеся разработкой встраиваемого программного 

обеспечения, тоже пишут микропрограммы! Вы тоже фактически пишете 

микропрограммы, когда внедряете SQL в свой код или когда ставите его 

в зависимость от платформы . Разработчики приложений для Android пишут 

микропрограммы, когда не отделяют бизнес-логику от Android API .

Я участвовал в разработке многих проектов, где грань между приклад-

ным кодом (программным обеспечением) и кодом, взаимодействующим 

с оборудованием (микропрограммой), была размыта до полного исчезно-

вения . Например, в конце 1990-х годов мне посчастливилось участвовать 

в перепроектировании подсистемы коммуникации с целью перехода от 

технологии мультиплексирования с разделением по времени (Time-Division 

Multiplexing; TDM) к технологии передачи голоса по протоколу IP (Voice 

Over IP; VOIP) . Технология VOIP широко используется в наши дни, а тех-

нология TDM считалась современной в 1950 — 1960-х годах и широко при-

менялась в 1980 — 1990-х годах .

Всякий раз, когда у нас появлялся вопрос к инженеру-системотехнику о том, 

как вызов должен реагировать в той или иной ситуации, он исчезал и спу-

стя какое-то время появлялся с очень подробным ответом . «Откуда ты это 

узнал?» — спрашивали мы . «Из кода продукта», — отвечал он . Запутанный 

и устаревший код служил справочником по новому продукту! Существу-

ющая реализация не имела разделения между TDM и бизнес-логикой, 

выполняющей вызовы . Весь продукт целиком зависел от оборудования/

250   Глава 29. Чистая встраиваемая архитектура

технологий, и этот клубок нельзя было распутать . Весь продукт фактически 

был микропрограммой .

Рассмотрим другой пример: управляющие сообщения поступают в систему 

через последовательный порт . Неудивительно, что в такой системе имеется 

обработчик/диспетчер сообщений . Обработчик сообщений знает их форма-

ты, может их анализировать и передавать коду, который сгенерирует ответ . 

Ничто из перечисленного не вызывает удивления, кроме того, что обработ-

чик/диспетчер сообщений находится в том же файле, что и код, взаимодей-

ствующий с микросхемой UART1 . Обработчик сообщений инфицирован 

деталями, имеющими отношение к микросхеме UART . Он мог бы быть 

программным обеспечением с потенциально большим сроком службы, но 

вместо этого он стал микропрограммой . Обработчику сообщений отказано 

в праве быть программным обеспечением — и это неправильно!

Я давно знал и понимал важность отделения программного обеспечения от 

оборудования, но слова Дуга прояснили, как использовать термины про-

граммное обеспечение и микропрограмма в отношении друг к другу .

Это ясное сообщение для инженеров и программистов: прекратите писать 

так много микропрограмм и дайте своему коду шанс служить долго . Конеч-

но, потребовать этого не получится . Но давайте посмотрим, как сохранить 

архитектуру встраиваемого программного кода в чистоте, чтобы дать про-

граммному обеспечению шанс служить долго .

Тест на профпригодность

Почему так много программного обеспечения превращается в микропро-

граммы? Похоже, что основная причина заключается в стремлении получить 

действующий встраиваемый код и практически не уделяется внимания его 

структурированию для увеличения срока службы . Кент Бек описывает три 

шага в создании программного обеспечения (далее в кавычках приводятся 

слова Кента, а курсивом выделены мои комментарии):

1 . «Сначала заставьте его работать» . Вы останетесь не у дел, если он не 

работает.

2 . «Затем перепишите его правильно» . Реорганизуйте код, чтобы вы и дру-

гие смогли понимать и развивать его, когда потребуется что-то изме-

нить или понять.

1 Микросхема, управляющая последовательным портом .

Тест на профпригодность      251

3 . «Затем заставьте его работать быстро» . Реорганизуйте код, чтобы до-

биться «необходимой» производительности.

Большая часть встраиваемых систем, которые мне приходилось видеть, по-

хоже, писалась с единственной мыслью в голове: «Заставьте его работать», — 

и иногда с навязчивой идеей: «Заставьте его работать быстро», — воплоща-

емой введением микрооптимизаций при каждом удобном случае . В своей 

книге The Mythical Man-Month1 Фред Брукс предлагает «планировать отказ 

от первой версии» . Кент и Фред советуют практически одно и то же: узнайте, 

как это работает, и найдите лучшее решение .

Встраиваемое программное обеспечение ничем не отличается в отношении 

этих проблем . Многие невстраиваемые приложения доводятся только до 

стадии «работает», и мало что делается, чтобы код получился правильным 

и служил долго .

Получение работающего приложения — это то, что я называю тестом на 

профпригодность для программиста . Программист, разрабатывающий про-

граммное обеспечение, встраиваемое или нет, который заботится только 

о том, чтобы получить работающее приложение, наносит вред своим продук-

там и работодателю . Программирование — это нечто большее, чем умение 

писать работающие приложения .

В качестве примера взгляните на следующие функции, находящиеся в одном 

файле маленькой встраиваемой системы, написанные в ходе прохождения 

теста на профпригодность:

ISR(TIMER1_vect) { ... }

ISR(INT2_vect) { ... }

void btn_Handler(void) { ... }

float calc_RPM(void) { ... }

static char Read_RawData(void) { ... }

void Do_Average(void) { ... }

void Get_Next_Measurement(void) { ... }

void Zero_Sensor_1(void) { ... }

void Zero_Sensor_2(void) { ... }

void Dev_Control(char Activation) { ... }

char Load_FLASH_Setup(void) { ... }

void Save_FLASH_Setup(void) { ... }

void Store_DataSet(void) { ... }

float bytes2float(char bytes[4]) { ... }

void Recall_DataSet(void) { ... }

void Sensor_init(void) { ... }

void uC_Sleep(void) { ... }

1 Фредерик Брукс . Мифический человеко-месяц, или Как создаются программные си-

стемы . СПб .: Символ-Плюс (2007) . — Примеч. пер.

252   Глава 29. Чистая встраиваемая архитектура

В таком порядке функции были объявлены в файле с исходным кодом . 

А теперь разделим их и сгруппируем по решаемым задачам:

 

� функции, реализующие предметную логику:

• float calc_RPM(void) { ... }

• void Do_Average(void) { ... }

• void Get_Next_Measurement(void) { ... }

• void Zero_Sensor_1(void) { ... }

• void Zero_Sensor_2(void) { ... }

 

� функции, обслуживающие аппаратную платформу:

• ISR(TIMER1_vect) { ... }*

• ISR(INT2_vect) { ... }

• void uC_Sleep(void) { ... }

 

� функции, реагирующие на нажатия кнопок:

• void btn_Handler(void) { ... }

• void Dev_Control(char Activation) { ... }

 

� функция, читающая данные из аппаратного аналогово-цифрового пре-

образователя:

• static char Read_RawData(void) { ... }

 

� функции, записывающие значения в долговременное хранилище:

• char Load_FLASH_Setup(void) { ... }

• void Save_FLASH_Setup(void) { ... }

• void Store_DataSet(void) { ... }

• float bytes2float(char bytes[4]) { ... }

• void Recall_DataSet(void) { ... }

 

� функция, которая не делает того, что подразумевает ее имя:

• void Sensor_init(void) { ... }

Заглянув в другие файлы этого приложения, я нашел множество препят-

ствий, мешающих пониманию кода . Также я обнаружил, что организация 

файлов подра зумевает единственный способ тестирования этого кода — 

непосредственно внутри целевого устройства . Практически каждый бит 

этого кода знает, что относится к специализированной микропроцессорной 

Привязка к оборудованию — узкое место      253

архитектуре, используя «расширенные» конструкции языка C1, привязыва-

ющие код к конкретному набору инструментов и микропроцессору . У этого 

кода нет ни малейшего шанса служить долго, если будет решено перенести 

продукт на другую аппаратную платформу .

Приложение работает: инженер прошел тест на профпригодность . Но нельзя 

сказать, что оно имеет чистую встраиваемую архитектуру .

Привязка к оборудованию — 

узкое место

Существует масса особых проблем, с которыми приходится сталкиваться 

разработчикам встраиваемых систем и не знакомых разработчикам обыч-

ного программного обеспечения . Например, ограниченный объем памяти, 

ограничения по времени выполнения операций, ограниченные возмож-

ности ввода/вывода, нетрадиционные пользовательские интерфейсы, 

а также наличие датчиков и контактов, соединяющих с внешним миром . 

В большинстве случаев аппаратное обеспечение развивается параллельно 

с программным обеспечением и микропрограммами . У вас, как инженера, 

разрабатывающего код для такого рода систем, может не быть места для за-

пуска кода . Но это еще не самое худшее — полученное оборудование может 

иметь собственные недостатки, что замедляет разработку программного 

обеспечения больше, чем обычно .

Да, встраиваемое программное обеспечение имеет свои особенности, и ин-

женеры встраиваемых систем — особые люди . Но разработка встраиваемых 

систем не настолько особенная, чтобы принципы, описываемые в этой книге, 

нельзя было применить к встраиваемым системам .

Одна из особых проблем встраиваемых систем — тесная зависимость от 

оборудования . Когда встраиваемый код структурируется без применения 

принципов и приемов чистой архитектуры, часто приходится сталкиваться 

со сценарием, когда код можно протестировать только на целевом обо-

рудовании . Если это оборудование — единственное место, где возможно 

тестирование, такая тесная связь начинает замедлять вас .

1 Некоторые производители микроконтроллеров добавляют свои ключевые слова 

в язык C, чтобы упростить доступ к регистрам и портам из кода на C . К сожалению, 

как только код начинает использовать такие ключевые слова, он перестает быть 

кодом на C .

254   Глава 29. Чистая встраиваемая архитектура

Чистая встраиваемая архитектура — 

архитектура, поддерживающая тестирование

Давайте посмотрим, как применяются некоторые архитектурные принципы 

к встраиваемому программному обеспечению и микропрограммам и как они 

помогают избавиться от тесной привязки к оборудованию .

Уровни

Деление на уровни можно произвести разными способами . Начнем с трех-

уровневой организации, изображенной на рис . 29 .1 . Внизу находится уро-

вень оборудования . Как предупреждает Дуг, вследствие совершенствования 

технологий и согласно закону Мура оборудование будет изменяться . Одни 

компоненты устаревают, и на смену им приходят новые компоненты, по-

требляющие меньше электроэнергии, или имеющие более высокую произ-

водительность, или стоящие дешевле . Независимо от причин я, как инженер 

встраиваемых систем, не хотел бы делать больше, чем необходимо, когда 

неизбежное изменение оборудования наконец произойдет .

Программное

обеспечение

Микропрограмма

Оборудование

Рис. 29.1. Три уровня

Раздел между оборудованием и остальной частью системы — объективная 

реальность, по крайней мере после определения оборудования (рис . 29 .2) . 

Именно здесь часто возникают проблемы при попытке пройти тест на проф-

пригодность . Ничто не мешает знаниям об оборудовании инфицировать 

весь код . Если не проявить осторожность при структурировании кода и не 

ограничить просачивание сведений об одном модуле в другой, код будет 

трудно изменить . Я говорю не только о случае, когда изменяется оборудова-

ние, но также о ситуации, когда понадобится исправить ошибку или внести 

изменение по требованию пользователя .

Привязка к оборудованию — узкое место      255

Микро-

программа

Оборудование

Рис. 29.2. Оборудование должно отделяться от остальной системы

Смешивание программного обеспечения и микропрограмм — это антиша-

блон . Код, демонстрирующий этот антишаблон, будет сопротивляться изме-

нениям . Кроме того, изменения сопряжены с опасностями, часто ведущими 

к непредвиденным последствиям . Даже незначительные изменения требуют 

полного регрессионного тестирования системы . Если вы не создали тесты 

с внешним оборудованием, готовьтесь проводить тестирование вручную, 

а затем ожидать новых сообщений об обнаруженных ошибках .

Оборудование — это деталь

Линия между программным обеспечением и микропрограммами обычно 

видна не так четко, как линия, разделяющая код и оборудование (рис . 29 .3) .

Одна из задач разработчика встраиваемого программного обеспечения — 

укрепить эту линию . Границу между программным обеспечением и микро-

Программное

обеспечение

Микро-

программа

Оборудование

Рис. 29.3. Линия между программным обеспечением и микропрограммами обычно 

более размытая, чем линия между кодом и оборудованием

256   Глава 29. Чистая встраиваемая архитектура

программой (рис . 29 .4) называют слоем аппаратных абстракций (Hardware 

Abstraction Layer; HAL) . Это не новая идея: она была реализована в персо-

нальных компьютерах еще в эпоху до Windows .

Программное

обеспечение

Микро-

программа

Оборудование

Рис. 29.4. Слой аппаратных абстракций

Слой HAL существует для программного обеспечения над ним, и его API 

должен приспосабливаться под потребности этого программного обеспече-

ния . Например, микропрограмма может хранить байты и массивы байтов 

во флеш-памяти, а приложению требуется хранить и читать пары имя/

значение с использованием некоторого механизма хранения . Программное 

обеспечение не должно заботиться о деталях хранения пар имя/значение 

во флеш-памяти, на вращающемся диске, в облаке или в основной памяти . 

Слой аппаратных абстракций (HAL) предоставляет услугу и не раскрыва-

ет программному обеспечению, как она работает . Реализация поддержки 

флеш-памяти — это деталь, которая должна быть скрыта от программного 

обеспечения .

Еще один пример: управление светодиодом привязано к биту GPIO1 . Ми-

кропрограмма может предоставлять доступ к битам GPIO, а слой HAL 

может иметь функцию Led_TurnOn(5) . Это довольно низкоуровневый слой 

аппаратной абстракции . Давайте посмотрим, как повысить уровень абстрак-

ции с точки зрения программного обеспечения/продукта . Какую информа-

цию сообщает светодиод? Допустим, что включение светодиода сообщает 

о низком заряде аккумулятора . На некотором уровне микропрограмма (или 

пакет поддержки платформы) может предоставлять функцию Led_TurnOn(5), 

а слой HAL — функцию Indicate_LowBattery() . Таким способом слой HAL 

выражает назначение услуги для приложения . Кроме того, уровни могут 

содержать подуровни . Это больше напоминает повторяющийся фракталь-

1 General-Purpose Input/Output (интерфейс ввода/вывода общего назначения) . — При-

меч. пер.

Привязка к оборудованию — узкое место      257

ный узор, чем ограниченный набор предопределенных уровней . Назначение 

ввода/выводов GPIO — это детали, которые должны быть скрыты от про-

граммного обеспечения .

Не раскрывайте деталей об оборудовании 

пользователям HAL

Встраиваемое программное обеспечение с чистой архитектурой допускает 

возможность тестирования без целевого оборудования . Удачно спроек-

тированный слой аппаратных абстракций (HAL) предоставляет тот шов, 

или набор, точек подстановки, которые облегчат тестирование без обо-

рудования .

Процессор — это деталь

Когда сборка встраиваемого программного обеспечения производится с при-

менением специализированного набора инструментов, в комплект часто 

входят заголовочные файлы с <i>поддержкой дополнительных конструкций 

</i>1 . Эти компиляторы часто допускают вольное обращение с языком C, 

добавляя новые ключевые слова для доступа к функциям процессора . Код 

выглядит как код на C, но он больше не является кодом на C .

Иногда компиляторы языка C, поставляемые производителем оборудова-

ния, поддерживают нечто, напоминающее глобальные переменные, дающие 

</p>
   </article>
</body>
</html>
