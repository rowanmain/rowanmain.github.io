<!DOCTYPE html>
<html>
<head>
   <title>Моя статья</title>
   <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<style>
body {
   background-color: #f0f0f0;
   font-family: Arial, sans-serif;
}

header {
   background-color: #333;
   color: white;
   padding: 10px;
   text-align: center;
}

h1 {
   margin: 0;
}

article {
   margin: 20px;
}

h2 {
   color: #333;
}

p {
   line-height: 1.6;
}
</style>
<body>
   <header>
       <h1>статья</h1>
   </header>
   <article>
       <p>
ность изменять поведение компьютеров . Поведение компьютеров в некото-

рых пределах можно также изменять посредством аппаратного обеспечения, 

но этот путь намного сложнее .

Для достижения этой цели программное обеспечение должно быть по-

датливым — то есть должна быть возможность легко изменить его . Когда 

заинтересованные стороны меняют свое мнение о некоторой особенности, 

приведение ее в соответствие с пожеланиями заинтересованной стороны 

должно быть простой задачей . Сложность в таких случаях должна быть 

пропорциональна лишь масштабу изменения, но никак не его форме .

Наибольшая ценность      37

Именно эта разница между масштабом и формой часто является причиной 

роста стоимости разработки программного обеспечения . Именно по этой 

причине стоимость растет пропорционально объему требуемых изменений . 

Именно поэтому стоимость разработки в первый год существенно ниже, чем 

во второй, а во второй год ниже, чем в третий .

С точки зрения заинтересованных сторон они просто формируют поток из-

менений примерно одинакового масштаба . С точки зрения разработчиков, 

заинтересованные стороны формируют поток фрагментов, которые они 

должны встраивать в мозаику со все возрастающей сложностью . Каждый 

новый запрос сложнее предыдущего, потому что форма системы не соот-

ветствует форме запроса .

Я использовал здесь слово «форма» не в традиционном его понимании, но, 

как мне кажется, такая метафора вполне уместна . У разработчиков про-

граммного обеспечения часто складывается ощущение, что их заставляют 

затыкать круглые отверстия квадратными пробками .

Проблема, конечно же, кроется в архитектуре системы . Чем чаще архитек-

тура отдает предпочтение какой-то одной форме, тем выше вероятность, 

что встраивание новых особенностей в эту структуру будет даваться все 

сложнее и сложнее . Поэтому архитектуры должны быть максимально не-

зависимыми от формы .

Наибольшая ценность

Функциональность или архитектура? Что более ценно? Что важнее — пра-

вильная работа системы или простота ее изменения?

Если задать этот вопрос руководителю предприятия, он наверняка ответит, 

что важнее правильная работа . Разработчики часто соглашаются с этим мне-

нием . Но оно ошибочно . Я могу доказать ошибочность этого взгляда простым 

логическим инструментом исследования экстремумов .

 

� Если правильно работающая программа не допускает возможности ее 

изменения, она перестанет работать правильно, когда изменятся тре-

бования, и вы не сможете заставить ее работать правильно. То есть 

программа станет бесполезной.

 

� Если программа работает неправильно, но легко поддается изменению, вы 

сможете заставить работать ее правильно и поддерживать ее работо-

способность по мере изменения требований. То есть программа постоянно 

будет оставаться полезной.

38   Глава 2. История о двух ценностях

Эти аргументы могут показаться вам неубедительными . В конце концов, нет 

таких программ, которые нельзя изменить . Однако есть системы, изменить 

которые практически невозможно, потому что стоимость изменений пре-

высит получаемые выгоды . Многие системы достигают такого состояния 

в некоторых своих особенностях или конфигурациях .

Если спросить руководителя, хотел бы он иметь возможность вносить из-

менения, он ответит, что безусловно хотел бы, но тут же может уточнить, что 

работоспособность в данный момент для него важнее гибкости в будущем . 

Однако если руководитель потребует внести изменения, а ваши затраты 

на эти изменения окажутся несоизмеримо высокими, он почти наверняка 

будет негодовать оттого, что вы довели систему до такого состояния, когда 

стоимость изменений превышает разум ные пределы .

Матрица Эйзенхауэра

Рассмотрим матрицу президента Дуайта Дэвида Эйзенхауэра для определе-

ния приоритета между важностью и срочностью (рис . 2 .1) . Об этой матрице 

Эйзенхауэр говорил так:

У меня есть два вида дел, срочные и важные. Срочные дела, как правило, не 

самые важные, а важные — не самые срочные1.

Важные

Срочные

Важные

Не срочные

Не важные

Срочные

Не важные

Не срочные

Рис. 2.1. Матрица Эйзенхауэра

Это старое изречение несет много истины . Срочное действительно редко 

бывает важным, а важное — срочным .

Первая ценность программного обеспечения — поведение — это нечто сроч-

ное, но не всегда важное .

Вторая ценность — архитектура — нечто важное, но не всегда срочное .

1 Из речи, произнесенной в Северо-Западном университете в 1954 году .

Битва за архитектуру      39

Конечно, имеются также задачи важные и срочные одновременно и задачи 

не важные и не срочные . Все эти четыре вида задач можно расставить по 

приоритетам .

1 . Срочные и важные .

2 . Не срочные и важные .

3 . Срочные и не важные .

4 . Не срочные и не важные .

Обратите внимание, что архитектура кода — важная задача — оказывается 

в двух верхних позициях в этом списке, тогда как поведение кода занимает 

первую и третью позиции .

Руководители и разработчики часто допускают ошибку, поднимая пункт 3 до 

уровня пункта 1 . Иными словами, они неправильно отделяют срочные и не 

важные задачи от задач, которые по-настоящему являются срочными и важ-

ными . Эта ошибочность суждений приводит к игнорированию важности архи-

тектуры системы и уделению чрезмерного внимания не важному поведению .

Разработчики программного обеспечения оказываются перед проблемой, 

обусловленной неспособностью руководителей оценить важность архитек-

туры . Но именно для ее решения они и были наняты . Поэтому разработчики 

должны всякий раз подчеркивать приоритет важности архитектуры перед 

срочностью поведения .

Битва за архитектуру

Эта обязанность означает постоянную готовность к битве — возможно, 

в данном случае лучше использовать слово «борьба» . Честно говоря, подоб-

ная ситуация распространена практически повсеместно . Команда разработ-

чиков должна бороться за то, что, по их мнению, лучше для компании, так же 

как команда управленцев, команда маркетинга, команда продаж и команда 

эксплуатации . Это всегда борьба .

Эффективные команды разработчиков часто выходят победителями в этой 

борьбе . Они открыто и на равных вступают в конфликт со всеми другими 

заинтересованными сторонами . Помните: как разработчик программного 

обеспечения вы тоже являетесь заинтересованной стороной . У вас есть 

свой интерес в программном обеспечении, который вы должны защищать . 

Это часть вашей роли и ваших обязанностей . И одна из основных причин, 

почему вас наняли .

40   Глава 2. История о двух ценностях

Важность этой задачи удваивается, если вы выступаете в роли архитектора 

программного обеспечения . Архитекторы, в силу своих профессиональных 

обязанностей, больше сосредоточены на структуре системы, чем на кон-

кретных ее особенностях и функциях . Архитекторы создают архитектуру, 

помогающую быстрее и проще создавать эти особенности и функции, из-

менять их и дополнять .

Просто помните, что если поместить архитектуру на последнее место, раз-

работка системы будет обходиться все дороже, и в конце концов внесение 

изменений в такую систему или в отдельные ее части станет практически 

невозможным . Если это случилось, значит, команда разработчиков сража-

лась недостаточно стойко за то, что они считали необходимым .

II   

Начальные основы: 

парадигмы 

программирования

Архитектура программного обеспечения начинается с кода, поэтому начнем 

обсуждение архитектуры с рассказа о самом первом программном коде .

Основы программирования заложил Алан Тьюринг в 1938 году . Он не 

первый, кто придумал программируемую машину, но он первым понял, что 

программы — это всего лишь данные . К 1945 году Тьюринг уже писал на-

стоящие программы для настоящих компьютеров, используя код, который 

мы смогли бы прочитать (приложив определенные усилия) . В своих про-

граммах он использовал циклы, конструкции ветвления, операторы присва-

ивания, подпрограммы, стеки и другие знакомые нам структуры . Тьюринг 

использовал двоичный язык .

С тех пор в программировании произошло несколько революций . Одна из 

самых известных — революция языков . Во-первых, в конце 1940-х появились 

ассемблеры . Эти «языки» освободили программистов от тяжкого бремени 

трансляции их программ в двоичный код . В 1951 году Грейс Хоппер изобрела 

первый компилятор A0 . Именно она фактически ввела термин компилятор . 

В 1953 году был изобретен язык Fortran (через год после моего рождения) . 

42   Начальные основы: парадигмы программирования

Затем последовал непрерывный поток новых языков программирования: 

COBOL, PL/1, SNOBOL, C, Pascal, C++, Java и так до бесконечности .

Другая, еще более важная, как мне кажется, революция произошла в пара-

дигмах программирования . Парадигма — это способ программирования, не 

зависящий от конкретного языка . Парадигма определяет, какие структуры 

использовать и когда их использовать . До настоящего времени было при-

думано три такие парадигмы . По причинам, которые мы обсудим далее, едва 

ли стоит ожидать каких-то других, новых парадигм .

3 Обзор парадигм

44   Глава 3. Обзор парадигм

В этой главе дается общий обзор следующих трех парадигм: структурное 

программирование, объектно-ориентированное программирование и функ-

циональное программирование .

Структурное программирование

Первой, получившей всеобщее признание (но не первой из придуманных), 

была парадигма структурного программирования, предложенная Эдсгером 

Вибе Дейкстрой в 1968 году . Дейкстра показал, что безудержное использо-

вание переходов (инструкций goto) вредно для структуры программы . Как 

будет описано в последующих главах, он предложил заменить переходы 

более понятными конструкциями if/then/else и do/while/until .

Подводя итог, можно сказать, что:

Структурное программирование накладывает ограничение на прямую пере-

дачу управления.

Объектно-ориентированное 

программирование

Второй парадигмой, получившей широкое распространение, стала пара-

дигма, в действительности появившаяся двумя годами ранее, в 1966-м, 

и предложенная Оле-Йоханом Далем и Кристеном Нюгором . Эти два про-

граммиста заметили, что в языке ALGOL есть возможность переместить 

кадр стека вызова функции в динамическую память (кучу), благодаря чему 

локальные переменные, объявленные внутри функции, могут сохраняться 

после выхода из нее . В результате функция превращалась в конструктор 

класса, локальные переменные — в переменные экземпляра, а вложенные 

функции — в методы . Это привело к открытию полиморфизма через строгое 

использование указателей на функции .

Подводя итог, можно сказать, что:

Объектно-ориентированное программирование накладывает ограничение на 

косвенную передачу управления.

Пища для ума      45

Функциональное программирование

Третьей парадигмой, начавшей распространяться относительно недавно, 

является самая первая из придуманных . Фактически изобретение этой па-

радигмы предшествовало появлению самой идеи программирования . Пара-

дигма функционального программирования является прямым результатом 

работы Алонзо Чёрча, который в 1936 году изобрел лямбда-исчисление (или 

λ-исчисление), исследуя ту же математическую задачу, которая примерно 

в то же время занимала Алана Тьюринга . Его λ-исчисление легло в основу 

языка LISP, изобретенного в 1958 году Джоном Маккарти . Основополагаю-

щим понятием λ-исчисления является неизменяемость — то есть невозмож-

ность изменения значений символов . Фактически это означает, что функ-

циональный язык не имеет инструкции присваивания . В действительности 

большинство функциональных языков обладает некоторыми средствами, 

позволяющими изменять значение переменной, но в очень ограниченных 

случаях .

Подводя итог, можно сказать, что:

Функциональное программирование накладывает ограничение на присваи-

вание.

Пища для ума

Обратите внимание на шаблон, который я преднамеренно ввел в представ-

ление этих трех парадигм программирования: каждая отнимает у програм-

миста какие-то возможности . Ни одна не добавляет новых возможностей . 

Каждая накладывает какие-то дополнительные ограничения, отрицатель-

ные по своей сути . Парадигмы говорят нам не столько что делать, сколько 

чего нельзя делать .

Если взглянуть под другим углом, можно заметить, что каждая парадигма 

что-то отнимает у нас . Три парадигмы вместе отнимают у нас инструкции 

goto, указатели на функции и оператор присваивания . Есть ли у нас еще 

что-то, что можно отнять?

Вероятно, нет . Скорее всего, эти три парадигмы останутся единственными, 

которые мы увидим, — по крайней мере единственными, что-то отнимаю-

46   Глава 3. Обзор парадигм

щими у нас . Доказательством отсутствия новых парадигм может служить 

тот факт, что все три известные парадигмы были открыты в течение десяти 

лет, между 1958 и 1968 годами . За многие последующие десятилетия не по-

явилось ни одной новой парадигмы .

Заключение

Какое отношение к архитектуре имеет эта поучительная история о парадиг-

мах? Самое непосредственное . Мы используем полиморфизм как механизм 

преодоления архитектурных границ, мы используем функциональное про-

граммирование для наложения ограничений на местоположение данных 

и порядок доступа к ним, и мы используем структурное программирование 

как алгоритмическую основу для наших модулей .

Отметьте, как точно вышесказанное соответствует трем главнейшим аспек-

там строительства архитектуры: функциональности, разделению компонен-

тов и управлению данными .

4

Структурное 

программирование

48   Глава 4. Структурное программирование

Эдсгер Вибе Дейкстра родился в Роттердаме в 1930 году . Он пережил бом-

бардировки Роттердама во время Второй мировой войны, оккупацию Ни-

дерландов Германией и в 1948 году окончил среднюю школу с наивысшими 

отметками по математике, физике, химии и биологии . В марте 1952 года, 

в возрасте 21 года (и всего за 9 месяцев до моего рождения), Дейкстра устро-

ился на работу в Математический центр Амстердама и стал самым первым 

программистом в Нидерландах .

В 1955 году, имея трехлетний опыт программирования и все еще будучи 

студентом, Дейкстра пришел к выводу, что интеллектуальные вызовы про-

граммирования намного обширнее интеллектуальных вызовов теоретиче-

ской физики . В результате в качестве своей дальнейшей стези он выбрал 

программирование . В 1957 году Дейкстра женился на Марии Дебетс . В то 

время в Нидерландах требовали от вступающих в брак указывать профес-

сию . Голландские власти не пожелали принять от Дейкстры документы 

с указанной профессией «программист»; они никогда не слышали о такой 

профессии . Поэтому ему пришлось переписать документы и указать про-

фессию «физик-теоретик» .

Решение выбрать карьеру программиста Дейкстра обсудил со своим руко-

водителем, Адрианом ван Вейнгаарденом . Дейкстру волновало, что про-

граммирование в то время не признавалось ни профессией, ни наукой и что 

по этой причине его никто не будет воспринимать всерьез . Адриан ответил, 

что Дейкстра вполне может стать одним из основателей профессии и пре-

вратить программирование в науку .

Свою карьеру Дейкстра начинал в эпоху ламповой электроники, когда ком-

пьютеры были огромными, хрупкими, медленными, ненадежными и чрез-

вычайно ограниченными (по современным меркам) . В те годы программы 

записывались двоичным кодом или на примитивном языке ассемблера . 

Ввод программ в компьютеры осуществлялся с использованием перфолент 

или перфокарт . Цикл правка—компиляция—тестирование занимал часы, 

а порой и дни .

В такой примитивной среде Дейкстра сделал свои величайшие открытия .

Доказательство

С самого начала Дейкстра заметил, что программирование — сложная ра-

бота и что программисты справляются с ней не очень успешно . Программа 

любой сложности содержит слишком много деталей, чтобы человеческий 

мозг смог справиться с ней без посторонней помощи . Стоит упустить из 

Доказательство      49

виду одну маленькую деталь, и программа, которая кажется работающей, 

может завершаться с ошибкой в самых неожиданных местах .

В качестве решения Дейкстра предложил применять математический ап-

парат доказательств . Оно заключалось в построении евклидовой иерархии 

постулатов, теорем, следствий и лемм . Дейкстра полагал, что программисты 

смогут использовать эту иерархию подобно математикам . Иными словами, 

программисты должны использовать проверенные структуры и связывать 

их с кодом, в правильности которого они хотели бы убедиться .

Дейкстра понимал, что для этого он должен продемонстрировать методику 

написания доказательств на простых алгоритмах . Но эта задача оказалась 

довольно сложной .

В ходе исследований Дейкстра обнаружил, что в некоторых случаях ис-

пользование инструкции goto мешает рекурсивному разложению модулей 

на все меньшие и меньшие единицы и тем самым препятствует применению 

принципа «разделяй и властвуй», что является необходимым условием для 

обоснованных доказательств .

Однако в других случаях инструкция goto не вызывала этой проблемы . 

Дейкстра заметил, что эти случаи «доброкачественного» использования 

goto соответствуют простым структурам выбора и управления итерациями, 

таким как if/then/else и do/while . Модули, использующие только такие 

управляющие структуры, можно было рекурсивно разложить на доказуемые 

единицы .

Дейкстра знал, что эти управляющие структуры в сочетании с последова-

тельным выполнением занимают особое положение . Они были идентифи-

цированы за два года до этого Бёмом и Якопини, доказавшими, что любую 

программу можно написать, используя всего три структуры: последователь-

ность, выбор и итерации .

Это было важное открытие: управляющие структуры, делающие доказуемой 

правильность модуля, в точности совпадали с набором структур, минималь-

но необходимым для написания любой программы . Так родилось структур-

ное программирование .

Дейкстра показал, что доказать правильность последовательности инструк-

ций можно простым перечислением . Методика заключалась в прослежива-

нии последовательности математическим способом от входа до выхода . Она 

ничем не отличалась от обычного математического доказательства .

Правильность конструкций выбора Дейкстра доказывал через повторяюще-

еся применение приема перечисления, когда прослеживанию подвергался 

50   Глава 4. Структурное программирование

каждый путь . Если оба пути в конечном итоге давали соответствующие 

математические результаты, их правильность считалась доказанной .

Итерации — несколько иной случай . Чтобы доказать правильность ите-

рации, Дейкстре пришлось использовать индукцию . Он доказал методом 

перечисления правильность случая с единственной итерацией . Затем, опять 

же методом перечисления, доказал, что если случай для N итераций пра-

вильный, значит, правильным будет случай для N + 1 итераций . Используя 

тот же метод перечисления, он доказал правильность критериев начала 

и окончания итераций .

Такие доказательства были сложными и трудоемкими, но они были дока-

зательствами . С их развитием идея создания евклидовой иерархии теорем 

выглядела достижимой в реальности .

Объявление вредным

В 1968 году Дейкстра написал редактору журнала CACM письмо под за-

головком Go To Statement Considered Harmful («О вреде оператора Go To»)1, 

которое было опубликовано в мартовском выпуске . В статье он обосновал 

свою позицию в отношении трех управляющих структур2 .

И мир программирования запылал . Тогда у нас не было Интернета, поэтому 

люди не могли публиковать злобные мемы на Дейкстру и затопить его не-

дружественными сообщениями . Но они могли писать — и писали — письма 

редакторам многих популярных журналов .

Не все письма были корректными . Некоторые из них были резко отрица-

тельными; другие выражали решительную поддержку . И эта битва продол-

жалась почти десять лет .

В конце концов спор утих по одной простой причине: Дейкстра победил . 

По мере развития языков программирования инструкция goto все больше 

сдавала свои позиции, пока, наконец, не исчезла . Большинство современных 

языков программирования не имеют инструкции goto, а некоторые, такие 

как LISP, никогда ее не имели .

1 На самом деле Дейкстра озаглавил свое письмо A Case Against the Goto Statement («Дело 

против оператора goto»), но редактор CACM Никлаус Вирт изменил заголовок . — При-

меч. пер.

2 Перевод статьи на русский язык можно найти по адресу http://hosting.vspu.ac.ru/~chul/

dijkstra/goto/goto.htm . — Примеч. пер.

Формальные доказательства отсутствуют      51

В настоящее время все программисты используют парадигму структурного 

программирования, хотя и не всегда осознанно . Просто современные языки 

не дают возможности неограниченной прямой передачи управления .

Некоторые отмечают сходство инструкции break с меткой и исключений 

в Java с инструкцией goto . В действительности эти структуры не являются 

средствами неограниченной прямой передачи управления, имевшимися 

в старых языках, таких как Fortran или COBOL . Кроме того, даже языки, 

сохранившие ключевое слово goto, часто ограничивают возможность пере-

ходов границами текущей функции .

Функциональная декомпозиция

Структурное программирование дает возможность рекурсивного разло-

жения модулей на доказуемые единицы, что, в свою очередь, означает воз-

можность функциональной декомпозиции . То есть решение большой задачи 

можно разложить на ряд функций верхнего уровня . Каждую из этих функ-

ций в свою очередь можно разложить на ряд функций более низкого уров-

ня, и так до бесконечности . Кроме того, каждую из таких функций можно 

представить с применением ограниченного набора управляющих структур, 

предлагаемых парадигмой структурного программирования .

Опираясь на этот фундамент, в конце 1970-х годов и на протяжении 

1980-х годов приобрели популярность такие дисциплины, как структурный 

анализ и структурное проектирование . В тот период многие, например Эд 

Йордан, Ларри Константин, Том Демарко и Меилир Пейдж-Джонс, продви-

гали и популяризовали эти дисциплины . Следуя им, программисты могли 

разбивать большие системы на модули и компоненты, которые затем можно 

было разбить на маленькие и доказуемые функции .

Формальные доказательства отсутствуют

Но доказательства так и не появились . Евклидова иерархия теорем не 

была построена . И программисты не увидели преимуществ использования 

трудоемкого процесса формального доказательства правильности каждой, 

даже самой маленькой функции . В конечном итоге мечта Дейкстры рас-

сеялась как дым . Не многие из современных программистов считают, что 

формальные доказательства являются подходящим способом производства 

высококачественного программного обеспечения .

52   Глава 4. Структурное программирование

Конечно, формальный евклидов стиль математических доказательств не 

единственная стратегия создания чего-то правильного . Другой, более успеш-

ной стратегией является научный метод .

Наука во спасение

Принципиальное отличие науки от математики заключается в том, что пра-

вильность научных теорий и законов нельзя доказать . Я не смогу доказать 

верность второго закона движения Ньютона, F = ma, или закона гравитации, 

F = Gm1m2/r2 . Я могу продемонстрировать действие этих законов и прове-

сти измерения, подтверждающие их правильность до многих знаков после 

запятой, но я не смогу доказать их в математическом смысле . Я могу про-

вести массу экспериментов и собрать массу эмпирических подтверждений, 

но всегда остается вероятность, что какой-то эксперимент покажет, что эти 

законы движения и гравитации неверны .

Такова природа научных теорий и законов: их можно сфальсифицировать, 

но нельзя доказать .

Тем не менее мы верим в эти законы . Каждый раз, садясь в автомобиль, мы 

ставим свою жизнь на то, что формула F = ma точно описывает окружающий 

мир . Каждый раз, делая шаг, мы ставим свои здоровье и безопасность на 

верность формулы F = Gm1m2/r2 .

Наука не требует доказательства истинности утверждений, чаще она требует 

доказательства их ложности . Утверждения, доказать ложность которых не 

удается после многих усилий, мы считаем истинными .

Конечно, не все утверждения требуют доказательств . Например, утвержде-

ние «это — ложь» не является ни истинным, ни ложным . Это один из про-

стейших примеров утверждений, не требующих доказательств .

Подводя итог, можно сказать, что математика — это дисциплина доказа-

тельства истинности утверждений, требующих доказательства . Наука, на-

против, — дисциплина доказательства ложности утверждений, требующих 

доказательства .

Тестирование

Однажды Дейкстра сказал: «Тестирование показывает присутствие ошибок, 

а не их отсутствие» . Иными словами, тестированием можно доказать не-

правильность программы, но нельзя доказать ее правильность . Все, что дает 

Заключение      53

тестирование после приложения достаточных усилий, — это уверенность, 

что программа действует достаточно правильно .

Следствия из этого факта могут показаться ошеломляющими . Разработка 

программного обеспечения не является математической задачей, даже при 

том, что она связана с применением математических конструкций . Эта сфера 

деятельности больше похожа на науку . Мы убеждаемся в правильности, по-

терпев неудачу в попытке доказать неправильность .

Такие доказательства неправильности можно применить только к доказуе-

мым программам . Недоказуемую программу — например, из-за неумерен-

ного использования goto — нельзя считать правильной, сколько бы тестов 

к ней ни применялось .

Парадигма структурного программирования заставляет нас рекурсивно 

разбивать программы на множество мелких и доказуемых функций . В ре-

зультате мы получаем возможность использовать тесты, чтобы попытаться 

доказать их неправильность . Если такие тесты терпят неудачу, тогда мы 

считаем функции достаточно правильными .

Заключение

Именно эта возможность создавать программные единицы, неправильность 

которых можно доказать, является главной ценностью структурного про-

граммирования . Именно поэтому современные языки обычно не поддер-

живают неограниченное применение инструкций goto . Кроме того, именно 

поэтому функциональная декомпозиция считается одним из лучших приемов 

на архитектурном уровне .

На всех уровнях, от маленьких функций до больших компонентов, раз-

работка программного обеспечения напоминает науку, и поэтому в ней 

применяется правило опровергающих доказательств . Программные архи-

текторы стремятся определить модули, компоненты и службы, неправиль-

ность которых легко можно было бы доказать (протестировать) . Для этого 

они используют ограничения, напоминающие ограничения в структурном 

программировании, хотя и более высокого уровня .

Именно эти ограничения мы будем подробно изучать в последующих главах .

5

Объектно- 

ориентированное  

программирование

Инкапсуляция?      55

Как мы увидим далее, для создания хорошей архитектуры необходимо 

понимать и уметь применять принципы объектно-ориентированного про-

граммирования (ОО) . Но что такое ОО?

Один из возможных ответов на этот вопрос: «комбинация данных и функ-

ций» . Однако, несмотря на частое цитирование, этот ответ нельзя признать 

точным, потому что он предполагает, что o.f() — это нечто отличное от f(o) . 

Это абсурд . Программисты передавали структуры в функции задолго до 

1966 года, когда Даль и Нюгор перенесли кадр стека функции в динамиче-

скую память и изобрели ОО .

Другой распространенный ответ: «способ моделирования реального мира» . 

Это слишком уклончивый ответ . Что в действительности означает «модели-

рование реального мира» и почему нам может понадобиться такое модели-

рование? Возможно, эта фраза подразумевает, что ОО делает программное 

обеспечение проще для понимания, потому что оно становится ближе к ре-

альному миру, но и такое объяснение слишком размыто и уклончиво . Оно 

не отвечает на вопрос, что же такое ОО .

Некоторые, чтобы объяснить природу ОО, прибегают к трем волшебным 

словам: инкапсуляция, наследование и полиморфизм . Они подразумевают, 

что ОО является комплексом из этих трех понятий или, по крайней мере, 

что объектно-ориентированный язык должен их поддерживать .

Давайте исследуем эти понятия по очереди .

Инкапсуляция?

Инкапсуляция упоминается как часть определения ОО потому, что языки 

ОО поддерживают простой и эффективный способ инкапсуляции данных 

и функций . Как результат, есть возможность очертить круг связанных 

данных и функций . За пределами круга эти данные невидимы и доступны 

только некоторые функции . Воплощение этого понятия можно наблюдать 

в виде приватных членов данных и общедоступных членов-функций класса .

Эта идея определенно не уникальная для ОО . Например, в языке C имеется 

превосходная поддержка инкапсуляции . Рассмотрим простую программу 

на C:

point .h 

struct Point;

struct Point* makePoint(double x, double y);

double distance (struct Point *p1, struct Point *p2);

56   Глава 5. Объектно-ориентированное программирование  

point .c

#include "point.h"

#include <stdlib.h>

#include <math.h>

struct Point {

  double x,y;

};

struct Point* makepoint(double x, double y) {

  struct Point* p = malloc(sizeof(struct Point));

  p->x = x;

  p->y = y;

  return p;

}

double distance(struct Point* p1, struct Point* p2) {

  double dx = p1->x - p2->x;

  double dy = p1->y - p2->y;

  return sqrt(dx*dx+dy*dy);

}

Пользователи point.h не имеют доступа к членам структуры Point . Они 

могут вызывать функции makePoint() и distance(), но не имеют никакого 

представления о реализации структуры Point и функций для работы с ней .

Это отличный пример поддержки инкапсуляции не в объектно-ориенти-

рованном языке . Программисты на C постоянно использовали подобные 

приемы . Мы можем объявить структуры данных и функции в заголовочных 

файлах и реализовать их в файлах реализации . И наши пользователи никог-

да не получат доступа к элементам в этих файлах реализации .

Но затем пришел объектно-ориентированный C++ и превосходная инкап-

суляция в C оказалась разрушенной .

По техническим причинам1 компилятор C++ требует определять перемен-

ные-члены класса в заголовочном файле . В результате объектно-ориентиро-

ванная версия предыдущей программы Point приобретает такой вид:

point .h

class Point {

public:

  Point(double x, double y);

  double distance(const Point& p) const;

1 Чтобы иметь возможность определить размер экземпляра каждого класса .

Инкапсуляция?      57

private:

  double x;

  double y;

};

point .cc

#include "point.h"

#include <math.h>

Point::Point(double x, double y)

: x(x), y(y)

{}

double Point::distance(const Point& p) const {

  double dx = x-p.x;

  double dy = y-p.y;

  return sqrt(dx*dx + dy*dy);

}

Теперь пользователи заголовочного файла point.h знают о переменных-

членах x и y! Компилятор не позволит обратиться к ним непосредственно, 

но клиент все равно знает об их существовании . Например, если имена этих 

членов изменятся, файл point.cc придется скомпилировать заново! Инкап-

суляция оказалась разрушенной .

Введением в язык ключевых слов public, private и protected инкапсуляция 

была частично восстановлена . Однако это был лишь грубый прием (хак), 

обусловленный технической необходимостью компилятора видеть все пере-

менные-члены в заголовочном файле .

Языки Java и C# полностью отменили деление на заголовок/реализацию, 

ослабив инкапсуляцию еще больше . В этих языках невозможно разделить 

объявление и определение класса .

По описанным причинам трудно согласиться, что ОО зависит от строгой 

инкапсуляции . В действительности многие языки ОО практически не имеют 

принудительной инкапсуляции1 .

ОО безусловно полагается на поведение программистов — что они не станут 

использовать обходные приемы для работы с инкапсулированными дан-

ными . То есть языки, заявляющие о поддержке OO, фактически ослабили 

превосходную инкапсуляцию, некогда существовавшую в C .

1 Например, Smalltalk, Python, JavaScript, Lua и Ruby .

58   Глава 5. Объектно-ориентированное программирование  

Наследование?

Языки ОО не улучшили инкапсуляцию, зато они дали нам наследование .

Точнее — ее разновидность . По сути, наследование — это всего лишь по-

вторное объявление группы переменных и функций в ограниченной области 

видимости . Нечто похожее программисты на C проделывали вручную за-

долго до появления языков ОО1 .

Взгляните на дополнение к нашей исходной программе point.h на языке C:

namedPoint .h

struct NamedPoint;

struct NamedPoint* makeNamedPoint(double x, double y, char* name);

void setName(struct NamedPoint* np, char* name);

char* getName(struct NamedPoint* np);

namedPoint .c

#include "namedPoint.h"

#include <stdlib.h>

struct NamedPoint {

  double x,y;

  char* name;

};

struct NamedPoint* makeNamedPoint(double x, double y, char* name) {

  struct NamedPoint* p = malloc(sizeof(struct NamedPoint));

  p->x = x;

  p->y = y;

  p->name = name;

  return p;

}

void setName(struct NamedPoint* np, char* name) {

  np->name = name;

}

char* getName(struct NamedPoint* np) {

  return np->name;

}

1 И не только программисты на C: большинство языков той эпохи позволяли маскиро-

вать одни структуры данных под другие .

Наследование?      59

main .c

#include "point.h"

#include "namedPoint.h"

#include <stdio.h>

int main(int ac, char** av) {

  struct NamedPoint* origin = makeNamedPoint(0.0, 0.0, "origin");

  struct NamedPoint* upperRight = makeNamedPoint

    (1.0, 1.0, "upperRight");

  printf("distance=%f\n",

    distance(

      (struct Point*) origin,

      (struct Point*) upperRight));

}

Внимательно рассмотрев основной код в файле main.c, можно заметить, что 

структура данных NamedPoint используется, как если бы она была производ-

ной от структуры Point . Такое оказалось возможным потому, что первые два 

поля в NamedPoint совпадают с полями в Point . Проще говоря, NamedPoint 

может маскироваться под Point, потому что NamedPoint фактически являет-

ся надмножеством Point и имеет члены, соответствующие структуре Point, 

следующие в том же порядке .

Этот прием широко применялся1 программистами до появления ОО . Фак-

тически именно так C++ реализует единственное наследование .

То есть можно сказать, что некоторая разновидность наследования у нас 

имелась задолго до появления языков ОО . Впрочем, это утверждение не 

совсем истинно . У нас имелся трюк, хитрость, не настолько удобный, как 

настоящее наследование . Кроме того, с помощью описанного приема очень 

сложно получить что-то похожее на множественное наследование .

Обратите также внимание, как в main.c мне пришлось приводить аргументы 

NamedPoint к типу Point . В настоящем языке ОО такое приведение к роди-

тельскому типу производится неявно .

Справедливости ради следует отметить, что языки ОО действительно 

сделали маскировку структур данных более удобной, хотя это и не совсем 

новая особенность .

Итак, мы не можем дать идее ОО ни одного очка за инкапсуляцию и можем 

дать лишь пол-очка за наследование . Пока что общий счет не впечатляет .

Но у нас есть еще одно понятие .

1 И продолжает применяться .

60   Глава 5. Объектно-ориентированное программирование  

Полиморфизм?

Была ли возможность реализовать полиморфное поведение до появления 

языков ОО? Конечно! Взгляните на следующую простую программу copy 

на языке C.

#include <stdio.h>

void copy() {

  int c;

  while ((c=getchar()) != EOF)

    putchar(c);

}

Функция getchar() читает символ из STDIN. Но какое устройство в действи-

тельности скрыто за ширмой STDIN? Функция putchar() записывает символ 

в STDOUT. Но что это за устройство? Эти функции являются полиморфными — 

их поведение зависит от типов устройств, назначенных на STDIN и STDOUT.

В некотором смысле STDIN и STDOUT похожи на интерфейсы в стиле Java, 

когда для каждого устройства имеется своя реализация этих интерфейсов. 

Конечно, в примере программы на C нет никаких интерфейсов, но как тог-

да вызов getchar() передается драйверу устройства, который фактически 

читает символ?

Ответ на этот вопрос прост: операционная система UNIX требует, чтобы 

каждый драйвер устройства ввода/вывода реализовал пять стандартных 

функций1: open, close, read, write и seek. Сигнатуры этих функций должны 

совпадать для всех драйверов.

Структура FILE имеет пять указателей на функции. В нашем случае она 

могла бы выглядеть как-то так:

struct FILE {

  void (*open)(char* name, int mode);

  void (*close)();

  int (*read)();

  void (*write)(char);

  void (*seek)(long index, int mode);

};

Драйвер консоли определяет эти функции и инициализирует указатели на 

них в структуре FILE примерно так:

1 В разных версиях UNIX требования разные; это всего лишь пример.

Полиморфизм?      61

#include "file.h"

void open(char* name, int mode) {/*...*/}

void close() {/*...*/};

int read() {int c;/*...*/ return c;}

void write(char c) {/*...*/}

void seek(long index, int mode) {/*...*/}

struct FILE console = {open, close, read, write, seek};

Если теперь предположить, что символ STDIN определен как указатель FILE* 

и ссылается на структуру console, тогда getchar() можно реализовать как-то 

так:

extern struct FILE* STDIN;

int getchar() {

  return STDIN->read();

}

Иными словами, getchar() просто вызывает функцию, на которую ссыла-

ется указатель read в структуре FILE, на которую, в свою очередь, ссылается 

STDIN .

Этот простой трюк составляет основу полиморфизма в ОО . В C++, на-

пример, каждая виртуальная функция в классе представлена указателем 

в таблице виртуальных методов vtable и все вызовы виртуальных функций 

выполняются через эту таблицу . Конструкторы производных классов про-

сто инициализируют таблицу vtable объекта указателями на свои версии 

функций .

Суть полиморфизма заключается в применении указателей на функции . 

Программисты использовали указатели на функции для достижения поли-

морфного поведения еще со времен появления архитектуры фон Неймана 

в конце 1940-х годов . Иными словами, парадигма ОО не принесла ничего 

нового .

Впрочем, это не совсем верно . Пусть полиморфизм появился раньше языков 

ОО, но они сделали его намного надежнее и удобнее .

Проблема явного использования указателей на функции для создания по-

лиморфного поведения в том, что указатели на функции по своей природе 

опасны . Такое их применение оговаривается множеством соглашений . Вы 

должны помнить об этих соглашениях и инициализировать указатели . Вы 

должны помнить об этих соглашениях и вызывать функции посредством 

62   Глава 5. Объектно-ориентированное программирование  

указателей . Если какой-то программист забудет о соглашениях, возникшую 

в результате ошибку будет чертовски трудно отыскать и устранить .

Языки ОО избавляют от необходимости помнить об этих соглашениях и, со-

ответственно, устраняют опасности, связанные с этим . Поддержка полимор-

физма на уровне языка делает его использование тривиально простым . Это 

обстоятельство открывает новые возможности, о которых программисты 

на C могли только мечтать . Отсюда можно заключить, что ОО накладывает 

ограничение на косвенную передачу управления .

Сильные стороны полиморфизма

Какими положительными чертами обладает полиморфизм? Чтобы в пол-

ной мере оценить их, рассмотрим пример программы copy . Что случится 

с программой, если создать новое устройство ввода/вывода? Допустим, 

мы решили использовать программу copy для копирования данных из 

устройства распознавания рукописного текста в устройство синтеза речи: 

что нужно изменить в программе copy, чтобы она смогла работать с новыми 

устройствами?

Самое интересное, что никаких изменений не требуется! В действитель-

ности нам не придется даже перекомпилировать программу copy . Почему? 

Потому что исходный код программы copy не зависит от исходного кода 

драйверов ввода/вывода . Пока драйверы реализуют пять стандартных 

функций, определяемых структурой FILE, программа copy сможет с успехом 

их использовать .

Проще говоря, устройства ввода/вывода превратились в плагины для про-

граммы copy .

Почему операционная система UNIX превратила устройства ввода/выво-

да в плагины? Потому что в конце 1950-х годов мы поняли, что наши про-

граммы не должны зависеть от конкретных устройств . Почему? Потому что 

мы успели написать массу программ, зависящих от устройств, прежде чем 

смогли понять, что в действительности мы хотели бы, чтобы эти программы, 

выполняя свою работу, могли бы использовать разные устройства .

Например, раньше часто писались программы, читавшие исходные данные 

из пакета перфокарт1 и пробивавшие на перфораторе новую стопку пер-

1 Перфокарты IBM Hollerith имели ширину 80 колонок . Я уверен, что многие из вас 

никогда даже не видели их, но они широко были распространены в 1950-е, 1960-е 

и даже в 1970-е годы .

Полиморфизм?      63

фокарт с результатами . Позднее наши клиенты стали передавать исходные 

данные не на перфокартах, а на магнитных лентах . Это было неудобно, по-

тому что приходилось переписывать большие фрагменты первоначальных 

программ . Было бы намного удобнее, если бы та же программа могла рабо-

тать и с перфокартами, и с магнитной лентой .

Для поддержки независимости от устройств ввода/вывода была придумана 

архитектура плагинов и реализована практически во всех операционных 

системах . Но даже после этого большинство программистов не давали рас-

пространения этой идее в своих программах, потому что использование 

указателей на функции было опасно .

Объектно-ориентированная парадигма позволила использовать архитектуру 

плагинов повсеместно .

Инверсия зависимости

Представьте, на что походило программное обеспечение до появления на-

дежного и удобного механизма полиморфизма . В типичном дереве вызовов 

главная функция вызывала функции верхнего уровня, которые вызывали 

функции среднего уровня, в свою очередь, вызывавшие функции нижнего 

уровня . Однако в таком дереве вызовов зависимости исходного кода непре-

клонно следовали за потоком управления (рис . 5 .1) .

Главная

Зависимости

исходного кода

Поток

управления

Рис. 5.1. Зависимости исходного кода следуют за потоком управления

Чтобы вызвать одну из функций верхнего уровня, функция main должна 

сослаться на модуль, содержащий эту функцию . В языке C для этой цели 

64   Глава 5. Объектно-ориентированное программирование  

используется директива #include . В Java — инструкция import . В C# — ин-

струкция using . В действительности любой вызывающий код был вынужден 

ссылаться на модуль, содержащий вызываемый код .

Эти требования предоставляли архитектору программного обеспечения не-

сколько вариантов . Поток управления определяется поведением системы, 

а зависимости исходного кода определяются этим потоком управления .

Однако когда в игру включился полиморфизм, стало возможным нечто со-

вершенно иное (рис . 5 .2) .

Рис. 5.2. Инверсия зависимости

На рис . 5 .2 модуль верхнего уровня HL1 вызывает функцию F() из модуля 

среднего уровня ML1 . Вызов посредством интерфейса является уловкой лишь 

для исходного кода . Во время выполнения интерфейсов не существует . 

 Модуль HL1 просто вызывает F() внутри ML11 .

Но обратите внимание, что направление зависимости в исходном коде (от-

ношение наследования) между ML1 и интерфейсом I поменялось на противо-

положное по отношению к потоку управления . Этот эффект называют 

инверсией зависимости (dependency inversion), и он имеет далеко идущие 

последствия для архитекторов программного обеспечения .

Факт поддержки языками ОО надежного и удобного механизма полимор-

физма означает, что любую зависимость исходного кода, где бы она ни на-

ходилась, можно инвертировать .

Теперь вернемся к дереву вызовов, изображенному на рис . 5 .1, и к множеству 

зависимостей в его исходном коде . Любую из зависимостей в этом исходном 

коде можно обратить, добавив интерфейс .

1 Хотя и косвенно .

Полиморфизм?      65

При таком подходе архитекторы, работающие в системах, которые написа-

ны на объектно-ориентированных языках, получают абсолютный контроль 

над направлением всех зависимостей в исходном коде . Они не ограничены 

только направлением потока управления . Неважно, какой модуль вызыва-

ет и какой модуль вызывается, архитектор может определить зависимость 

в исходном коде в любом направлении .

Какая возможность! И эту возможность открывает ОО . Собственно, это все, 

что дает ОО, — по крайней мере с точки зрения архитектора .

Что можно сделать, обладая этой возможностью? Можно, например, пере-

упорядочить зависимости в исходном коде так, что база данных и пользова-

тельский интерфейс (ПИ) в вашей системе будут зависеть от бизнес-правил 

(рис . 5 .3), а не наоборот .

ПИ

Рис. 5.3. База данных и пользовательский интерфейс зависят от бизнес-правил

Это означает, что ПИ и база данных могут быть плагинами к бизнес-прави-

лам . То есть в исходном коде с реализацией бизнес-правил могут отсутство-

вать любые ссылки на ПИ или базу данных .

Как следствие, бизнес-правила, ПИ и базу данных можно скомпилировать 

в три разных компонента или единицы развертывания (например, jar-

файлы, библиотеки DLL или файлы Gem), имеющих те же зависимости, 

как в исходном коде . Компонент с бизнес-правилами не будет зависеть от 

компонентов, реализующих ПИ и базу данных .

Как результат, появляется возможность развертывать бизнес-правила неза-

висимо от ПИ и базы данных . Изменения в ПИ или в базе данных не должны 

оказывать никакого влияния на бизнес-правила . То есть компоненты можно 

развертывать отдельно и независимо .

Проще говоря, когда реализация компонента изменится, достаточно повтор-

но развернуть только этот компонент . Это независимость развертывания .

Если система состоит из модулей, которые можно развертывать независимо, 

их можно разрабатывать независимо, разными командами . Это независи-

мость разработки .

66   Глава 5. Объектно-ориентированное программирование  

Заключение

Что такое ОО? Существует много взглядов и ответов на этот вопрос . Од-

нако для программного архитектора ответ очевиден: ОО дает, посредством 

поддержки полиморфизма, абсолютный контроль над всеми зависимостя-

ми в исходном коде . Это позволяет архитектору создать архитектуру со 

сменными модулями (плагинами), в которой модули верхнего уровня не 

зависят от модулей нижнего уровня . Низкоуровневые детали не выходят 

за рамки модулей плагинов, которые можно развертывать и разрабатывать 

независимо от модулей верхнего уровня .

6

Функциональное 

программирование

68   Глава 6. Функциональное программирование

Многие идеи функционального программирования появились задолго 

до появления самого программирования . Эта парадигма в значитель-

ной мере основана на λ-исчислении, изобретенном Алонзо Чёрчем 

в 1930-х годах .

Квадраты целых чисел

Суть функционального программирования проще объяснить на примерах . 

С этой целью исследуем решение простой задачи: вывод квадратов первых 

25 целых чисел (то есть от 0 до 24) .

В языках, подобных Java, эту задачу можно решить так:

public class Squint {

  public static void main(String args[]) {

    for (int i=0; i<25; i++)

      System.out.println(i*i);

  }

}

В Clojure, функциональном языке и производном от языка Lisp, аналогич-

ную программу можно записать так:

(println (take 25 (map (fn [x] (* x x)) (range))))

Этот код может показаться немного странным, если вы не знакомы с Lisp . 

Поэтому я, с вашего позволения, немного переоформлю его и добавлю не-

сколько комментариев .

(println ;___________________ Вывести

  (take 25 ;_________________ первые 25

    (map (fn [x] (* x x)) ;__ квадратов

      (range)))) ;___________ целых чисел

Совершенно понятно, что println, take, map и range — это функции . В языке 

Lisp вызов функции производится помещением ее имени в круглые скобки . 

Например, (range) — это вызов функции range .

Выражение (fn [x] (* x x)) — это анонимная функция, которая, в свою 

очередь, вызывает функцию умножения и передает ей две копии входного 

аргумента . Иными словами, она вычисляет квадрат заданного числа .

Взглянем на эту программу еще раз, начав с самого внутреннего вызова 

функции:

Неизменяемость и архитектура      69

 

� функция range возвращает бесконечный список целых чисел, начи-

ная с 0;

 

� этот список передается функции map, которая вызывает анонимную 

функцию для вычисления квадрата каждого элемента и производит бес-

конечный список квадратов;

 

� список квадратов передается функции take, которая возвращает новый 

список, содержащий только первые 25 элементов;

 

� функция println выводит этот самый список квадратов первых 25 целых 

чисел .

Если вас напугало упоминание бесконечных списков, не волнуйтесь . В дей-

ствительности программа создаст только первые 25 элементов этих беско-

нечных списков . Дело в том, что новые элементы бесконечных списков не 

создаются, пока программа не обратится к ним .

Если все вышесказанное показалось вам запутанным и непонятным, тогда 

можете отложить эту книгу и прекрасно провести время, изучая функцио-

нальное программирование и язык Clojure . В этой книге я не буду рассма-

тривать эти темы, так как не это является моей целью .

Моя цель — показать важнейшее отличие между программами на Clojure 

и Java . В программе на Java используется изменяемая переменная — пере-

менная, состояние которой изменяется в ходе выполнения программы . Это 

переменная i — переменная цикла . В программе на Clojure, напротив, нет 

изменяемых переменных . В ней присутствуют инициализируемые пере-

менные, такие как x, но они никогда не изменяются .

В результате мы пришли к удивительному утверждению: переменные 

в функциональных языках не изменяются .

Неизменяемость и архитектура

Почему этот аспект важен с архитектурной точки зрения? Почему архитек-

тора должна волновать изменчивость переменных? Ответ на этот вопрос до 

нелепого прост: все состояния гонки (race condition), взаимоблокировки 

(deadlocks) и проблемы параллельного обновления обусловлены изменя-

емостью переменных . Если в программе нет изменяемых переменных, она 

никогда не окажется в состоянии гонки и никогда не столкнется с пробле-

мами одновременного изменения . В отсутствие изменяемых блокировок 

программа не может попасть в состояние взаимоблокировки .

70   Глава 6. Функциональное программирование

Иными словами, все проблемы, характерные для приложений с конкури-

рующими вычислениями, — с которыми нам приходится сталкиваться, 

когда требуется организовать многопоточное выполнение и задействовать 

вычислительную мощность нескольких процессоров, исчезают сами собой 

в отсутствие изменяемых переменных .

Вы, как архитектор, обязаны интересоваться проблемами конкуренции . Вы 

должны гарантировать надежность и устойчивость проектируемых вами си-

стем в многопоточном и многопроцессорном окружении . И один из главных 

вопросов, которые вы должны задать себе: достижима ли неизменяемость 

на практике?

Ответ на этот вопрос таков: да, если у вас есть неограниченный объем па-

мяти и процессор с неограниченной скоростью вычислений . В отсутствие 

этих бесконечных ресурсов ответ выглядит не так однозначно . Да, неизме-

няемость достижима, но при определенных компромиссах .

Рассмотрим некоторые из этих компромиссов .

Ограничение изменяемости

Один из самых общих компромиссов, на которые приходится идти ради 

неизменяемости, — деление приложения или служб внутри приложения 

на изменяемые и неизменяемые компоненты . Неизменяемые компоненты 

решают свои задачи исключительно функциональным способом, без ис-

пользования изменяемых переменных . Они взаимодействуют с другими 

компонентами, не являющимися чисто функциональными и допускающими 

изменение состояний переменных (рис . 6 .1) .

Изменяемое состояние этих других компонентов открыто всем проблемам 

многопоточного выполнения, поэтому для защиты изменяемых переменных 

от конкурирующих обновлений и состояния гонки часто используется не-

которая разновидность транзакционной памяти .

Транзакционная память интерпретирует переменные в оперативной памяти 

подобно тому, как база данных интерпретирует записи на диске . Она защи-

щает переменные, применяя механизм транзакций с повторениями .

Простым примером могут служить атомы в Clojure:

(def counter (atom 0)) ; инициализировать счетчик нулем

(swap! counter inc)    ; безопасно увеличить счетчик counter.

Ограничение изменяемости      71

Рис. 6.1. Изменяемое состояние и транзакционная память

В этом фрагменте переменная counter определяется как атом (с помощью 

функции atom) . Атом в языке Clojure — это особая переменная, способная 

изменяться при очень ограниченных условиях, соблюдение которых гаран-

тирует функция swap! .

Функция swap!, показанная в предыдущем фрагменте, принимает два ар-

гумента: атом, подлежащий изменению, и функцию, вычисляющую новое 

значение для сохранения в атоме . В данном примере атом counter получит 

значение, вычисленное функцией inc, которая просто увеличивает свой 

аргумент на единицу .

Функция swap! реализует традиционный алгоритм сравнить и присвоить . 

Она читает значение counter и передает его функции inc . Когда inc вернет 

управление, доступ к переменной counter блокируется и ее значение сравни-

вается со значением, переданным в inc . Если они равны, в counter записыва-

ется значение, которое вернула функция inc, и блокировка освобождается . 

Иначе блокировка освобождается и попытка повторяется .

Механизм атомов эффективен для простых приложений . Но, к сожалению, 

он не гарантирует абсолютную защищенность от конкурирующих обновле-

ний и взаимоблокировок, когда в игру вступает несколько взаимозависимых 

изменяемых переменных . В таких ситуациях предпочтительнее использо-

вать более надежные средства .

Суть в том, что правильно организованные приложения должны делиться 

на компоненты, имеющие и не имеющие изменяемых переменных . Такое 

72   Глава 6. Функциональное программирование

деление обеспечивается использованием подходящих дисциплин для за-

щиты изменяемых переменных .

Со стороны архитекторов было бы разумно как можно больше кода поме-

стить в неизменяемые компоненты и как можно меньше — в компоненты, 

допускающие возможность изменения .

Регистрация событий

Проблема ограниченности объема памяти и конечной вычислительной 

мощности процессоров очень быстро теряет свою актуальность . В настоя-

щее время обычными стали компьютеры с процессорами, выполняющими 

миллиарды инструкций в секунду, и имеющие объем оперативной памяти 

в несколько миллиардов байтов . Чем больше памяти, тем быстрее работает 

компьютер и тем меньше потребность в изменяемом состоянии .

Как простой пример, представьте банковское приложение, управляющее 

счетами клиентов . Оно изменяет счета, когда выполняются операции за-

числения или списания средств .

Теперь вообразите, что вместо сумм на счетах мы сохраняем только ин-

формацию об операциях . Всякий раз, когда кто-то пожелает узнать баланс 

своего счета, мы просто выполняем все транзакции с состоянием счета от 

момента его открытия . Эта схема не требует изменяемых переменных .

Очевидно, такой подход кажется абсурдным . С течением времени коли-

чество транзакций растет и в какой-то момент объем вычислений, необ-

ходимый для определения баланса счета, станет недопустимо большим . 

Чтобы такая схема могла работать всегда, мы должны иметь неограни-

ченный объем памяти и процессор с бесконечно высокой скоростью вы-

числений .

Но иногда не требуется, чтобы эта схема работала всегда . Иногда у нас доста-

точно памяти и вычислительной мощности, чтобы подобная схема работала 

</p>
   </article>
</body>
</html>
