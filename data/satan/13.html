<!DOCTYPE html>
<html>
<head>
   <title>Моя статья</title>
   <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<style>
body {
   background-color: #f0f0f0;
   font-family: Arial, sans-serif;
}

header {
   background-color: #333;
   color: white;
   padding: 10px;
   text-align: center;
}

h1 {
   margin: 0;
}

article {
   margin: 20px;
}

h2 {
   color: #333;
}

p {
   line-height: 1.6;
}
</style>
<body>
   <header>
       <h1>статья</h1>
   </header>
   <article>
       <p>
большинство функциональных языков обладает некоторыми средствами, 

позволяющими изменять значение переменной, но в очень ограниченных 

случаях .

Подводя итог, можно сказать, что:

Функциональное программирование накладывает ограничение на присваи-

вание.

Пища для ума

Обратите внимание на шаблон, который я преднамеренно ввел в представ-

ление этих трех парадигм программирования: каждая отнимает у програм-

миста какие-то возможности . Ни одна не добавляет новых возможностей . 

Каждая накладывает какие-то дополнительные ограничения, отрицатель-

ные по своей сути . Парадигмы говорят нам не столько что делать, сколько 

чего нельзя делать .

Если взглянуть под другим углом, можно заметить, что каждая парадигма 

что-то отнимает у нас . Три парадигмы вместе отнимают у нас инструкции 

goto, указатели на функции и оператор присваивания . Есть ли у нас еще 

что-то, что можно отнять?

Вероятно, нет . Скорее всего, эти три парадигмы останутся единственными, 

которые мы увидим, — по крайней мере единственными, что-то отнимаю-

46   Глава 3. Обзор парадигм

щими у нас . Доказательством отсутствия новых парадигм может служить 

тот факт, что все три известные парадигмы были открыты в течение десяти 

лет, между 1958 и 1968 годами . За многие последующие десятилетия не по-

явилось ни одной новой парадигмы .

Заключение

Какое отношение к архитектуре имеет эта поучительная история о парадиг-

мах? Самое непосредственное . Мы используем полиморфизм как механизм 

преодоления архитектурных границ, мы используем функциональное про-

граммирование для наложения ограничений на местоположение данных 

и порядок доступа к ним, и мы используем структурное программирование 

как алгоритмическую основу для наших модулей .

Отметьте, как точно вышесказанное соответствует трем главнейшим аспек-

там строительства архитектуры: функциональности, разделению компонен-

тов и управлению данными .

4

Структурное 

программирование

48   Глава 4. Структурное программирование

Эдсгер Вибе Дейкстра родился в Роттердаме в 1930 году . Он пережил бом-

бардировки Роттердама во время Второй мировой войны, оккупацию Ни-

дерландов Германией и в 1948 году окончил среднюю школу с наивысшими 

отметками по математике, физике, химии и биологии . В марте 1952 года, 

в возрасте 21 года (и всего за 9 месяцев до моего рождения), Дейкстра устро-

ился на работу в Математический центр Амстердама и стал самым первым 

программистом в Нидерландах .

В 1955 году, имея трехлетний опыт программирования и все еще будучи 

студентом, Дейкстра пришел к выводу, что интеллектуальные вызовы про-

граммирования намного обширнее интеллектуальных вызовов теоретиче-

ской физики . В результате в качестве своей дальнейшей стези он выбрал 

программирование . В 1957 году Дейкстра женился на Марии Дебетс . В то 

время в Нидерландах требовали от вступающих в брак указывать профес-

сию . Голландские власти не пожелали принять от Дейкстры документы 

с указанной профессией «программист»; они никогда не слышали о такой 

профессии . Поэтому ему пришлось переписать документы и указать про-

фессию «физик-теоретик» .

Решение выбрать карьеру программиста Дейкстра обсудил со своим руко-

водителем, Адрианом ван Вейнгаарденом . Дейкстру волновало, что про-

граммирование в то время не признавалось ни профессией, ни наукой и что 

по этой причине его никто не будет воспринимать всерьез . Адриан ответил, 

что Дейкстра вполне может стать одним из основателей профессии и пре-

вратить программирование в науку .

Свою карьеру Дейкстра начинал в эпоху ламповой электроники, когда ком-

пьютеры были огромными, хрупкими, медленными, ненадежными и чрез-

вычайно ограниченными (по современным меркам) . В те годы программы 

записывались двоичным кодом или на примитивном языке ассемблера . 

Ввод программ в компьютеры осуществлялся с использованием перфолент 

или перфокарт . Цикл правка—компиляция—тестирование занимал часы, 

а порой и дни .

В такой примитивной среде Дейкстра сделал свои величайшие открытия .

Доказательство

С самого начала Дейкстра заметил, что программирование — сложная ра-

бота и что программисты справляются с ней не очень успешно . Программа 

любой сложности содержит слишком много деталей, чтобы человеческий 

мозг смог справиться с ней без посторонней помощи . Стоит упустить из 

Доказательство      49

виду одну маленькую деталь, и программа, которая кажется работающей, 

может завершаться с ошибкой в самых неожиданных местах .

В качестве решения Дейкстра предложил применять математический ап-

парат доказательств . Оно заключалось в построении евклидовой иерархии 

постулатов, теорем, следствий и лемм . Дейкстра полагал, что программисты 

смогут использовать эту иерархию подобно математикам . Иными словами, 

программисты должны использовать проверенные структуры и связывать 

их с кодом, в правильности которого они хотели бы убедиться .

Дейкстра понимал, что для этого он должен продемонстрировать методику 

написания доказательств на простых алгоритмах . Но эта задача оказалась 

довольно сложной .

В ходе исследований Дейкстра обнаружил, что в некоторых случаях ис-

пользование инструкции goto мешает рекурсивному разложению модулей 

на все меньшие и меньшие единицы и тем самым препятствует применению 

принципа «разделяй и властвуй», что является необходимым условием для 

обоснованных доказательств .

Однако в других случаях инструкция goto не вызывала этой проблемы . 

Дейкстра заметил, что эти случаи «доброкачественного» использования 

goto соответствуют простым структурам выбора и управления итерациями, 

таким как if/then/else и do/while . Модули, использующие только такие 

управляющие структуры, можно было рекурсивно разложить на доказуемые 

единицы .

Дейкстра знал, что эти управляющие структуры в сочетании с последова-

тельным выполнением занимают особое положение . Они были идентифи-

цированы за два года до этого Бёмом и Якопини, доказавшими, что любую 

</p>
   </article>
</body>
</html>
