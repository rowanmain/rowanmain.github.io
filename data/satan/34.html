<!DOCTYPE html>
<html>
<head>
   <title>Моя статья</title>
   <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<style>
body {
   background-color: #f0f0f0;
   font-family: Arial, sans-serif;
}

header {
   background-color: #333;
   color: white;
   padding: 10px;
   text-align: center;
}

h1 {
   margin: 0;
}

article {
   margin: 20px;
}

h2 {
   color: #333;
}

p {
   line-height: 1.6;
}
</style>
<body>
   <header>
       <h1>статья</h1>
   </header>
   <article>
       <p>
ся об интеграции результатов своего труда в коллективную основу . Затем, 

в пятницу, они объединяют свои изменения и пытаются собрать систему .

Этот подход имеет замечательное преимущество, позволяя разработчикам 

работать в изоляции четыре дня из пяти . Недостаток, конечно же, — боль-

шие трудозатраты на интеграцию в пятницу .

Принцип ацикличности зависимостей      123

К сожалению, с развитием проекта становится все сложнее завершить ин-

теграцию в пятницу . Бремя интеграции продолжает расти, пока не начинает 

захватывать субботу . Нескольких таких суббот достаточно, чтобы разработ-

чики пришли к выводу, что интеграция должна начинаться в четверг — так 

начало интеграции постепенно переползает ближе к середине недели .

Одновременно с уменьшением отношения продолжительности разработки 

к продолжительности интеграции снижается эффективность команды . В ко-

нечном итоге ситуация становится настолько удручающей, что разработчики 

и руководители проекта заявляют о необходимости перехода на двухнедель-

ный цикл сборки . Это ослабляет проблему на какое-то время, но время, за-

трачиваемое на интеграцию, продолжает расти вместе с размерами проекта .

В конечном счете этот сценарий приводит к кризису . Для поддержания 

эффективности на высоком уровне график сборки должен постоянно удли-

няться, но такое удлинение увеличивает риски . Интеграция и тестирование 

становятся все сложнее, а команда теряет преимущества, которые дает бы-

страя обратная связь .

Устранение циклических зависимостей

Решение этой проблемы заключается в разделении проекта на компоненты, 

которые могут выпускаться независимо . Компоненты становятся единицами 

работы, ответственность за которые можно возложить на одного разработ-

чика или на небольшую группу . Когда разработчики добиваются работо-

способности компонента, они выпускают новую версию для использования 

другими разработчиками . Они присваивают этой версии номер и помещают 

в каталог, доступный другим разработчикам . Затем продолжают разработку 

компонента, изменяя свои локальные копии . А все остальные используют 

выпущенную версию .

Когда появляется новая версия компонента, другие команды могут выби-

рать — сразу же задействовать новую версию или подождать . Если принято 

решение подождать, они просто продолжают использовать предыдущую 

версию . Но как только они решат, что готовы, они начинают использовать 

новую версию .

В результате ни одна команда не отдается на милость другим . Изменения 

в одном компоненте не оказывают немедленного влияния на другие команды . 

Каждая коман да сама решает, когда начать адаптацию своего компонента для 

использования новой версии другого компонента . Кроме того, интеграция 

происходит небольшими шагами . Нет единого момента времени, когда все 

разработчики должны собраться вместе и интегрировать все, что они создали .

124   Глава 14. Сочетаемость компонентов

Этот очень простой и рациональный процесс получил широкое распростра-

нение . Однако чтобы добиться успеха, вы должны управлять структурой за-

висимостей компонентов . В ней не должно быть циклических зависимостей . 

Если в структуре зависимостей появятся циклы, «синдрома следующего 

утра» не избежать .

Взгляните на диаграмму компонентов на рис . 14 .1 . Она демонстрирует 

типичную структуру компонентов, собранных в приложение . В данном 

случае назначение приложения не играет роли — важна сама структура 

зависимостей компонентов . Обратите внимание, что структура имеет вид 

ориентированного (направленного) графа . Компоненты играют роль узлов, 

а зависимости между ними — ориентированных ребер .

Рис. 14.1. Типичная диаграмма компонентов

Обратите внимание на одну важную особенность: с какого бы компонента 

вы ни начали, вы не сможете пройти по связям-зависимостям и вернуться 

обратно в этот же компонент . Эта структура не имеет циклов . Это ацикли-

ческий ориентированный граф (Directed Acyclic Graph; DAG) .

Теперь представьте, что произойдет, когда одна из команд выпустит новую 

версию компонента Presenters . Определить, кого затронет этот факт, нетруд-

но, нужно лишь проследовать по стрелкам входящих зависимостей . То есть 

затронуты будут компоненты View и Main . В этот момент разработчики, раз-

вивающие эти компоненты, должны решить, когда начать их интеграцию 

с новой версией Presenters .

Принцип ацикличности зависимостей      125

Отметьте также, что выпуск новой версии компонента Main не затронет ни-

какой другой компонент в системе . Их разработчики вообще могут не знать 

о существовании компонента Main и никак не учитывать изменения, проис-

ходящие в нем . Это замечательно . Это означает, что выпуск новой версии 

Main оказывает минимальное влияние .

Когда разработчики компонента Presenters пожелают протестировать его, 

им просто нужно собрать свою версию Presenters с версиями компонентов 

Interactors и Entities, используемыми в данный момент . Никакой другой 

компонент в системе им не потребуется для этого . Это замечательно . Это 

означает, что разработчикам Presenters не придется прилагать значительных 

усилий для подготовки к тестированию и им достаточно учесть небольшое 

количество переменных .

Когда придет время выпустить новую версию всей системы, процесс будет 

протекать снизу вверх . Сначала будет скомпилирован, протестирован и выпу-

щен компонент Entities . Затем те же действия будут выполнены с компонен-

тами Database и Interactors . За ними последуют Presenters, View, Controllers 

и затем Authorizer . И наконец, очередь дойдет до Main . Это очевидный и легко 

воспроизводимый процесс . Мы знаем, в каком порядке собирать систему, по-

тому что понимаем, как связаны зависимостями отдельные ее части .

Влияние циклов в графе зависимостей 

компонентов

Предположим, что появление новых требований вынудило нас изменить 

один из классов в компоненте Entities так, что он стал использовать класс 

из компонента Authorizer . Например, допустим, что класс User из Entities 

стал использовать класс Permissions из Authorizer . В результате образова-

лась циклическая зависимость, как показано на рис . 14 .2 .

Этот цикл немедленно приводит к появлению проблем . Например, разра-

ботчики, развивающие компонент Database, знают, что для выпуска новой 

версии они должны проверить совместимость с компонентом Entities . Но 

из-за образовавшегося цикла компонент Database теперь также должен 

быть совместим с Authorizer . Но Authorizer зависит от Interactors . Все это 

усложняет выпуск новой версии Database . Entities, Authorizer и Interactors 

фактически превращаются в один большой компонент — это означает, что 

</p>
   </article>
</body>
</html>
