<!DOCTYPE html>
<html>
<head>
   <title>Моя статья</title>
   <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<style>
body {
   background-color: #f0f0f0;
   font-family: Arial, sans-serif;
}

header {
   background-color: #333;
   color: white;
   padding: 10px;
   text-align: center;
}

h1 {
   margin: 0;
}

article {
   margin: 20px;
}

h2 {
   color: #333;
}

p {
   line-height: 1.6;
}
</style>
<body>
   <header>
       <h1>статья</h1>
   </header>
   <article>
       <p>
в течение времени выполнения приложения .

Эта идея положена в основу технологии регистрации событий (event 

sourcing)1 . Регистрация событий (event sourcing) — это стратегия, согласно 

которой сохраняются транзакции, а не состояние . Когда требуется получить 

состояние, мы просто применяем все транзакции с самого начала .

1 Спасибо Грегу Янгу, что объяснил мне суть этого понятия .

Заключение      73

Конечно, реализуя подобную стратегию, можно использовать компромисс-

ные решения для экономии ресурсов . Например, вычислять и сохранять 

состояние каждую полночь . А затем, когда потребуется получить инфор-

мацию о состоянии, выполнить лишь транзакции, имевшие место после 

полуночи .

Теперь представьте хранилище данных, которое потребуется для поддержки 

этой схемы: оно должно быть о-о-очень большим . В настоящее время объ-

емы хранилищ данных растут так быстро, что, например, триллион байтов 

мы уже не считаем большим объемом — то есть нам понадобится намного, 

намного больше .

Что особенно важно, никакая информация не удаляется из такого храни-

лища и не изменяется . Как следствие, от набора CRUD-операций1 в при-

ложениях остаются только CR . Также отсутствие операций изменения и/

или удаления с хранилищем устраняет любые проблемы конкурирующих 

обновлений .

Обладая хранилищем достаточного объема и достаточной вычислительной 

мощностью, мы можем сделать свои приложения полностью неизменяемы-

ми — и, как следствие, полностью функциональными .

Если это все еще кажется вам абсурдным, вспомните, как работают системы 

управления версиями исходного кода .

Заключение

Итак:

 

� Структурное программирование накладывает ограничение на прямую 

передачу управления .

 

� Объектно-ориентированное программирование накладывает ограниче-

ние на косвенную передачу управления .

 

� Функциональное программирование накладывает ограничение на при-

сваивание .

Каждая из этих парадигм что-то отнимает у нас . Каждая ограничивает под-

ходы к написанию исходного кода . Ни одна не добавляет новых возмож-

ностей .

1 CRUD — аббревиатура, обозначающая набор основных операций с данными: Create 

(создание), Read (чтение), Update (изменение) и Delete (удаление) . — Примеч. пер.

74   Глава 6. Функциональное программирование

Фактически последние полвека мы учились тому, как не надо делать .

Осознав это, мы должны признать неприятный факт: разработка программ-

ного обеспечения не является быстро развивающейся индустрией . Прави-

ла остаются теми же, какими они были в 1946 году, когда Алан Тьюринг 

написал первый код, который мог выполнить электронный компьютер . 

Инструменты изменились, аппаратура изменилась, но суть программного 

обеспечения осталась прежней .

Программное обеспечение — материал для компьютерных программ — со-

стоит из последовательностей, выбора, итераций и косвенности . Ни больше 

ни меньше .

III 

Принципы дизайна

Хорошая программная система начинается с чистого кода . С одной стороны, 

если здание строить из плохих кирпичей, его архитектура не имеет большого 

значения . С другой стороны, плохие кирпичи можно перемешать с хороши-

ми . Именно на этом основаны принципы SOLID .

Принципы SOLID определяют, как объединять функции и структуры 

данных в классы и как эти классы должны сочетаться друг с другом . Ис-

пользование слова «класс» не означает, что эти принципы применимы 

только к объектно-ориентированному программному коду . В данном случае 

«класс» означает лишь инструмент объединения функций и данных в груп-

пы . Любая программная система имеет такие объединения, как бы они ни 

назывались, «класс» или как-то еще . Принципы SOLID применяются к этим 

объединениям .

Цель принципов — создать программные структуры среднего уровня, ко-

торые:

 

� терпимы к изменениям;

 

� просты и понятны;

 

� образуют основу для компонентов, которые могут использоваться во 

многих программных системах .

Термин «средний уровень» отражает тот факт, что эти принципы приме-

няются программистами на уровне модулей . Они применяются на уровне, 

76   Принципы дизайна

лежащем непосредственно над уровнем программного кода, и помогают 

определять программные структуры, используемые в модулях и компо-

нентах .

Как из хороших кирпичей можно сложить никуда не годную стену, так из 

хорошо продуманных компонентов среднего уровня можно создать никуда 

не годную систему . Поэтому сразу после знакомства с принципами SOLID 

мы перейдем к их аналогам в мире компонентов, а затем к высокоуровневым 

принципам создания архитектур .

Принципы SOLID имеют долгую историю . Я начал собирать их в конце 

1980-х годов, обсуждая принципы проектирования программного обеспече-

ния с другими пользователями USENET (ранняя разновидность Facebook) . 

На протяжении многих лет принципы смещались и изменялись . Некоторые 

исчезали . Другие объединялись . А какие-то добавлялись . В окончательном 

виде они были сформулированы в начале 2000-х годов, хотя и в другом по-

рядке, чем я представлял .

В 2004 году или около того Майкл Физерс прислал мне электронное пись-

мо, в котором сообщил, что если переупорядочить мои принципы, из их 

первых букв можно составить слово SOLID1 — так появились принципы 

SOLID .

Последующие главы подробнее описывают каждый принцип, а пока позна-

комьтесь с краткой аннотацией:

 

� SRP: Single Responsibility Principle — принцип единственной ответствен-

ности .

Действительное следствие закона Конвея: лучшей является такая струк-

тура программной системы, которая формируется в основном под вли-

янием социальной структуры организации, использующей эту систему, 

поэтому каждый программный модуль имеет одну и только одну причину 

для изменения .

 

� OCP: Open-Closed Principle — принцип открытости/закрытости .

Этот принцип был сформулирован Бертраном Мейером в 1980-х годах . 

Суть его сводится к следующему: простая для изменения система должна 

предусматривать простую возможность изменения ее поведения добав-

лением нового, но не изменением существующего кода .

1 В данном случае слово «SOLID» можно перевести как «прочный», «надежный», «ос-

новательный» . — Примеч. пер.

Принципы дизайна      77

 

� LSP: Liskov Substitution Principle — принцип подстановки Барбары 

Лисков .

Определение подтипов Барбары Лисков известно с 1988 года . В двух сло-

вах, этот принцип утверждает, что для создания программных систем из 

взаимозаменяемых частей эти части должны соответствовать контракту, 

который позволяет заменять эти части друг другом .

 

� ISP: Interface Segregation Principle — принцип разделения интерфейсов .

Этот принцип призывает разработчиков программного обеспечения из-

бегать зависимости от всего, что не используется .

 

� DIP: Dependency Inversion Principle — принцип инверсии зависимости .

Код, реализующий высокоуровневую политику, не должен зависеть от 

кода, реализующего низкоуровневые детали . Напротив, детали должны 

зависеть от политики .

Эти принципы детально описаны во множестве публикаций1 . Последующие 

главы освещают влияние этих принципов на проектирование архитектур, не 

повторяя подробное обсуждение из этих публикаций . Если вы еще не знако-

мы с перечисленными принципами, обсуждения, следующего далее, будет 

недостаточно, чтобы понять их во всех подробностях, поэтому я рекомендую 

обратиться к документам, перечисленным в сноске .

1 Например, Agile Software Development, Principles, Patterns, and Practices, Robert C . 

Martin, Prentice Hall, 2002 (Роберт С. Мартин. Гибкая разработка программ на Java 

и C++: принципы, паттерны и методики . М .: Вильямс, 2017 . — Примеч. пер.), http://

www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod и https://en.wikipedia.org/wiki/

SOLID_(object-oriented_design) (можно просто выполнить поиск в Google по слову 

«SOLID») .

7

Принцип единственной 

ответственности

Принцип единственной ответственности      79

Из всех принципов SOLID наиболее трудно понимаемым является прин-

цип единственной ответственности (Single Responsibility Principle, SRP) . 

Это, вероятно, обусловлено выбором названия, недостаточно точно соот-

ветствующего сути . Услышав это название, многие программисты решают: 

оно означает, что каждый модуль должен отвечать за что-то одно .

Самое интересное, что такой принцип действительно существует . Он гласит: 

функция должна делать что-то одно и только одно . Этот принцип мы исполь-

зуем, когда делим большие функции на меньшие, то есть на более низком 

уровне . Но он не является одним из принципов SOLID — это не принцип 

единственной ответственности .

Традиционно принцип единственной ответственности описывался так:

Модуль должен иметь одну и только одну причину для изменения.

Программное обеспечение изменяется для удовлетворения нужд пользова-

телей и заинтересованных лиц . Пользователи и заинтересованные лица как 

раз и есть та самая «причина для изменения», о которой говорит принцип . 

Фактически принцип можно перефразировать так:

Модуль должен отвечать за одного и только за одного пользователя или за-

интересованное лицо.

К сожалению, слова «пользователь» и «заинтересованное лицо» не совсем 

правильно использовать здесь, потому что одного и того же изменения си-

стемы могут желать несколько пользователей или заинтересованных лиц . 

Более правильным выглядит понятие группы, состоящей из одного или 

нескольких лиц, желающих данного изменения . Мы будем называть такие 

группы акторами (actor) .

Соответственно, окончательная версия принципа единственной ответствен-

ности выглядит так:

Модуль должен отвечать за одного и только за одного актора.

Теперь определим, что означает слово «модуль» . Самое простое опреде-

ление — файл с исходным кодом . В большинстве случаев это определение 

можно принять . Однако некоторые языки среды разработки не используют 

исходные файлы для хранения кода . В таких случаях модуль — это просто 

связный набор функций и структур данных .

Слово «связный» подразумевает принцип единственной ответственности . 

Связность — это сила, которая связывает код, ответственный за единствен-

ного актора .

80   Глава 7. Принцип единственной ответственности

Пожалуй, лучший способ понять суть этого принципа — исследовать при-

знаки его нарушения .

Признак 1: непреднамеренное 

дублирование

Мой любимый пример — класс Employee из приложения платежной ведомо-

сти . Он имеет три метода: calculatePay(), reportHours() и save() (рис . 7 .1) .

Рис. 7.1. Класс Employee

Этот класс нарушает принцип единственной ответственности, потому что 

три его метода отвечают за три разных актора .

 

� Реализация метода calculatePay() определяется бухгалтерией .

 

� Реализация метода reportHours() определяется и используется отделом 

по работе с персоналом .

 

� Реализация метода save() определяется администраторами баз данных .

Поместив исходный код этих трех методов в общий класс Employee, разработ-

чики объединили перечисленных акторов . В результате такого объединения 

действия сотрудников бухгалтерии могут затронуть что-то, что требуется 

сотрудникам отдела по работе с персоналом .

Например, представьте, что функции calculatePay() и reportHours() исполь-

зуют общий алгоритм расчета не сверхурочных часов . Представьте также, 

что разработчики, старающиеся не дублировать код, поместили реализацию 

этого алгоритма в функцию с именем regularHours() (рис . 7 .2) .

Признак 2: слияния      81

Рис. 7.2. Общий алгоритм

Теперь вообразите, что сотрудники бухгалтерии решили немного изменить 

алгоритм расчета не сверхурочных часов . Сотрудники отдела по работе 

с персоналом были бы против такого изменения, потому что вычисленное 

время они используют для других целей .

Разработчик, которому было поручено внести изменение, заметил, что функ-

ция regularHours() вызывается методом calculatePay(), но, к сожалению, не 

заметил, что она также вызывается методом reportHours() .

Разработчик внес требуемые изменения и тщательно протестировал резуль-

тат . Сотрудники бухгалтерии проверили и подтвердили, что обновленная 

функция действует в соответствии с их пожеланиями, после чего изменен-

ная версия системы была развернута .

Разумеется, сотрудники отдела по работе с персоналом не знали о про-

изошедшем и продолжали использовать отчеты, генерируемые функцией 

reportHours(), но теперь содержащие неправильные цифры . В какой-то 

момент проблема вскрылась, и сотрудники отдела по работе с персоналом 

разом побледнели от ужаса, потому что ошибочные данные обошлись их 

бюджету в несколько миллионов долларов .

Все мы видели нечто подобное . Эти проблемы возникают из-за того, что 

мы вводим в работу код, от которого зависят разные акторы . Принцип 

единственной ответственности требует разделять код, от которого зависят 

разные акторы .

Признак 2: слияния

Слияния — обычное дело для исходных файлов с большим количеством 

разных методов . Эта ситуация особенно вероятна, если эти методы отвечают 

за разных акторов .

82   Глава 7. Принцип единственной ответственности

Например, представим, что коллектив администраторов баз данных решил 

внести простое исправление в схему таблицы Employee . Представим также, 

что сотрудники отдела по работе с персоналом пожелали немного изменить 

формат отчета, возвращаемого функцией reportHours() .

Два разных разработчика, возможно, из двух разных команд, извлекли 

класс Employee из репозитория и внесли изменения . К сожалению, их 

изменения оказались несовместимыми . В результате потребовалось вы-

полнить слияние .

Я думаю, мне не нужно рассказывать вам, что всякое слияние сопряжено 

с некоторым риском . Современные инструменты довольно совершенны, 

но никакой инструмент не сможет правильно обработать все возможные 

варианты слияния . В итоге риск есть всегда .

В нашем примере процедура слияния поставила под удар администраторов 

баз данных и отдел по работе с персоналом . Вполне возможно, что риску 

подверглась также бухгалтерия .

Существует много других признаков, которые мы могли бы рассмотреть, 

но все они сводятся к изменению одного и того же исходного кода разными 

людьми по разным причинам .

И снова, исправить эту проблему можно, разделив код, предназначенный 

для обслуживания разных акторов .

Решения

Существует много решений этой проблемы . Но каждое связано с перемеще-

нием функций в разные классы .

Наиболее очевидным, пожалуй, является решение, связанное с отделением 

данных от функций . Три класса, как показано на рис . 7 .3, используют общие 

данные EmployeeData — простую структуру без методов . Каждый класс вклю-

чает только исходный код для конкретной функции . Эти три класса никак 

не зависят друг от друга . То есть любое непреднамеренное дублирование 

исключено .

Недостаток такого решения — разработчик теперь должен создавать экзем-

пляры трех классов и следить за ними . Эта проблема часто решается приме-

нением шаблона проектирования «Фасад» (Facade), как показано на рис . 7 .4 .

Класс EmployeeFacade содержит очень немного кода и отвечает за создание 

экземпляров трех классов и делегирование вызовов методов .

Решения      83

Рис. 7.3. Три класса, не зависящих друг от друга

Рис. 7.4. Шаблон «Фасад»

Некоторые разработчики предпочитают держать наиболее важные бизнес-

правила как можно ближе к данным . Это можно сделать, сохранив важные 

методы в оригинальном классе Employee, и затем использовать этот класс 

как фасад для низкоуровневых функций (рис . 7 .5) .

Рис. 7.5. Наиболее важные методы остаются в оригинальном классе Employee 

и используются как фасад для низкоуровневых функций

Вы можете возразить против такого решения на том основании, что каж-

дый класс содержит только одну функцию . Однако в реальности такое едва 

ли возможно . Количество функций, необходимых для расчета зарплаты, 

создания отчета или сохранения данных, наверняка будет больше в любом 

случае . Каждый из таких классов может иметь также много приватных 

методов .

84   Глава 7. Принцип единственной ответственности

Каждый такой класс, содержащий подобное семейство методов, образует 

свою область видимости . Вне этой области никто не знает о существовании 

приватных членов семейства .

Заключение

Принцип единственной ответственности (Single Responsibility Principle; 

SRP) касается функций и классов, но он проявляется в разных формах на 

еще двух более высоких уровнях . На уровне компонентов он превращается 

в принцип согласованного изменения (Common Closure Principle; CCP), 

а на архитектурном уровне — в принцип оси изменения (Axis of Change), 

отвечающий за создание архитектурных границ . Все эти идеи мы обсудим 

в последующих главах .

8

Принцип открытости/

закрытости

86   Глава 8. Принцип открытости/закрытости

Принцип открытости/закрытости (Open-Closed Principle; OCP) был сфор-

мулирован Бертраном Мейером в 1988 году .1 Он гласит:

Программные сущности должны быть открыты для расширения и закрыты 

для изменения.

Иными словами, должна иметься возможность расширять поведение про-

граммных сущностей без их изменения .

Это одна из основных причин, почему мы изучаем архитектуру программ-

ного обеспечения . Очевидно, если простое расширение требований ведет 

к значительным изменениям в программном обеспечении, значит, архитек-

торы этой программной системы потерпели сокрушительное фиаско .

Большинство студентов, изучающих проектирование программного обе-

спечения, признают принцип OCP как руководство по проектированию 

классов и модулей . Но на уровне архитектурных компонентов этот принцип 

приобретает еще большую значимость .

Увидеть это поможет простой мысленный эксперимент .

Мысленный эксперимент

Представьте, что у нас есть финансовая сводка . Содержимое страницы про-

кручивается, и отрицательные значения выводятся красным цветом .

Теперь допустим, что заинтересованные лица попросили нас представить 

ту же информацию в виде отчета, распечатанного на черно-белом принтере . 

Отчет должен быть разбит на страницы, включать соответствующие верхний 

и нижний колонтитулы на каждой странице и колонку меток . Отрицатель-

ные значения должны заключаться в круглые скобки .

Очевидно, что для этого придется написать новый код . Но как много старого 

кода придется изменить?

В программном обеспечении с хорошо проработанной архитектурой таких 

изменений должно быть очень немного . В идеале их вообще не должно быть .

Как? Правильно разделяя сущности, которые изменяются по разным причи-

нам (принцип единственной ответственности), и затем правильно организуя 

зависимости между этими сущностями (принцип инверсии зависимостей) .

1 Bertrand Meyer . Object Oriented Software Construction, Prentice Hall, 1988, p . 23 (Бертран 

Мейер. Объектно-ориентированное конструирование программных систем . Русская 

редакция, 2005 . — Примеч. пер.) .

Мысленный эксперимент      87

Применяя принцип единственной ответственности, можно прийти к пото-

ку данных, изображенному на рис . 8 .1 . Некоторая процедура анализирует 

финансовые данные и производит данные для отчета, которые затем фор-

матируются двумя процедурами формирования отчетов .

Рис. 8.1. Результат применения принципа единственной ответственности

Самое важное, что нужно понять, — в данном примере в создание отчета 

вовлечены две отдельные ответственности: вычисление данных для отчета 

и представление этих данных в форме веб-отчета или распечатанного отчета .

Сделав такое разделение, мы должны организовать зависимости в исходном 

коде так, чтобы изменения в одной из ответственностей не вызывали не-

обходимости изменений в другой . Кроме того, новая организация должна 

гарантировать возможность расширения поведения без отмены изменений .

Этого можно добиться, выделив процессы в классы, а классы в компоненты, 

ограниченные двойными линиями на рис . 8 .2 . Компонент в левом верхнем 

углу на этом рисунке — контроллер . В правом верхнем углу — интерактор, 

или посредник . В правом нижнем углу — база данных . Наконец, в левом ниж-

нем углу изображены четыре компонента — презентаторы и представления .

Классы, отмеченные символами <I>, — это интерфейсы; отмеченные сим-

волами <DS> — это структуры данных (data structures) . Простые стрелки 

соответствуют отношениям использования . Стрелки с треугольным нако-

нечником соответствуют отношениям реализации или наследования .

Первое, на что следует обратить внимание, — все зависимости определены 

на уровне исходного кода . Стрелка, направленная от класса A к классу B, 

означает, что в исходном коде класса A упоминается имя класса B, но в коде 

класса B не упоминается имя класса A . Так, на рис . 8 .2 диспетчер финан-

совых данных знает о существовании шлюза через отношение реализации, 

а шлюз финансовых данных ничего не знает о диспетчере .

88   Глава 8. Принцип открытости/закрытости

Контроллер

финансового

отчета

Контроллер

Презентатор

финансового

отчета

Интерактор

Запрос

финансового

отчета

Заказчик

финансового

отчета

Возвращаемый

финансовый

отчет

Генератор

финансового

отчета

Шлюз

финансовых

данных

Финансовые

сущности

Диспетчер

финансовых

данных

Финансовая

база данных

База

данных

Экранный

презентатор

Экранный

презентатор

Модель

экранного

представления

Экранное

представление

Веб-представ-

ление

Веб-представ-

ление

PDF-представ-

ление

PDF-представ-

ление

Печатное

представление

Модель

печатного

представления

Печатный

презентатор

Печатный

презентатор

Рис. 8.2. Выделение процессов в классы и выделение классов в компоненты

Также важно отметить, что каждая двойная линия пересекается толь-

ко в одном направлении . Это означает, что все отношения компонентов 

однонаправленны, как показано на графе компонентов (рис . 8 .3) . Эти 

стрелки указывают на компоненты, которые мы стремимся защитить от 

изменения .

Позволю себе повторить еще раз: если компонент A требуется защитить от 

изменений в компоненте B, компонент B должен зависеть от компонента A .

Нам нужно защитить контроллер от изменений в презентаторах . Нам 

нужно защитить презентаторы от изменений в представлениях . Нам нужно 

защитить интерактор от изменений в . . . во всех остальных компонентах .

Интерактор находится в позиции, лучше соответствующей принципу 

 открытости/закрытости . Изменения в базе данных, или в контроллере, 

или в презентаторах, или в представлениях не должны влиять на ин-

терактор .

Мысленный эксперимент      89

Контроллер

финансового

отчета

Интерактор

финансового

отчета

Экранный

презентатор

Печатный

презентатор

Веб-представ-

ление

PDF-представ-

ление

Финансовая

база данных

Рис. 8.3. Отношения компонентов однонаправленны

Почему интерактор должен придерживаться такой привилегированной 

позиции? Потому что он реализует бизнес-правила . Интерактор реализует 

политики высшего уровня в приложении . Все другие компоненты решают 

второстепенные задачи . Интерактор решает самую главную задачу .

Несмотря на то что контроллер является не таким важным компонентом, как 

интерактор, он важнее презентаторов и представлений . А презентаторы, 

хотя и менее важные, чем контроллеры, в свою очередь, важнее представлений .

Обратите внимание, что в результате выстраивается иерархия защиты, 

основанная на понятии «уровня» . Интеракторы занимают самый верхний 

уровень, поэтому они должны быть самыми защищенными . Представления 

занимают самый низкий уровень, поэтому они наименее защищены . Пре-

зентаторы находятся уровнем выше представлений, но ниже контроллера 

или интерактора .

Именно так работает принцип открытости/закрытости на архитектурном 

уровне . Архитекторы разделяют функциональные возможности, опираясь 

на то, как, почему и когда их может потребоваться изменить, и затем орга-

низуют их в иерархию компонентов . Компоненты, находящиеся на верхних 

уровнях в такой иерархии, защищаются от изменений в компонентах на 

нижних уровнях .

90   Глава 8. Принцип открытости/закрытости

Управление направлением

Если вы испытали шок от схемы классов, представленной выше, взгляните 

на нее еще раз . Основная сложность в ней заключается в необходимости 

сориентировать зависимости между компонентами в правильных направ-

лениях .

Например, интерфейс шлюза финансовых данных между генератором 

финансового отчета и диспетчером финансовых данных добавлен с целью 

обратить направление зависимости, которая иначе была бы направлена 

из компонента интерактора в компонент базы данных . То же относится 

к интерфейсу презентатора финансового отчета и двум интерфейсам пред-

ставлений .

Сокрытие информации

Интерфейс заказчика финансового отчета служит другой цели — защитить 

контроллер финансового отчета от необходимости знать внутренние особен-

ности интерактора . В отсутствие этого интерфейса контроллер получил бы 

транзитивные зависимости от финансовых сущностей .

Транзитивные (переходящие) зависимости нарушают общий принцип, со-

гласно которому программные сущности не должны зависеть от того, что 

они не используют непосредственно . Мы вновь встретимся с этим принци-

пом, когда будем обсуждать принципы разделения интерфейсов и совмест-

ного повторного использования (Common Reuse Principle; CRP) .

Поэтому, даже при том, что высший приоритет имеет защита интерактора 

от изменений в контроллере, мы также должны защитить контроллер от из-

менений в интеракторе, скрыв детали реализации интерактора .

Заключение

Принцип открытости/закрытости — одна из движущих сил в архитектуре 

систем . Его цель — сделать систему легко расширяемой и обезопасить ее от 

влияния изменений . Эта цель достигается делением системы на компоненты 

и упорядочением их зависимостей в иерархию, защищающую компоненты 

уровнем выше от изменений в компонентах уровнем ниже .

9

Принцип подстановки 

Барбары Лисков

92   Глава 9. Принцип подстановки Барбары Лисков

В 1988 году Барбара Лисков написала следующие строки с формулировкой 

определения подтипов .

Здесь требуется что-то вроде следующего свойства подстановки: если для 

каждого объекта o1 типа S существует такой объект o2 типа T, что для 

всех программ P, определенных в терминах T, поведение P не изменяется при 

подстановке o1 вместо o2, то S является подтипом T1.

Чтобы понять эту идею, известную как принцип подстановки Барбары Ли-

сков (Liskov Substitution Principle; LSP), рассмотрим несколько примеров .

Руководство по использованию 

наследования

Представьте, что у нас есть класс с именем License, как показано на рис . 9 .1 . 

Этот класс имеет метод с именем calcFee(), который вызывается приложе-

нием Billing . Существует два «подтипа» класса License: PersonalLicense 

и BusinessLicense . Они реализуют разные алгоритмы расчета лицензионных 

отчислений .

Рис. 9.1. Класс License и его производные, соответствующие принципу LSP

Этот дизайн соответствует принципу подстановки Барбары Лисков, потому 

что поведение приложения Billing не зависит от использования того или 

иного подтипа . Оба подтипа могут служить заменой для типа License .

Проблема квадрат/прямоугольник

Классическим примером нарушения принципа подстановки Барбары Ли-

сков может служить известная проблема квадрат/прямоугольник (рис . 9 .2) .

1 Barbara Liskov . Data Abstraction and Hierarchy, SIGPLAN Notices 23, 5 (May 1988) .

LSP и архитектура      93

Рис. 9.2. Известная проблема квадрат/прямоугольник

В этом примере класс Square (представляющий квадрат) неправильно 

определен как подтип класса Rectangle (представляющего прямоугольник), 

потому что высоту и ширину прямоугольника можно изменять независимо; 

а высоту и ширину квадрата можно изменять только вместе . Поскольку 

класс User полагает, что взаимодействует с экземпляром Rectangle, его легко 

можно ввести в заблуждение, как демонстрирует следующий код:

Rectangle r = ...

r.setW(5);

r.setH(2);

assert(r.area() == 10);

Если на место ... подставить код, создающий экземпляр Square, тогда 

проверка assert потерпит неудачу . Единственный способ противостоять 

такому виду нарушений принципа LSP — добавить в класс User механизм 

(например, инструкцию if), определяющий ситуацию, когда прямоуголь-

ник фактически является квадратом . Так как поведение User зависит от ис-

пользуемых типов, эти типы не являются заменяемыми (совместимыми) .

LSP и архитектура

На заре объектно-ориентированной революции принцип LSP рассматри-

вался как руководство по использованию наследования, как было показано 

в предыдущих разделах . Но со временем LSP был преобразован в более 

широкий принцип проектирования программного обеспечения, который 

распространяется также на интерфейсы и реализации .

Подразумеваемые интерфейсы могут иметь множество форм . Это могут 

быть интерфейсы в стиле Java, реализуемые несколькими классами . Или 

это может быть группа классов на языке Ruby, реализующих методы с оди-

94   Глава 9. Принцип подстановки Барбары Лисков

наковыми сигнатурами . Или это может быть набор служб, соответствующих 

общему интерфейсу REST .

Во всех этих и многих других ситуациях применим принцип LSP, потому что 

существуют пользователи, зависящие от четкого определения интерфейсов 

и замещаемости их реализаций .

Лучший способ понять значение LSP с архитектурной точки зрения — по-

смотреть, что случится с архитектурой системы при нарушении принципа .

Пример нарушения LSP

Допустим, что мы взялись за создание приложения, объединяющего не-

сколько служб, предоставляющих услуги такси . Клиенты, как предпола-

гается, будут использовать наш веб-сайт для поиска подходящего такси, 

независимо от принадлежности к той или иной компании . Как только 

клиент подтверждает заказ, наша система передает его выбранному такси, 

используя REST-службу .

Теперь предположим, что URI службы является частью информации, хра-

нящейся в базе данных водителей . Выбрав водителя, подходящего для 

клиента, наша система извлекает URI из записи с информацией о водителе 

и использует ее для передачи заказа этому водителю .

Допустим, что для водителя с именем Bob адрес URI отправки заказа вы-

глядит так:

purplecab.com/driver/Bob

Наша система добавит в конец этого URI информацию о заказе и пошлет 

его методом PUT:

purplecab.com/driver/Bob

       /pickupAddress/24 Maple St.

       /pickupTime/153

       /destination/ORD

Это явно означает, что все службы должны соответствовать общему 

интерфейсу REST . Они должны единообразно интерпретировать поля 

pickupAddress, pickupTime и destination .

Теперь предположим, что компания такси Acme наняла несколько про-

граммистов, которые ознакомились со спецификацией недостаточно вни-

мательно . Они сократили имя поля destination до dest . Компания Acme — 

Заключение      95

крупнейшая компания такси в нашем регионе, и бывшая жена президента 

компании Acme вышла замуж за президента нашей компании, и . . . В общем, 

вы поняли . Что может произойти с архитектурой нашей системы?

Очевидно, мы должны бы добавить особый случай . Запрос с заказом для 

любого водителя из Acme должен бы конструироваться в соответствии 

с иным набором правил, чем для всех остальных .

Решить поставленную задачу проще всего простым добавлением инструк-

ции if в модуль, занимающийся пересылкой заказов:

if (driver.getDispatchUri().startsWith("acme.com")) ...

Конечно, ни один архитектор, дорожащий своей репутацией, не позволил 

бы добавить такую конструкцию в систему . Появление слова «acme» непо-

средственно в коде создает возможность появления самых разных непри-

ятностей, не говоря уже о бреши в безопасности .

Например, представьте, что компания Acme добилась большого успеха, 

купила компанию Purple Taxi и объединенная компания решила сменить 

имя и адрес веб-сайта и объединить все системы оригинальных компаний . 

Получается, что теперь мы должны добавить еще одну инструкцию if для 

«purple»?

Архитектор должен изолировать систему от ошибок, подобных этой, и до-

бавить модуль, управляющий созданием команд доставки заказов в соот-

ветствии с параметрами, указанным для URI в базе данных с настройками . 

Настройки могли бы выглядеть как-то так:

URI            Формат команды

Acme.com      /pickupAddress/%s/pickupTime/%s/dest/%s

*.*           /pickupAddress/%s/pickupTime/%s/destination/%s

В результате архитектор вынужден добавить важный и сложный меха-

низм из-за того, что интерфейсы не всех REST-служб оказались совме-

стимыми .

Заключение

Принцип подстановки Барбары Лисков может и должен распространяться 

до уровня архитектуры . Простое нарушение совместимости может вызвать 

загрязнение архитектуры системы значительным количеством дополни-

тельных механизмов .

10

Принцип разделения 

интерфейсов

Принцип разделения интерфейсов      97

Происхождение названия принципа разделения интерфейсов (Interface 

Segregation Principle; ISP) наглядно иллюстрирует схема на рис . 10 .1 .

Рис. 10.1. Принцип разделения интерфейсов

В данной ситуации имеется несколько классов, пользующихся операциями 

в классе OPS . Допустим, что User1 использует только операцию op1, User2 — 

только op2 и User3 — только op3 .

Теперь представьте, что OPS — это класс, написанный на таком языке, как 

Java . Очевидно, что в такой ситуации исходный код User1 непреднамеренно 

будет зависеть от op2 и op3, даже при том, что он не пользуется ими . Эта за-

висимость означает, что изменения в исходном коде метода op2 в классе OPS 

потребуют повторной компиляции и развертывания класса User1, несмотря 

на то что для него ничего не изменилось .

Эту проблему можно решить разделением операций по интерфейсам, как 

показано на рис . 10 .2 .

Рис. 10.2. Разделение операций

98   Глава 10. Принцип разделения интерфейсов

Если снова представить, что этот интерфейс реализован на языке со строгим 

контролем типов, таком как Java, исходный код User1 будет зависеть от U1Ops 

и op1, но не от OPS . То есть изменения в OPS, которые не касаются User1, не 

потребуют повторной компиляции и развертывания User1 .

Принцип разделения интерфейсов и язык

Очевидно, что описание выше в значительной степени зависит от типа 

языка . Языки со статическими типами, такие как Java, вынуждают про-

граммистов создавать объявления, которые должны импортироваться или 

подключаться к исходному коду пользователя как-то иначе . Именно эти 

инструкции подключения в исходном коде пользователя создают зависи-

мости и вынуждают выполнять повторную компиляцию и развертывание .

В языках с динамической типизацией, таких как Ruby или Python, по-

добные объявления отсутствуют в исходном коде — они определяются 

автоматически во время выполнения . То есть в исходном коде отсутствуют 

зависимости, вынуждающие выполнять повторную компиляцию и развер-

тывание . Это главная причина, почему системы на языках с динамической 

типизацией получаются более гибкими и с меньшим количеством строгих 

связей .

Этот факт ведет нас к заключению, что принцип разделения интерфейсов 

является проблемой языка, а не архитектуры .

Принцип разделения интерфейсов 

и архитектура

Если отступить на шаг назад и взглянуть на коренные мотивы, стоящие 

за принципом разделения интерфейсов, можно заметить более глубинные 

проблемы . В общем случае опасно создавать зависимости от модулей, со-

держащих больше, чем требуется . Это справедливо не только в отношении 

зависимостей в исходном коде, которые могут вынуждать выполнять без 

необходимости повторную компиляцию и развертывание, но также на более 

высоком уровне — на уровне архитектуры .

Рассмотрим, например, действия архитектора, работающего над системой S . 

Он пожелал включить в систему некоторый фреймворк F . Теперь представь-

те, что авторы F связали его с поддержкой конкретной базы данных D . То 

есть S зависит от F, который зависит от D (рис . 10 .3) .

Заключение      99

Система S

Фреймворк F

База данных D

Рис. 10.3. Проблемная архитектура

Теперь представьте, что D включает функции, которые не используются 

фреймворком F и, соответственно, не используются системой S . Изменения 

в этих функциях внутри D могут вынудить повторно развернуть F и, со-

ответственно, повторно развернуть S . Хуже того, ошибка в одной из таких 

функций внутри D может спровоцировать появление ошибок в F и S .

Заключение

Из вышесказанного следует вывод: зависимости, несущие лишний груз 

ненужных и неиспользуемых особенностей, могут стать причиной неожи-

данных проблем .

Мы развернем эту мысль подробнее при обсуждении принципа совместно-

го использования (Common Reuse Principle; CRP) в главе 13 «Связность 

компонентов» .

11

Принцип инверсии 

зависимости

Стабильные абстракции      101

Принцип инверсии зависимости (Dependency Inversion Principle; DIP) ут-

верждает, что наиболее гибкими получаются системы, в которых зависимости 

в исходном коде направлены на абстракции, а не на конкретные реализации .

В языках со статической системой типов, таких как Java, это означает, что 

инструкции use, import и include должны ссылаться только на модули с ис-

ходным кодом, содержащим интерфейсы, абстрактные классы и другие 

абстрактные объявления . Никаких зависимостей от конкретных реализаций 

не должно быть .

То же правило действует для языков с динамической системой типов, таких 

как Ruby или Python . Исходный код не должен зависеть от модулей с кон-

кретной реализацией . Однако в этих языках труднее определить, что такое 

конкретный модуль . В частности, это любой модуль, в котором реализованы 

вызываемые функции .

Очевидно, что принять эту идею за правило практически невозможно, по-

тому что программные системы должны зависеть от множества конкретных 

особенностей . Например, String в Java — это конкретный класс и его невоз-

можно сделать абстрактным . Зависимости исходного кода от конкретного 

модуля java.lang.string невозможно и не нужно избегать .

С другой стороны, класс String очень стабилен . Изменения в этот класс 

вносятся крайне редко и жестко контролируются . Программистам и ар-

хитекторам не приходится беспокоиться о частых и непредсказуемых из-

менениях в String .

По этим причинам мы склонны игнорировать стабильный фундамент 

операционной системы и платформы, рассуждая о принципе инверсии за-

висимости . Мы терпим эти конкретные зависимости, потому что уверенно 

можем положиться на их постоянство .

Мы должны избегать зависимости от неустойчивых конкретных элементов 

системы . То есть от модулей, которые продолжают активно разрабатываться 

и претерпевают частые изменения .

Стабильные абстракции

Каждое изменение абстрактного интерфейса вызывает изменение его кон-

кретной реализации . Изменение конкретной реализации, напротив, не 

всегда сопровождается изменениями и даже обычно не требует изменений 

в соответствующих интерфейсах . То есть интерфейсы менее изменчивы, 

чем реализации .

102   Глава 11. Принцип инверсии зависимости

Действительно, хорошие дизайнеры и архитекторы программного обеспе-

чения всеми силами стремятся ограничить изменчивость интерфейсов . Они 

стараются найти такие пути добавления новых возможностей в реализации, 

которые не потребуют изменения интерфейсов . Это основа проектирования 

программного обеспечения .

Как следствие, стабильными называются такие архитектуры, в которых 

вместо зависимостей от переменчивых конкретных реализаций использу-

ются зависимости от стабильных абстрактных интерфейсов . Это следствие 

сводится к набору очень простых правил:

 

� Не ссылайтесь на изменчивые конкретные классы. Ссылайтесь на 

абстрактные интерфейсы . Это правило применимо во всех языках, не-

зависимо от устройства системы типов . Оно также накладывает важные 

ограничения на создание объектов и определяет преимущественное ис-

пользование шаблона «Абстрактная фабрика» .

 

� Не наследуйте изменчивые конкретные классы . Это естественное след-

ствие из предыдущего правила, но оно достойно отдельного упоминания . 

Наследование в языках со статической системой типов является самым 

строгим и жестким видом отношений в исходном коде; следовательно, его 

следует использовать с большой осторожностью . Наследование в языках 

с динамической системой типов влечет меньшее количество проблем, но 

все еще остается зависимостью, поэтому дополнительная предосторож-

ность никогда не помешает .

 

� Не переопределяйте конкретные функции. Конкретные функции часто 

требуют зависимостей в исходном коде . Переопределяя такие функции, 

вы не устраняете эти зависимости — фактически вы наследуете их . Для 

управления подобными зависимостями нужно сделать функцию аб-

страктной и создать несколько ее реализаций .

 

� Никогда не ссылайтесь на имена конкретных и изменчивых сущностей. 

В действительности это всего лишь перефразированная форма самого 

принципа .

Фабрики

Чтобы соблюсти все эти правила, необходимо предусмотреть особый способ 

создания изменчивых объектов . Это объясняется тем, что практически во 

всех языках создание объектов связано с образованием зависимостей на 

уровне исходного кода от конкретных определений этих объектов .

Фабрики      103

В большинстве объектно-ориентированных языков, таких как Java, для 

управления подобными нежелательными зависимостями можно использо-

вать шаблон «Абстрактная фабрика» .

Рисунок 11 .1 демонстрирует, как работает такая схема . Приложение 

Application использует конкретную реализацию ConcreteImpl через интер-

фейс Service . Однако приложению требуется каким-то образом создавать 

экземпляры ConcreteImpl . Чтобы решить эту задачу без образования зави-

симости от ConcreteImpl на уровне исходного кода, приложение вызывает 

метод makeSvc интерфейса фабрики ServiceFactory . Этот метод реализован 

в классе ServiceFactoryImpl, наследующем ServiceFactory . Эта реализация 

создает экземпляр ConcreteImpl и возвращает его как экземпляр интерфейса 

Service .

<<создает>>

Рис. 11.1. Использование шаблона «Абстрактная фабрика»  

для управления зависимостями

Извилистая линия на рис . 11 .1 обозначает архитектурную границу . Она от-

деляет абстракцию от конкретной реализации . Все зависимости в исходном 

коде пересекают эту границу в одном направлении — в сторону абстракции .

Извилистая линия делит систему на два компонента: абстрактный и кон-

кретный . Абстрактный компонент содержит все высокоуровневые бизнес-

правила приложения . Конкретный компонент содержит детали реализации 

этих правил .

Обратите внимание, что поток управления пересекает извилистую линию 

в направлении, обратном направлению зависимостей в исходном коде . 

104   Глава 11. Принцип инверсии зависимости

Зависимости следуют в направлении, противоположном направлению по-

тока управления — именно поэтому принцип получил название принципа 

инверсии зависимости .

Конкретные компоненты

Конкретный компонент ConcreteImpl на рис . 11 .1 имеет единственную за-

висимость, то есть он нарушает принцип DIP . Это нормально . Полностью 

устранить любые нарушения принципа инверсии зависимости невозможно, 

но их можно сосредоточить в узком круге конкретных компонентов и изо-

лировать от остальной системы .

Большинство систем будет содержать хотя бы один такой конкретный ком-

понент — часто с именем main, потому что включает функцию main1 . В схеме, 

изображенной на рис . 11 .1, функция main могла бы создавать экземпляр 

ServiceFactoryImpl и сохранять ссылку на него в глобальной переменной 

типа ServiceFactory . Благодаря этому приложение Application сможет ис-

пользовать данную глобальную переменную для обращения к фабрике .

Заключение

По мере продвижения вперед и знакомства с высокоуровневыми архитек-

турными принципами мы снова и снова будем сталкиваться с принципом 

инверсии зависимостей . Он будет самым заметным организационным прин-

ципом в наших архитектурных диаграммах . Извилистая линия на рис . 11 .1 

часто будет обозначать архитектурные границы в последующих главах . 

Зависимости будут пересекать эту извилистую линию в одном направле-

нии, в сторону более абстрактных сущностей, и это станет для нас новым 

правилом, которое мы будем называть правилом зависимостей .

1 То есть функцию, которая вызывается операционной системой в момент запуска при-

ложения .

IV 

Принципы 

организации 

компонентов

Принципы SOLID определяют, как выкладывать кирпичами стены, обра-

зующие комнаты, а принципы организации компонентов — как размещать 

комнаты в зданиях . Большие программные системы, подобно большим 

зданиям, строятся из меньших компонентов .

В части IV мы познакомимся с программными компонентами, узнаем, из 

каких элементов они состоят и как конструировать системы из них .

12 Компоненты

Краткая история компонентов      107

Компоненты — это единицы развертывания . Они представляют наименьшие 

сущности, которые можно развертывать в составе системы . В Java — это jar-

файлы . В Ruby — gem-файлы . В  .Net — библиотеки DLL . В компилирующих 

языках — комплексы двоичных файлов . В интерпретирующих языках — 

комплексы файлов с исходным кодом . Во всех языках — элементарная 

единица развертывания .

Компоненты могут объединяться в один выполняемый файл, собираться 

в один архив, например файл .war, или развертываться независимо, как 

отдельные плагины, загружаемые динамически, такие как файлы .jar, .dll 

или .exe . Но независимо от способа развертывания, правильно спроекти-

рованные компоненты всегда сохраняют возможность независимого раз-

вертывания и, соответственно, могут разрабатываться независимо .

Краткая история компонентов

На заре разработки программного обеспечения программисты сами опреде-

ляли организацию памяти в своих программах . В первых строках кода часто 

присутствовала инструкция origin, объявлявшая начальный адрес в памяти 

для загрузки программы .

Взгляните не следующую простую программу для PDP-8 . Она состоит 

из подпрограммы с именем GETSTR, которая принимает ввод с клавиатуры 

в виде строки и сохраняет его в буфер . В ней также имеется короткий мо-

дульный тест для проверки GETSTR .

        *200

        TLS

START,   CLA

        TAD BUFR

        JMS GETSTR

        CLA

        TAD BUFR

        JMS PUTSTR

        JMP START

BUFR,   3000

GETSTR, 0

        DCA PTR

NXTCH,  KSF

        JMP -1

        KRB

        DCA I PTR

        TAD I PTR

108   Глава 12. Компоненты

        AND K177

        ISZ PTR

        TAD MCR

        SZA

        JMP NXTCH

K177,   177

MCR,    -15

Обратите внимание на команду *200 в начале программы . Она сообщает 

компилятору, что сгенерированный им код будет загружаться в память, на-

чиная с адреса 2008 (в восьмеричной системе счисления) .

Такой способ программирования чужд современным программистам . Они 

редко задумываются, в какую область памяти будет загружаться программа . 

Но давным-давно это было одним из первых решений, которые программист 

должен был принять . В ту пору программы были неперемещаемыми .

Как осуществлялся доступ к библиотечным функциям в те дни? Это ил-

люстрирует предыдущий пример . Программисты включали исходный код 

библиотек в свои программы и компилировали их как одно целое1 . Библио-

теки хранились в исходном коде, а не в двоичном .

Проблема такого подхода в ту эпоху состояла в том, что устройства были 

медленными, а память стоила дорого, и поэтому ее объем был ограничен . 

Компиляторам требовалось выполнить несколько проходов по исходному 

коду, но памяти было недостаточно, чтобы уместить в ней весь исходный 

код . Как следствие, компилятору приходилось несколько раз читать исход-

ный код, используя медленные устройства .

Это требовало много времени, и чем больше была библиотека, тем дольше 

работал компилятор . Компиляция большой программы могла длиться часами .

Чтобы сократить время компиляции, программисты отделяли исходный 

код библиотек от приложений . Компилировали эти библиотеки отдельно 

и загружали готовый двоичный код в известный адрес — например, 20008 . 

Они создавали таблицу символов для библиотеки и компилировали ее со 

своим прикладным кодом . Когда им требовалось запустить приложение, 

они загружали двоичный код библиотеки2, а затем загружали приложение . 

Память была организована, как показано на рис . 12 .1 .

1 Мой первый работодатель хранил в шкафу несколько десятков колод перфокарт 

с исходным кодом библиотек подпрограмм . Когда кто-то писал новую программу, он 

просто брал требуемую колоду и добавлял ее в конец колоды со своей программой .

2 В действительности на многих старых ЭВМ использовалась энергонезависимая опе-

ративная память, которая не очищалась при выключении питания . Поэтому мы часто 

в течение нескольких дней использовали библиотеку, загруженную однажды .

Краткая история компонентов      109

Приложение

Библиотека функций

Рис. 12.1. Организация памяти на заре программирования

Такой прием прекрасно работал, пока приложение умещалось в объем между 

адресами 00008 и 17778 . Но если размер приложения оказывался больше от-

веденного адресного пространства, программисту приходилось разбивать 

программу на два сегмента, располагавшихся по обеим сторонам сегмента 

с библиотекой (рис . 12 .2) .

Приложение...

...Приложение

Библиотека функций

Рис. 12.2. Деление приложения на два сегмента

Очевидно, что так не могло продолжаться вечно . Добавляя новые функции 

в библиотеку, программисты выходили за границы объема, отведенного для 

110   Глава 12. Компоненты

нее, и были вынуждены выделять дополнительный сегмент (в этом при-

мере начинающийся с адреса 70008) . Такое фрагментирование программ 

и библио тек продолжалось с увеличением объемов памяти в компьютерах .

Совершенно понятно, что с этим нужно было что-то делать .

Перемещаемость

Решение проблемы было найдено в создании перемещаемого двоичного 

кода . Идея была проста . Компилятор изменили так, чтобы он производил 

двоичный код, который мог перемещаться в памяти специальным загрузчи-

ком . Этому загрузчику можно было сообщить, с какого адреса тот должен 

загрузить перемещаемый код . Код снабжался флагами, сообщающими 

загрузчику, какие части загружаемых данных нужно изменить, чтобы за-

грузить в выбранный адрес . Обычно это означало простое добавление на-

чального адреса к любым ссылкам в двоичном коде .

Теперь программист мог указать загрузчику начальный адрес для загруз-

ки библиотеки и адрес для загрузки приложения . Фактически загрузчик 

мог принять несколько фрагментов двоичного кода и просто загрузить их 

в память друг за другом, корректируя адреса ссылок в них . Это позволило 

программистам загружать только необходимые функции .

В компилятор также была встроена возможность, позволяющая генериро-

вать имена функций в виде метаданных . Если программа вызывала библио-

течную функцию, компилятор определял ее имя как внешнюю ссылку . Если 

программа объявляла библиотечную функцию, компилятор определял ее 

имя как внешнее определение . После этого, зная адреса загрузки функций, 

загрузчик связывал внешние ссылки с внешними определениями .

Так родился связывающий загрузчик .

Компоновщики

Связывающий загрузчик дал программистам возможность делить свои 

программы на сегменты, компилируемые и загружаемые по отдельности . 

Такое решение оставалось жизнеспособным, пока относительно небольшие 

программы компоновались с относительно небольшими библиотеками . 

Однако в конце 1960-х — начале 1970-х годов программисты стали более 

честолюбивыми и их программы значительно выросли в размерах .

Компоновщики      111

В результате связывающий загрузчик оказался слишком медлительным . 

Библиотеки хранились на устройствах с медленным доступом, таких как 

накопители на магнитной ленте . Даже дисковые устройства в ту пору были 

слишком медленными . Связывающие загрузчики должны были читать 

с этих медленных устройств десятки, а то и сотни библиотек в двоичном 

коде и корректировать внешние ссылки . С увеличением размеров программ 

и количества функций в библиотеках связывающему загрузчику часто тре-

бовалось больше часа, чтобы загрузить программу .

В конечном итоге загрузка и компоновка (связывание) были разделены на 

два отдельных этапа . Программисты выделили самый медленный этап — 

этап компоновки (связывания) — в отдельное приложение, получившее 

название компоновщик, или редактор связей (linker) . В результате работы 

компоновщика получался скомпонованный и перемещаемый двоичный код, 

который загружался загрузчиком очень быстро . Это позволило програм-

мистам создавать выполняемый код, используя медленный компоновщик, 

который можно было быстро загрузить в любой момент .

Затем наступили 1980-е годы . Программисты писали программы на высоко-

уровневых языках, таких как C . С ростом их амбиций росли и создаваемые 

ими программы . Программы с сотнями и тысячами строк кода стали обыч-

ным делом .

Модули с исходным кодом в файлах .c компилировались в файлы .o и затем 

передавались компоновщику для создания выполняемых файлов, которые 

можно было быстро загрузить . Компиляция каждого отдельного модуля 

выполнялась относительно быстро, но компиляция всех модулей порой тре-

бовала значительного времени . Для корректировки связей компоновщику 

могло потребоваться еще больше времени . Во многих случаях длительность 

этого процесса снова стала достигать часа и даже больше .

Казалось, что программисты обречены всю жизнь ходить по кругу . Все 

усилия, сделанные в 1960-х, 1970-х и 1980-х годах для достижения высокой 

скорости рабочего процесса, пошли прахом из-за амбиций программистов, 

создававших большие программы . Казалось, нет выхода из замкнутого 

круга многочасового ожидания . Этап загрузки выполнялся быстро, но этап 

</p>
   </article>
</body>
</html>
