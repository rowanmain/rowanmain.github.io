<!DOCTYPE html>
<html>
<head>
   <title>Моя статья</title>
   <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<style>
body {
   background-color: #f0f0f0;
   font-family: Arial, sans-serif;
}

header {
   background-color: #333;
   color: white;
   padding: 10px;
   text-align: center;
}

h1 {
   margin: 0;
}

article {
   margin: 20px;
}

h2 {
   color: #333;
}

p {
   line-height: 1.6;
}
</style>
<body>
   <header>
       <h1>статья</h1>
   </header>
   <article>
       <p>
Обратите внимание на стрелки, исходящие из класса DatabaseAccess . Они 

обе выходят из класса DatabaseAccess, а это значит, что никакой другой класс 

не знает о существовании DatabaseAccess .

174   Глава 17. Границы: проведение разделяющих линий

Теперь отступим на шаг назад и рассмотрим компонент с несколькими 

бизнес-правилами и компонент с базой данных и всеми необходимыми 

классами доступа (рис . 17 .3) .

Рис. 17.3. Компоненты с бизнес-правилами и базой данных

Обратите внимание на направление стрелки . Компонент Database знает 

о существовании компонента BusinessRules . Компонент BusinessRules не 

знает о существовании компонента Database . Это говорит о том, что интер-

фейсы DatabaseInterface находятся в компоненте BusinessRules, а классы 

DatabaseAccess — в компоненте Database .

Направление этой стрелки важно . Оно показывает, что компонент Database 

не имеет значения для BusinessRules, но Database не может существовать 

без BusinessRules .

Если вам это кажется странным, просто вспомните, что компонент Database 

содержит код, транслирующий вызовы, выполняемые компонентом 

BusinessRules, на язык запросов базы данных . Именно этот транслирующий 

код знает о существовании BusinessRules .

Проведя границу между двумя компонентами и направив стрелку в сторону 

BusinessRules, мы видим, что компонент BusinessRules мог бы использовать 

базу данных любого типа . Компонент Database можно заменить самыми 

разными реализациями — для BusinessRules это совершенно неважно .

Хранение данных можно организовать в базе данных Oracle, MySQL, Couch, 

Datomic или даже в простых файлах . Для бизнес-правил это совершенно 

неважно . А это означает, что выбор базы данных можно отложить и сосре-

доточиться на реализации и тестировании бизнес-правил .

О вводе и выводе      175

О вводе и выводе

Разработчики и клиенты часто неправильно понимают, что такое система . 

Они видят графический интерфейс и думают, что он и есть система . Они 

определяют систему в терминах графического интерфейса и считают, что 

должны сразу начать работу с графическим интерфейсом . Они не понимают 

важнейшего принципа: ввод/вывод не важен.

В первый момент это может быть трудно понять . Мы часто рассуждаем о по-

ведении системы в терминах ввода/вывода . Возьмем, например, видеоигру . 

В вашем представлении наверняка доминирует интерфейс: экран, мышь, 

управляющие клавиши и звуки . Вы забываете, что за этим интерфейсом на-

ходится модель — сложный комплекс структур данных и функций, — управ-

ляющая им . Что еще важнее, эта модель не нуждается в интерфейсе . Она 

благополучно будет решать свои задачи, моделируя все игровые события 

даже без отображения игры на экране . Интерфейс не важен для модели — 

для бизнес-правил .

И снова мы видим, что компоненты GUI и BusinessRules разделены грани-

цей (рис . 17 .4) . И снова мы видим, что менее важный компонент зависит от 

более важного компонента . Стрелки показывают, какой компонент знает 

о существовании другого и, соответственно, какой компонент зависит от 

другого . Компонент GUI зависит от BusinessRules .

Рис. 17.4. Граница между компонентами GUI и BusinessRules

Проведя границу и нарисовав стрелку, мы теперь видим, что GUI можно 

заменить интерфейсом какого-то другого вида — для BusinessRules это не 

важно .

176   Глава 17. Границы: проведение разделяющих линий

Архитектура с плагинами

Вместе эти два решения о базе данных и графическом интерфейсе образу-

ют шаблон для добавления других компонентов . Это тот же шаблон, что 

используется в системах, допускающих подключение сторонних сменных 

модулей — плагинов .

Фактически история технологий разработки программного обеспечения — 

это история создания плагинов для получения масштабируемой и управ-

ляемой архитектуры . Основные бизнес-правила хранятся отдельно и не 

зависят от компонентов, которые являются необязательными или могут 

быть реализованы в множестве разных форм (рис . 17 .5) .

Рис. 17.5. Подключение модулей к бизнес-правилам

Так как в таком дизайне пользовательский интерфейс считается плагином, 

мы можем позволить подключать множество разных пользовательских 

интерфейсов . Это могут быть веб-интерфейсы, интерфейсы клиент/сервер, 

интерфейсы служб, консольные интерфейсы или основанные на других 

способах взаимодействия с пользователем .

То же верно в отношении базы данных . Решив считать ее плагином, мы мо-

жем заменить ее любой базой данных SQL или NOSQL, простыми файлами 

или любыми другими технологиями хранения данных, которые мы сочтем 

необходимыми в будущем .

Такие замены осуществляются не всегда просто . Если первоначально систе-

ма опиралась на веб-интерфейс, создание плагина для интерфейса клиент/

сервер может оказаться сложной задачей . Вполне вероятно, что придется 

Аргумент в пользу плагинов      177

переделать какие-то взаимодействия между бизнес-правилами и новым 

пользовательским интерфейсом . И все же, допустив существование архи-

тектуры со сменными модулями (плагинами), мы сделали подобную замену 

практически возможной .

Аргумент в пользу плагинов

Рассмотрим отношения между ReSharper и Visual Studio . Эти компоненты 

производятся совершенно разными коллективами разработчиков в совер-

шенно разных компаниях . И действительно, компания JetBrains, создатель 

ReSharper, находится в России . Компания Microsoft, конечно, находится 

в Редмонде, штат Вашингтон, США . Трудно представить себе более разные 

команды разработчиков .

Какая команда может помешать другой? Какая команда защищена от 

влияния другой? Структура зависимости четко отвечает на оба вопро-

са (рис . 17 .6) . Исходный код ReSharper зависит от исходного кода Visual 

Studio . То есть команда ReSharper никак не сможет помешать команде Visual 

Studio . Но команда Visual Studio может полностью заблокировать команду 

ReSharper, если пожелает .

Это крайне асимметричное отношение, и именно его желательно воспро-

изводить в своих системах . Некоторые модули должны иметь абсолютную 

Рис. 17.6. ReSharper зависит от Visual Studio

178   Глава 17. Границы: проведение разделяющих линий

защиту от влияния других . Например, работа бизнес-правил не должна на-

</p>
   </article>
</body>
</html>
