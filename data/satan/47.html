<!DOCTYPE html>
<html>
<head>
   <title>Моя статья</title>
   <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<style>
body {
   background-color: #f0f0f0;
   font-family: Arial, sans-serif;
}

header {
   background-color: #333;
   color: white;
   padding: 10px;
   text-align: center;
}

h1 {
   margin: 0;
}

article {
   margin: 20px;
}

h2 {
   color: #333;
}

p {
   line-height: 1.6;
}
</style>
<body>
   <header>
       <h1>статья</h1>
   </header>
   <article>
       <p>
и P не стала исключением . Клиенты компании P настойчиво требовали 

написать версию продукта для Веб . Чтобы удовлетворить это требование, 

компания наняла двадцать с лишним крутых программистов на Java и при-

ступила к проектированию веб-версии своего продукта .

168   Глава 17. Границы: проведение разделяющих линий

Парни грезили о фермах серверов, поэтому решили выбрать богатую трех-

уровневую «архитектуру»1, которую они могли бы развернуть на такой 

ферме . Они предполагали, что у них будут отдельные серверы для об-

служивания интерфейса с пользователем, серверы для промежуточного 

программного обеспечения и серверы для баз данных . Но красиво было на 

бумаге, да забыли про овраги .

Программисты слишком рано решили, что все предметные объекты должны 

иметь по три экземпляра: один для уровня графического интерфейса, один 

для промежуточного уровня и один для уровня базы данных . Так как все эти 

экземпляры находились на разных серверах, была создана разветвленная 

система взаимодействий между процессами и уровнями . Вызовы методов 

между уровнями преобразовывались в объекты, которые подвергались се-

риализации и передавались по сети .

Теперь представьте, во что выливается простое изменение, такое как добав-

ление нового поля в существующую запись . Поле нужно добавить в классы 

на всех трех уровнях, а также в некоторые сообщения, циркулирующие 

между уровнями . Так как передача данных происходит в обоих направле-

ниях, необходимо спроектировать четыре протокола обмена сообщениями . 

Каждый протокол имеет отправляющую и принимающую стороны, итого 

необходимо реализовать восемь обработчиков протоколов . Нужно собрать 

три выполняемых файла, в каждом из которых находятся три измененных 

бизнес-объекта, четыре новых сообщения и восемь новых обработчиков .

А теперь задумайтесь, что все эти выполняемые файлы должны делать, 

чтобы выполнить простейшее действие . Они создают экземпляры объектов, 

выполняют их сериализацию, маршалинг и демаршалинг, конструируют 

и анализируют сообщения, выполняют операции с сокетами, обрабатывают 

тайм-ауты и производят повторные попытки и много чего еще только ради 

выполнения одной простой операции .

Конечно, во время разработки у программистов не было фермы серверов . 

В действительности они просто запускали все три выполняемых файла 

в трех разных процессах на одной машине . Так они развивали проект в тече-

ние нескольких лет, но были уверены, что их архитектура правильная . И по-

этому даже когда система выполнялась на одной машине, она по-прежнему 

продолжала создавать объекты, выполнять их сериализацию, маршалинг 

и демаршалинг, конструировать и анализировать сообщения, оперировать 

сокетами и много чего еще, ненужного на одной машине .

1 Слово «архитектура» взято в кавычки, потому что трехуровневая архитектура в дей-

ствительности не является архитектурой — это топология . Вот вам яркий пример 

решения, принятие которого хорошая архитектура стремится отложить .

Пара печальных историй      169

По иронии ни одна из систем, проданных компанией P, не требовала фермы 

серверов . Все системы, когда-либо развертывавшиеся компанией, размеща-

лись на единственном сервере . И на этом единственном сервере три выпол-

няемых файла продолжали создавать объекты, выполнять их сериализацию, 

маршалинг и демаршалинг, конструировать и анализировать сообщения, 

оперировать сокетами и много чего еще в ожидании фермы серверов, кото-

рая никогда не существовала и никогда не будет существовать .

Трагедия в том, что архитекторы, приняв преждевременное решение, чрез-

мерно увеличили трудозатраты на разработку .

История с компанией P не единственная . Я наблюдал нечто подобное много 

раз и во многих местах . Фактически компания P является лишь одним из 

примеров .

Но есть еще более печальные примеры, чем пример компании P .

Представьте себе компанию W, местное предприятие, управляющее парками 

служебных автомобилей . Недавно они наняли «Архитектора», чтобы взять 

под контроль разрозненные усилия по разработке программного обеспече-

ния . И, хочу вам сообщить, «Контроль» — это второе имя того парня . Он 

быстро решил, что требуется создать полномасштабную, корпоративную, 

сервис-ориентированную «АРХИТЕКТУРУ» . Он создал гигантскую пред-

метную модель всех возможных «бизнес-объектов», спроектировал набор 

служб для управления этими объектами и направил разработчиков по пути 

в Ад . Чтобы было понятнее, представьте, что вам понадобилось добавить 

имя, адрес и номер телефона контактного лица в запись о продаже . Для это-

го нужно обратиться в ServiceRegistry, запросить идентификатор службы 

ContactService . Затем послать сообщение CreateContact в ContactService . 

Конечно, это сообщение имеет десятки полей, каждое из которых должно 

содержать достоверные данные — данные, к которым у программиста не 

было доступа, потому что программист имел только имя, адрес и номер 

телефона . После заполнения полей ложными данными программист должен 

был вставить идентификатор вновь созданного контакта в запись и послать 

сообщение UpdateContact службе SaleRecordService .

Чтобы протестировать все это, нужно по порядку запустить все необходи-

мые службы, поднять шину сообщений и сервер BPel и . . . И затем все эти 

сообщения перемещались от службы к службе и ждали обработки то в одной 

очереди, то в другой .

Чтобы добавить что-то новое, представьте только зависимости между всеми 

этими службами и объем кода WSDL, который нужно изменить, а потом 

повторно развернуть модули, в которые были внесены изменения . . .

170   Глава 17. Границы: проведение разделяющих линий

В сравнении с этим ад начинает казаться не таким плохим местом .

В программной системе, организованной в виде набора служб, нет ничего 

принципиально неправильного . Ошибка компании W заключалась в пре-

ждевременном решении внедрить комплекс инструментов для поддержки 

SOA — то есть массивного набора служб для работы с предметными объ-

ектами . За эту ошибку пришлось заплатить человеко-часами — большим 

количеством человеко-часов, — сброшенными с вершины SOA .

Я мог бы описывать архитектурные провалы один за другим . Но давайте 

лучше поговорим об успешных примерах .

FitNesse

Мой сын Майка и я начали работу над проектом FitNesse в 2001 году . Мы 

намеревались создать простую вики-страницу, обертывающую инструмент 

FIT Уорда Каннингема для разработки приемочных тестов .

Это было еще до того, как в Maven «решили» проблему jar-файла . Я был 

абсолютно уверен: все, что мы производим, не должно вынуждать людей за-

гружать больше одного jar-файла . Я назвал это правило «Загрузи и вперед» . 

</p>
   </article>
</body>
</html>
