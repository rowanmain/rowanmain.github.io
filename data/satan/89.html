<!DOCTYPE html>
<html>
<head>
   <title>Моя статья</title>
   <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<style>
body {
   background-color: #f0f0f0;
   font-family: Arial, sans-serif;
}

header {
   background-color: #333;
   color: white;
   padding: 10px;
   text-align: center;
}

h1 {
   margin: 0;
}

article {
   margin: 20px;
}

h2 {
   color: #333;
}

p {
   line-height: 1.6;
}
</style>
<body>
   <header>
       <h1>статья</h1>
   </header>
   <article>
       <p>
предметно-ориентированного языка с такими командами, как «DIAL XXXX» 

или «MEASURE».

Загрузка M365 осуществлялась с магнитной ленты. Накопители на магнитной 

ленте были дорогими и не очень надежными, особенно в промышленном окру-

жении телефонных станций. Кроме того, сама машина M365 стоила довольно 

дорого в сравнении с остальной электроникой в компьютерах COLT. Поэтому 

мы приступили к реализации проекта по замене M365 микрокомпьютером на 

базе микропроцессора 8085.

Новый компьютер состоял из процессорной платы с микропроцессором 8085, 

платы ОЗУ с 32 Кбайт памяти и трех плат с ПЗУ, содержащих 12 Кбайт памяти, 

доступной только для чтения. Все эти платы помещались в шасси с измеритель-

ным оборудованием, благодаря чему можно было убрать громоздкое шасси, 

в котором размещалась ЭВМ M365.

Платы ПЗУ содержали по 12 микросхем Intel 2708 EPROM (Erasable 

Programmable Read-Only Memory — стираемое программируемое постоянное 

запоминающее устройство, СППЗУ)1. На рис. П.8 показано, как выглядела такая 

микросхема. Мы записывали программы в эти микросхемы, вставляя их в спе-

циальное устройство, которое назвалось программатором ППЗУ и управлялось 

нашей средой разработки. Информацию на микросхемах можно было стирать, 

подвергая их облучению ультрафиолетовым светом большой интенсивности2.

Мой друг и я занялись переводом программ для COLT с языка ассемблера 

M365 на язык ассемблера 8085. Перевод выполнялся вручную и занял почти 

6 месяцев. В результате получилось около 30 Кбайт кода 8085.

Наша среда разработки имела 64 Кбайт ОЗУ и не имела ПЗУ, поэтому скомпи-

лированный двоичный код мы могли быстро загрузить в ОЗУ и протестировать.

Получив работоспособную программу, мы переключались на использование 

СППЗУ (EPROM). Мы программировали 30 микросхем и вставляли их в со-

1 Да, я понимаю, что это оксюморон.

2 Для этого в микросхемах имелись прозрачные пластиковые окошки, через которые 

можно было видеть кремниевые кристаллы внутри и стирать данные ультрафиолетом.

320   Приложение. Архитектурная археология

ответствующие гнезда в трех платах ПЗУ. Каждая микросхема подписывалась, 

поэтому мы точно знали, какую из них в какое гнездо нужно вставить.

30 Кбайт программного кода — это был единый двоичный блок длиной 30 Кбайт. 

Чтобы записать этот код в микросхемы ПЗУ, мы просто делили двоичный образ 

на 30 сегментов по 1 Кбайт и записывали каждый сегмент в микросхему с соот-

ветствующей надписью.

Рис. П.8. Микросхема СППЗУ (EPROM)

Эта схема прекрасно работала, и мы начали массовое производство оборудова-

ния и развертывание системы в поле.

Но программное обеспечение в первую очередь является программным1. Тре-

бовалось добавлять новые возможности, исправлять ошибки. А так как базовая 

система разрасталась, логистика обновления программного обеспечения путем 

программирования 30 микросхем на каждый экземпляр и замены всех 30 микро-

схем в каждом офисе превращалась в кошмар.

Возможны были все виды проблем. Иногда микросхемы подписывались не-

правильно или наклейки с подписями отваливались. Иногда инженер службы 

эксплуатации мог по ошибке заменить не ту микросхему или поломать один из 

выводов новой микросхемы. Как следствие, инженерам приходилось носить 

с собой все 30 микросхем.

1 Да, я знаю, что после записи программного обеспечения в ПЗУ оно превращается 

в микропрограмму, но микропрограмма не перестает быть программным обеспечением.

4-TEL   321

Зачем менять все 30 микросхем? Каждый раз, когда добавлялся или удалялся 

код из 30-килобайтного блока выполняемого кода, изменялись адреса всех 

машинных инструкций. Изменялись также адреса подпрограмм и функций. То 

есть затрагивалась каждая микросхема, каким бы простым ни было изменение.

Однажды ко мне зашел мой начальник и попросил решить эту проблему. Он 

сказал, что нужно найти какой-то способ изменения микропрограммы без 

замены всех 30 микросхем ПЗУ. Мы в коллективе обсудили эту проблему 

и приступили к проекту «Векторизация». На его реализацию ушло 3 месяца.

Идея была до смешного простой. Мы разбили 30 Кбайт программного кода на 

32 файла с исходным кодом, компилирующихся независимо в блоки меньше одно-

го 1 Кбайт. В начало каждого файла с исходным кодом мы вставили инструкцию, 

сообщающую компилятору, в какой адрес должен компилироваться данный код 

(например, ORG C400 для микросхемы ПЗУ, вставляемой в гнездо C4).

Также в начало каждого файла с исходным кодом мы добавили структуру 

фиксированного размера с адресами всех подпрограмм в этом блоке (вектор 

переходов). Эта структура имела размер 40 байт, поэтому могла хранить до 

20 адресов. Это означало, что блок для одной микросхемы не мог содержать 

более 20 подпрограмм.

Затем мы создали особую область в ОЗУ, которую называли массивом векто-

ров. Она содержала 32 таблицы по 40 байт — достаточный объем для хранения 

указателей на начало каждого блока в отдельных микросхемах.

Наконец, мы заменили вызовы подпрограмм в каждом блоке косвенными вы-

зовами через соответствующий вектор в ОЗУ.

Когда происходила загрузка программы, в массив векторов в ОЗУ загружались 

векторы переходов из всех микросхем ПЗУ, а затем осуществлялся переход 

в точку запуска главной программы.

У нас все получилось. Теперь, когда исправлялась ошибка или добавлялось что-

то новое, мы могли перекомпилировать только один или два файла, записать их 

на соответствующие микросхемы и передать только эти микросхемы инженеру 

службы эксплуатации для замены.

Мы сделали блоки кода независимо развертываемыми. Мы изобрели полиморф-

ную диспетчеризацию. Мы изобрели объекты.

Это была архитектура с подключаемыми модулями (плагинами). Мы подклю-

чали микросхемы. Мы разработали ее так, чтобы новые возможности можно 

было включать в наши продукты установкой микросхем с этими возможностями 

в соответствующие гнезда. Управляющее меню появлялось автоматически, и так 

же автоматически происходила привязка новых возможностей к приложению.

Конечно, тогда мы не знали о принципах объектно-ориентированного програм-

мирования и также ничего не знали об отделении пользовательского интерфейса 

322   Приложение. Архитектурная археология

от бизнес-правил. Но кое-какие основы были заложены, и они здорово нам 

помогли.

Описанный подход дал одно неожиданное преимущество: мы получили воз-

можность обновлять микропрограмму через модемное соединение. Обнаружив 

ошибку, мы могли через модемное соединение связаться с устройством и посред-

ством специальной программы-монитора изменить вектор в ОЗУ, ссылающийся 

на подпрограмму с ошибкой, подставив адрес в пустой области ОЗУ, и затем 

</p>
   </article>
</body>
</html>
