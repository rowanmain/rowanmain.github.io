<!DOCTYPE html>
<html>
<head>
   <title>Моя статья</title>
   <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<style>
body {
   background-color: #f0f0f0;
   font-family: Arial, sans-serif;
}

header {
   background-color: #333;
   color: white;
   padding: 10px;
   text-align: center;
}

h1 {
   margin: 0;
}

article {
   margin: 20px;
}

h2 {
   color: #333;
}

p {
   line-height: 1.6;
}
</style>
<body>
   <header>
       <h1>статья</h1>
   </header>
   <article>
       <p>
сокетов или разделяемой памяти . Важно отметить, что в этом случае 

разделенные компоненты находятся в независимых единицах раз-

вертывания, таких как jar-, gem-файлы или динамически загружаемые 

библиотеки .

 

� Уровень служб . Мы можем ограничить зависимости до уровня структур 

данных и взаимодействовать, обмениваясь исключительно сетевыми 

пакетами, чтобы каждая единица выполнения была по-настоящему не-

зависимой от изменений в исходном и двоичном коде в других (как, на-

пример, службы и микрослужбы) .

Какой режим лучше?

Ответ заключается в следующем: на ранних этапах разработки проекта 

трудно понять, какой режим лучше . В действительности по мере взросления 

проекта оптимальный режим может изменяться .

Например, нетрудно представить, что система, вполне комфортно чув-

ствовавшая себя на одном сервере, может разрастись до масштабов, когда 

164   Глава 16. Независимость

удобнее перенести некоторые ее компоненты на отдельные серверы . Пока 

система действует на одном сервере, разделения на уровне исходного кода 

может быть вполне достаточно . Но позднее может понадобиться разделить 

ее на единицы развертывания или даже на службы .

Одно из решений (набирающее популярность в наши дни) заключается 

в изначальном разделении на службы . Однако такой подход дорог и спо-

собствует разделению на слишком крупные блоки . Какими бы «микро» ни 

получились микрослужбы, маловероятно, что разделение будет выполнено 

на достаточно мелкие блоки .

Еще одна проблема разделения на службы — дороговизна, и в отношении 

разработки, и в отношении системных ресурсов . Для преодоления границ 

между службами, когда в действительности в них нет необходимости, тре-

буются дополнительные усилия, память и машинные такты . И да, я помню, 

что последние два дешевы, но первое — нет .

Я предпочитаю доводить деление до того состояния, когда при необходи-

мости легко можно сформировать отдельные службы, но оставлять компо-

ненты в общем адресном пространстве до тех пор, пока это возможно . Это 

оставляет открытой возможность организации служб .

При таком подходе компоненты первоначально разделяются на уровне 

исходного кода . Этого может оказаться достаточно для продолжительного 

развития проекта . Если возникают проблемы с развертыванием или разра-

боткой, разделения до уровня развертывания может быть достаточно — по 

крайней мере на какое-то время .

По мере накопления проблем с разработкой, развертыванием и эффек-

тивной работой я тщательно отбираю единицы развертывания, которые 

можно преобразовать в службы, и постепенно двигаю систему в этом на-

правлении .

Со временем требования к эффективности работы могут снижаться . И для 

системы, прежде требовавшей разделения до уровня служб, теперь может 

оказаться достаточно разделения до уровня развертывания или даже ис-

ходного кода .

Хорошая архитектура позволит создать монолитную систему, развертывае-

мую как один файл, а затем превратить ее в набор независимых единиц раз-

вертывания и далее в независимые службы и/или микрослужбы . Позднее, 

когда что-то изменится, она должна позволить обратить все вспять и вновь 

вернуться к монолитной структуре .

Заключение      165

Хорошая архитектура защищает большую часть исходного кода от таких из-

менений . Она оставляет режим разделения открытым, поэтому для крупно-

масштабных вариантов развертывания может использоваться один режим, 

а для мелкомасштабных — другой .

Заключение

Да, все это непросто . Впрочем, я и не говорю, что изменение режимов раз-

деления должно сводиться к тривиальным изменениям в конфигурации 

(хотя иногда такое возможно) . Я говорю, что режим разделения системы 

на компоненты относится к числу вариантов, которые, скорее всего, будут 

изменяться со временем, и хороший архитектор должен предвидеть такие 

изменения и стремиться к упрощению .

17

Границы: проведение 

разделяющих линий

Пара печальных историй      167

Разработка архитектуры программного обеспечения — это искусство про-

ведения разделяющих линий, которые я называю границами . Границы от-

деляют программные элементы друг от друга и избавляют их от необходи-

мости знать, что находится по ту сторону . Некоторые из этих линий можно 

провести на самых ранних этапах развития проекта — даже до появления 

первого программного кода . Другие проводятся намного позже . Границы, 

проводимые на ранних этапах, призваны отложить принятие решений на как 

можно долгий срок и предотвратить загрязнение основной бизнес-логики 

этими решениями .

Напомню, что целью архитектора является минимизация трудозатрат на 

создание и сопровождение системы . Что может помешать достижению 

этой цели? Зависимость — и особенно зависимость от преждевременных 

решений .

Какие решения можно назвать преждевременными? Решения, не имеющие 

ничего общего с бизнес-требованиями — вариантами использования — 

системы . К ним можно отнести решения о выборе фреймворка, базы 

данных, веб-сервера, вспомогательных библиотек, механизма внедрения 

зависимостей и т . п . В хорошей архитектуре подобные решения носят вспо-

могательный характер и откладываются на потом . Хорошая архитектура 

не зависит от таких решений . Хорошая архитектура позволяет принимать 

эти решения в самый последний момент без существенного влияния на 

саму архитектуру .

Пара печальных историй

Расскажу одну печальную историю о компании P, которая послужит преду-

преждением всем, кто торопится принимать решения . В 1980-х годах осно-

ватели компании P написали простое монолитное приложение для настоль-

ного компьютера . Оно пользовалось большим успехом, и в 1990-е годы этот 

продукт превратили в по пулярное и успешное приложение с графическим 

интерфейсом .

Но потом, в конце 1990-х годов, началось бурное развитие Всемирной пау-

тины . Многие внезапно решили, что у них должны быть свои веб-решения, 

</p>
   </article>
</body>
</html>
