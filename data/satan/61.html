<!DOCTYPE html>
<html>
<head>
   <title>Моя статья</title>
   <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<style>
body {
   background-color: #f0f0f0;
   font-family: Arial, sans-serif;
}

header {
   background-color: #333;
   color: white;
   padding: 10px;
   text-align: center;
}

h1 {
   margin: 0;
}

article {
   margin: 20px;
}

h2 {
   color: #333;
}

p {
   line-height: 1.6;
}
</style>
<body>
   <header>
       <h1>статья</h1>
   </header>
   <article>
       <p>
Рис. 25.1. Одни и те же игровые правила могут использоваться любым числом 

компонентов пользовательского интерфейса

Игровые правила не должны ничего знать о разных видах хранилищ, по-

этому зависимости должны быть направлены в соответствии с правилом 

зависимостей, как показано на рис . 25 .2 .

Английский

интерфейс

Испанский

интерфейс

Правила игры

Данные

на флешке

Данные

в облаке

Рис. 25.2. Следование правилу зависимостей

Чистая архитектура?

Очевидно, что в этом контексте мы легко смогли бы применить приемы соз-

дания чистой архитектуры1 со всеми вариантами использования, границами, 

сущностями и соответствующими структурами данных . Но действительно 

ли мы нашли все важнейшие архитектурные границы?

Например, язык не является единственной осью изменения для пользо-

вательского интерфейса . Также может измениться механизм ввода текста . 

Например, мы можем использовать обычное окно командной оболочки, 

текстовые сообщения или приложение чата . Возможности в этом плане 

бесчисленны .

1 Также должно быть ясно, что мы не будем применять приемы создания чистой архи-

тектуры для таких тривиальных программ, как эта игра . В конце концов, программу 

целиком можно уместить в 200 строк кода и даже меньше . В этом случае мы исполь-

зуем простую программу как прокси для более крупной системы со значимыми архи-

тектурными границами .

222   Глава 25. Уровни и границы

Это означает, что существует потенциальная архитектурная граница, опре-

деляемая этой осью изменения . Возможно, нам следует сконструировать 

API, пересекающий границу и отделяющий язык от механизма ввода; эта 

идея показана на рис . 25 .3 .

Рис. 25.3. Следующая версия диаграммы

Диаграмма на рис . 25 .3 стала сложнее, но не содержит никаких сюрпризов . 

Пунктиром обведены абстрактные компоненты, определяющие API, реали-

зуемый компонентами, стоящими выше или ниже их . Например, Language 

API реализуют компоненты English и Spanish .

GameRules взаимодействует с компонентом Language через API, который опре-

деляет GameRules и реализует Language . Также компонент Language взаимодей-

ствует с компонентом TextDelivery посредством API, который определяется 

в Language и реализуется в TextDelivery . Как видите, API определяется и при-

надлежит компоненту-пользователю, но не реализующему его .

Если заглянуть в GameRules, можно увидеть полиморфные пограничные ин-

терфейсы, используемые внутри GameRules и реализованные в компоненте 

Language . Имеются также полиморфные пограничные интерфейсы, исполь-

зуемые компонентом Language и реализованные в GameRules .

Заглянув в Language, мы увидели бы то же самое: полиморфные погра-

ничные интерфейсы, используемые кодом в Language и реализованные 

в TextDelivery, и полиморфные пограничные интерфейсы, используемые 

кодом в TextDelivery и реализованные в Language .

В каждом случае API определяется пограничными интерфейсами, принад-

лежащими компоненту, находящемуся уровнем выше .

Варианты, такие как English, SMS и CloudData, предоставляются полиморф-

ными интерфейсами, определяемыми в API абстрактных компонентов 

и реализуемыми конкретными компонентами, которые обслуживают их . 

Чистая архитектура?      223

Например, предполагается, что полиморфные интерфейсы, объявленные 

в Language, будут реализованы в English и Spanish .

Эту диаграмму можно упростить, устранив все варианты и сосредоточив-

шись исключительно на API компонентов, как показано на рис . 25 .4 .

Рис. 25.4. Упрощенная диаграмма

Обратите внимание, что диаграмма на рис . 25 .4 ориентирована так, чтобы 

все стрелки указывали вверх . В результате компонент GameRules оказался 

вверху . Такая ориентация имеет определенный смысл, потому что GameRules 

содержит политики высшего уровня .

Рассмотрим направление движения информации . Ввод от пользователя пе-

редается через компонент TextDelivery снизу слева . Она поднимается вверх 

до компонента Language, где транслируется в команды, понятные GameRules . 

GameRules обрабатывает ввод пользователя и посылает соответствующие 

данные вниз, в компонент DataStorage справа внизу .

Затем GameRules посылает ответ обратно в компонент Language, который 

переводит его на соответствующий язык и возвращает пользователю через 

компонент TextDelivery .

Такая организация эффективно делит поток данных на два потока1 . Поток 

слева соответствует взаимодействию с пользователем, а поток справа — 

1 Если вас взволновало несоответствие направлений стрелок на рис . 25 .4, напомню, что 

они соответствуют зависимостям в исходном коде, но не движению потоков данных .

224   Глава 25. Уровни и границы

с хранилищем данных . Оба потока встречаются на вершине1, в компоненте 

GameRules — конечном обработчике данных, через который проходят оба 

потока .

Пересечение потоков

Всегда ли существует только два потока данных, как в данном примере? Нет, 

не всегда . Представьте, что мы захотели реализовать сетевой вариант игры 

«Охота на Вампуса», в которой участвует несколько игроков . В этом случае 

нам потребуется сетевой компонент, как показано на рис . 25 .5 . В данном 

случае поток данных делится на три потока, управляемых компонентом 

GameRules .

Рис. 25.5. Добавление сетевого компонента

То есть с ростом сложности системы структура компонентов может разби-

ваться на несколько потоков .

Разбиение потоков

Сейчас вы наверняка подумали, что все потоки в конечном счете встреча-

ются на вершине диаграммы, в единственном компоненте . Ах, если бы все 

было так просто! Увы, действительность намного сложнее .

Рассмотрим компонент GameRules для игры «Охота на Вампуса» . Часть игро-

вых правил связана с механикой карты . Они знают, как соединены пещеры 

</p>
   </article>
</body>
</html>
