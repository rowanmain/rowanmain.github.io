<!DOCTYPE html>
<html>
<head>
   <title>Моя статья</title>
   <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<style>
body {
   background-color: #f0f0f0;
   font-family: Arial, sans-serif;
}

header {
   background-color: #333;
   color: white;
   padding: 10px;
   text-align: center;
}

h1 {
   margin: 0;
}

article {
   margin: 20px;
}

h2 {
   color: #333;
}

p {
   line-height: 1.6;
}
</style>
<body>
   <header>
       <h1>статья</h1>
   </header>
   <article>
       <p>
OrdersService и OrdersRepository должны быть объявлены общедоступными, 

потому что имеют входящие зависимости от классов, находящихся за преде-

лами пакета, в котором объявлены эти интерфейсы . Классам с реализациями 

(OrdersServiceImpl и JdbcOrdersRepository), напротив, можно придать более 

ограниченную видимость (на уровне пакета) . Никто не должен знать об их 

существовании; они являются деталями реализации .

В подходе «упаковка по особенностям» единственной точкой входа в пакет 

является OrdersController, поэтому доступ ко всему остальному можно 

ограничить рамками пакета . Важно отметить, что в такой ситуации никакой 

другой код, находящийся за пределами этого пакета, не сможет получить 

никакой информации о заказах в обход контроллера . Иногда это может 

быть нежелательно .

В подходе с портами и адаптерами интерфейсы OrdersService и Orders име-

ют входящие зависимости из других пакетов, поэтому они должны быть 

объявлены общедоступными . И снова, доступность классов реализации 

1 Например, в Java невозможно ограничить доступ на основе отношений пакетов и под-

пакетов, хотя все мы привыкли считать пакеты иерархическими структурами . Любые 

создаваемые иерархии отражаются только на именах пакетов и структуре каталогов 

на диске .

Организация и инкапсуляция      301

<<использует>>

<<использует>>

<<использует>>

<<использует>>

<<использует>>

<<использует>>

<<использует>>

<<использует>>

<<интерфейс>>

<<интерфейс>>

<<интерфейс>>

<<интерфейс>>

<<интерфейс>>

Рис. 34.8. Бледно-серым цветом выделены типы с более ограничивающим 

модификатором доступа

можно ограничить рамками пакета и внедрять зависимости во время вы-

полнения .

Наконец, в подходе «упаковка по компонентам» интерфейс OrdersCompo-

nent имеет входящую зависимость от контроллера, но доступ ко всему 

остальному можно ограничить рамками пакета . Чем меньше общедоступ-

ных типов, тем меньше число потенциальных зависимостей . В данном 

случае код за пределами этого пакета не имеет возможности1 напрямую 

использовать интерфейс OrdersRepository или его реализацию, поэтому 

соблюдение архитектурного принципа можно переложить на компиля-

тор . То же самое можно проделать в  .NET с помощью ключевого слова 

internal, но при этом придется создать отдельные сборки для всех ком-

понентов .

1 Можно, конечно, схитрить и воспользоваться механизмом рефлексии в Java, но не 

делайте так, пожалуйста!

302   Глава 34. Недостающая глава

Для большей ясности отмечу, что все, о чем рассказывалось здесь, относит-

ся к монолитному приложению, когда весь код находится в едином дереве 

исходных текстов . Если вы создаете такое приложение, я рекомендовал бы 

проводить в жизнь архитектурные принципы, опираясь на компилятор, 

а не полагаться на самодисциплину и инструменты, выполняющиеся после 

компиляции .

Другие режимы разделения

Кроме средств, поддерживаемых языком программирования, часто су-

ществуют другие способы разделения зависимостей в исходном коде . 

Для Java имеются свои инфраструктуры, такие как OSGi, и новейшая 

система модулей в Java 9 . При правильном использовании системы мо-

дулей позволяют разделить типы, объявленные как public, и публикуемые 

(published) типы . Например, можно создать модуль Orders, в котором все 

типы объявлены как public, но опубликовать только ограниченное число 

этих типов для внешних потребителей . Это долгожданное нововведение, 

и я с энтузиазмом воспринимаю появление новой системы модулей Java 9, 

которая даст нам еще один инструмент для создания хорошего программ-

ного обеспечения и вновь разбудит в людях интерес к дизайнерскому 

мышлению .

Другая возможность разделить зависимости на уровне исходного кода — 

создать несколько разных деревьев с исходным кодом . Для портов и адаптеров, 

например, можно было бы создать три таких дерева:

 

� Исходный код с предметной и бизнес-логикой (то есть все, что не зависит 

от выбора технологии и фреймворков): OrdersService, OrdersServiceImpl 

и Orders .

 

� Исходный код веб-интерфейса: OrdersController .

 

� Исходный код, реализующий хранение данных: JdbcOrdersRepository .

Последние два дерева имеют зависимости времени компиляции от кода 

с предметной и бизнес-логикой, который сам по себе ничего не знает о веб-

интерфейсе и особенностях хранения данных . С точки зрения реализации 

это можно сделать, настроив отдельные модули или проекты в конфигура-

ции инструмента сборки (например, Maven, Gradle, MSBuild) . В идеале этот 

шаблон можно применить для отделения деревьев с исходным кодом всех 

компонентов приложения .

Другие режимы разделения      303

Однако это слишком идеалистическое решение, потому что такое разбиение 

исходного кода влечет за собой проблемы производительности, сложности 

и сопровождения .

Более простой подход, используемый теми, кто реализует архитектуру пор-

тов и адаптеров, заключается в создании двух деревьев с исходным кодом:

 

� Предметный код («внутренняя» область) .

 

� Инфраструктурный код («внешняя» область) .

Его хорошо иллюстрирует диаграмма (рис . 34 .9), которую многие исполь-

зуют для обобщения архитектуры портов и адаптеров с ее зависимостью 

времени компиляции инфраструктурного кода от предметного .

</p>
   </article>
</body>
</html>
