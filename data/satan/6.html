<!DOCTYPE html>
<html>
<head>
   <title>Моя статья</title>
   <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<style>
body {
   background-color: #f0f0f0;
   font-family: Arial, sans-serif;
}

header {
   background-color: #333;
   color: white;
   padding: 10px;
   text-align: center;
}

h1 {
   margin: 0;
}

article {
   margin: 20px;
}

h2 {
   color: #333;
}

p {
   line-height: 1.6;
}
</style>
<body>
   <header>
       <h1>статья</h1>
   </header>
   <article>
       <p>
противоположном потоку управления

Даже в монолитном, статически скомпонованном выполняемом файле та-

кой вид организационного разделения значительно помогает в разработке, 

тестировании и развертывании проекта . Команды разработчиков могут 

трудиться независимо друг от друга и не наступая друг другу на пятки . 

Высокоуровневые компоненты остаются независимыми от низкоуровневых 

деталей .

Взаимодействия между компонентами в монолите протекают быстро и эф-

фективно . Обычно они сводятся к простым вызовам функций . Как след-

ствие, взаимодействия через границы, проведенные на уровне исходного 

кода, могут быть очень обширными .

Поскольку для развертывания монолита обычно требуется выполнить ком-

пиляцию и статическую компоновку, компоненты в таких системах часто 

поставляются в исходном коде .

Компоненты развертывания

Простейшим примером физического представления архитектурной грани-

цы может служить динамическая библиотека DLL в  .Net, jar-файл в Java, 

gem-файл в Ruby или разделяемая библиотека (.so) в UNIX . Развертыва-

Локальные процессы      183

ние в этом случае не связано с компиляцией — компоненты поставляются 

в двоичном виде или в иной форме, пригодной к непосредственному раз-

вертыванию . Это режим разделения на уровне развертывания . Акт развер-

тывания заключается в простой сборке единиц развертывания в удобную 

форму, например WAR-файл, или даже в обычном копировании файлов 

в каталог .

Кроме этого единственного исключения, компоненты уровня развертыва-

ния остаются теми же, что и в монолите . Все функции обычно действуют 

в одном процессе и в общем адресном пространстве . Стратегии разделения 

компонентов и управления их зависимостями не меняются1 .

Так же как в монолите, взаимодействия между границами развертываемых 

компонентов часто осуществляются посредством вызовов функций и, со-

ответственно, обходятся очень дешево . Динамическая компоновка или 

загрузка во время выполнения могут однократно увеличивать потребление 

вычислительных ресурсов, но сами взаимодействия через границы все еще 

могут быть очень обширными .

Потоки выполнения

Монолиты и компоненты развертывания могут выполняться в многопоточ-

ном режиме . Потоки выполнения не являются архитектурными границами 

или единицами развертывания, это способ организации планирования и вы-

полнения задач . Они могут вообще не выходить за рамки компонента или 

охватывать сразу несколько компонентов .

Локальные процессы

Локальные процессы представляют более надежные физические архитек-

турные границы . Обычно локальный процесс запускается из командной 

строки или с помощью эквивалентного системного вызова . Локальные про-

цессы выполняются на одном процессоре или группе процессоров (в много-

процессорной системе), но в разных адресных пространствах . Механизмы 

защиты памяти обычно не позволяют таким процессам совместно исполь-

зовать одну и ту же область памяти, хотя для взаимодействий нередко ис-

пользуются сегменты разделяемой памяти .

1 Хотя в этом случае статический полиморфизм даже нельзя рассматривать как вариант .

184   Глава 18. Анатомия границ

Чаще всего локальные процессы взаимодействуют друг с другом посред-

ством сокетов или других средств связи, поддерживаемых операционной 

системой, таких как почтовые ящики или очереди сообщений .

Каждый локальный процесс может быть статически скомпонованным моно-

литом или динамически компонуемой группой компонентов развертыва-

ния . В первом случае несколько монолитных процессов могут содержать 

одни и те же компоненты, скомпилированные и скомпонованные в них . Во 

втором — они могут совместно использовать динамически составляемые 

компоненты развертывания .

Локальный процесс можно считать своеобразным суперкомпонентом: про-

цесс состоит из низкоуровневых компонентов и управляет их зависимостя-

ми с помощью динамического полиморфизма .

Стратегия разделения между локальными процессами остается той же, что 

для монолитов и двоичных компонентов . Зависимости в исходном коде 

направлены в одну сторону через границу и всегда в сторону высокоуров-

невого компонента .

Для локальных процессов это означает, что исходный код высокоуровне-

вых процессов не должен содержать имен, физических адресов или ключей 

в реестре, соответствующих низкоуровневым процессам . Не забывайте, что 

главная архитектурная цель — сделать низкоуровневые процессы плагинами 

(сменными модулями) для высокоуровневых процессов .

Взаимодействия через границы локальных процессов связаны с обращени-

ем к системным вызовам, маршалингом и декодированием данных, а также 

переключением контекстов и обходятся умеренно дорого . Количество таких 

взаимодействий следует тщательно ограничивать .

Службы

Самыми надежными являются границы служб . Часто служба — это процесс, 

который запускается из командной строки или с помощью эквивалентного 

системного вызова . Службы не зависят от физического местоположения . 

Две взаимодействующие службы могут или не могут действовать на одном 

процессоре или группе процессоров в многопроцессорной системе . Службы 

предполагают, что все взаимодействия осуществляются по сети .

Взаимодействия через границы служб осуществляются очень медленно 

в сравнении с вызовами функций . Время между запросом и ответом может 

составлять от десятков миллисекунд до нескольких секунд . Взаимодействия 

Заключение      185

следует ограничивать по мере возможностей . Взаимодействия на этом уров-

не должны учитывать возможность больших задержек .

В остальном к службам применяются те же правила, что и к локальным 

процессам . Низкоуровневые службы должны «подключаться» к высоко-

уровневым службам . Исходный код высокоуровневых служб не должен 

содержать никакой конкретной информации (например, URI) о низко-

уровневых службах .

Заключение

Большинство систем, кроме монолитных, используют несколько стратегий 

разграничения . Система, состоящая из служб, может также иметь несколь-

ко локальных процессов . В действительности служба часто является всего 

лишь фасадом для нескольких взаимодействующих локальных процессов . 

Служба или локальный процесс чаще имеют форму монолита, составленно-

го из исходных кодов компонентов, или группы динамически подключаемых 

компонентов развертывания .

Это означает, что границы в системе часто будут представлены смесью 

локальных границ (недорогих в пересечении) и границ, страдающих за-

держками .

19 Политика и уровень

Уровень      187

Программные системы — это заявления о направлении действий . Факти-

чески любая компьютерная программа является таким заявлением . Ком-

пьютерная программа — это подробное описание политики преобразования 

входных данных в выходные .

В большинстве нетривиальных систем общую политику можно разбить на 

множество более мелких заявлений . Некоторые из этих заявлений могут 

описывать действие конкретных бизнес-правил . Другие могут определять 

оформление отчетов . А третьи — описывать порядок проверки входных 

данных .

Отчасти искусство создания программных архитектур заключается в отде-

лении этих политик друг от друга и их перегруппировке с учетом способов 

их изменения . Политики, изменяющиеся по одинаковым причинам и в одно 

время, находятся на одном уровне и принадлежат одному компоненту . По-

литики, изменяющиеся по разным причинам или в разное время, находятся 

на разных уровнях и должны помещаться в разные компоненты .

Искусство создания программных архитектур нередко связано с организа-

цией перегруппированных компонентов в ориентированный ациклический 

граф . Узлами такого графа являются компоненты, содержащие политики 

одного уровня . А ориентированными ребрами — зависимости между ком-

понентами . Они соединяют компоненты, находящиеся на разных уровнях .

К ним относятся зависимости на уровне исходного кода или времени компи-

ляции . В Java они выражаются инструкциями import . В C# — инструкциями 

using . В Ruby — инструкциями require . Все эти зависимости необходимы 

компилятору для выполнения своей работы .

В хорошей архитектуре направление этих зависимостей обусловлено уров-

нем компонентов, которые они соединяют . В любом случае низкоуровневые 

компоненты проектируются так, чтобы они зависели от высокоуровневых 

компонентов .

Уровень

Термин «уровень» имеет строгое определение: «удаленность от ввода и вы-

вода» . Чем дальше политика от ввода и вывода, тем выше ее уровень . Поли-

тики, управляющие вводом и выводом, являются самыми низкоуровневыми 

в системе .

Диаграмма потоков данных на рис . 19 .1 соответствует простой программе 

шифрования, которая читает символы из устройства ввода, преобразует 

188   Глава 19. Политика и уровень

их с использованием таблицы и записывает преобразованные символы 

в устройство вывода . Направления потоков данных показаны на диаграмме 

извилистыми сплошными стрелками . Правильно спроектированные зави-

симости в исходном коде показаны пунктирными стрелками .

Преобразование

Чтение символа

Запись символа

зависи-

мости

в исходном 

коде

символ

Таблица

символ

Рис. 19.1. Простая программа шифрования

Компонент, выполняющий преобразование, — это самый высокоуровневый 

компонент в данной системе, потому что он дальше других находится от 

ввода и вывода1 .

Обратите внимание, что потоки данных и зависимости в исходном коде не 

всегда указывают в одном направлении . Это тоже один из элементов искус-

ства создания программных архитектур . Мы должны отделить зависимости 

в исходном коде от потоков данных и связать с уровнем .

Мы легко могли бы создать неправильную архитектуру, реализовав про-

грамму так:

function encrypt() {

  while(true)

    writeChar(translate(readChar()));

}

Это неправильная архитектура, потому что высокоуровневая функция 

encrypt зависит от низкоуровневых функций readChar и writeChar .

1 Меилир Пейдж-Джонс (Meilir Page-Jones) назвал этот компонент «центральным пре-

образованием» в своей книге The Practical Guide to Structured Systems Design, 2nd ed ., 

Yourdon Press, 1988 .

Уровень      189

Более удачная архитектура для этой системы изображена на рис . 19 .2 . 

Обратите внимание на пунктирную границу, окружающую класс Encrypt, 

и интерфейсы CharWriter и CharReader . Все зависимости, пересекающие гра-

ницу, указывают внутрь . Этот модуль является элементом высшего уровня 

в системе .

Рис. 19.2. Диаграмма классов, демонстрирующая  

более удачную архитектуру для системы

На диаграмме также изображены классы ConsoleReader и ConsoleWriter . Они 

находятся на более низком уровне, потому что расположены ближе к вводу 

и выводу .

Обратите внимание, как эта структура отделяет высокоуровневую политику 

шифрования от низкоуровневых политик ввода/вывода . Это позволяет ис-

пользовать политику шифрования в широком диапазоне контекстов . Когда 

в политиках ввода и вывода происходят изменения, они никак не затраги-

вают политику шифрования .

Помните, что политики группируются в компоненты по способам из-

менения . Политики, изменяющиеся по одним причинам и в одно время, 

объединяются в соответствии с принципами единственной ответствен-

ности (SRP) и согласованного изменения (CCP) . Чем дальше политика 

от ввода и вывода, тем выше ее уровень и тем реже она изменяется и по 

более важным причинам . Чем ближе политика к вводу и выводу, тем ниже 

ее уровень и тем чаще она изменяется и по более неотложным, но менее 

важным причинам .

190   Глава 19. Политика и уровень

Например, даже в тривиальной программе шифрования вероятность изме-

нения устройств ввода/вывода намного выше, чем вероятность изменения 

алгоритма шифрования . Изменение алгоритма шифрования наверняка 

будет обусловлено более серьезной причиной, чем изменение устройств 

ввода/вывода .

Отделение политик друг от друга и организация зависимостей в исходном 

коде так, что все они направлены в сторону политик более высокого уров-

ня, уменьшает влияние изменений . Тривиальные, но срочные изменения 

на более низких уровнях системы не влияют или слабо влияют на более 

высокие уровни .

На эту проблему можно взглянуть с другой стороны, если вспомнить, что 

низкоуровневые компоненты должны быть плагинами для высокоуровне-

вых компонентов . Этот взгляд демонстрирует диаграмма компонентов на 

рис . 19 .3 . Компонент Encryption ничего не знает о компоненте IODevices; 

а компонент IODevices зависит от компонента Encryption .

Рис. 19.3. Низкоуровневые компоненты должны быть плагинами  

для высокоуровневых компонентов

Заключение

На этом этапе в обсуждение политик были вовлечены принципы единствен-

ной ответственности (SRP), открытости/закрытости (OCP), согласованного 

изменения (CCP), инверсии зависимостей (DIP), устойчивых зависимостей 

(SDP) и устойчивости абстракций (SAP) . А теперь вернитесь назад и посмо-

трите, сможете ли вы определить, где каждый из принципов используется 

и почему .

20 Бизнес-правила

192   Глава 20. Бизнес-правила

Прежде чем пытаться делить приложение на бизнес-правила и плагины, 

необходимо понять, какие бизнес-правила существуют . Как оказывается, 

их несколько видов .

Строго говоря, бизнес-правила — это правила или процедуры, делающие 

или экономящие деньги . Еще строже говоря, бизнес-правила — это правила, 

делающие или экономящие деньги независимо от наличия или отсутствия 

их реализации на компьютере . Они делают или экономят деньги, даже когда 

выполняются вручную .

Банк взимает N% за кредит — это бизнес-правило, которое приносит банку 

деньги . И неважно, имеется ли компьютерная программа, вычисляющая 

процент, или служащий вычисляет его на счетах .

Мы будем называть такие правила критическими бизнес-правилами, потому 

что они имеют решающее значение для бизнеса и будут существовать даже 

в отсутствие системы, автоматизирующей их .

Критические бизнес-правила обычно требуют каких-то данных для работы . 

Например, в случае с кредитом нужно иметь сумму остатка, процентную 

ставку и график платежей .

Мы будем называть такие данные критическими бизнес-данными . Эти дан-

ные существуют даже в отсутствие системы автоматизации .

Критические правила и критические данные неразрывно связаны друг с дру-

гом, поэтому являются отличными кандидатами на объединение в объект . 

Мы будем называть такие объекты сущностями1 .

Сущности

Сущность — это объект в компьютерной системе, воплощающий небольшой 

набор критических бизнес-правил, оперирующих критическими бизнес-дан-

ными . Объект-сущность или содержит критические бизнес-правила в себе, 

или имеет простой доступ к ним . Интерфейс сущности состоит из функций, 

реализующих критические бизнес-правила и оперирующих этими данными .

Например, на рис . 20 .1 показано, как могла бы выглядеть сущность Loan 

(представляющая банковский кредит) в виде класса на диаграмме UML . 

Она включает три фрагмента взаимосвязанных критических бизнес-данных 

и реализует интерфейс с тремя взаимосвязанными критическими бизнес-

правилами .

1 Это название предложил Ивар Якобсон (Ivar Jacobson, Object Oriented Software 

Engineering, Addison-Wesley, 1992) .

Варианты использования      193

Рис. 20.1. Сущность Loan в виде класса на диаграмме UML

Создавая такой класс, мы объединяем программную реализацию идеи, име-

ющей решающее значение для бизнеса, и отделяем ее от остальных задач 

в создаваемой нами системе автоматизации . Этот класс играет роль пред-

ставителя бизнеса . Он не зависит от выбора базы данных, пользовательского 

интерфейса или сторонних фреймворков . Он может служить целям бизнеса 

в любой системе, независимо от того, какой пользовательский интерфейс 

она имеет, как хранит данные или как организованы компьютеры в этой 

системе . Сущность — это бизнес в чистом виде и больше ничего .

Кто-то из вас, возможно, забеспокоился, когда я назвал сущность классом . 

Не волнуйтесь . Чтобы создать сущность, не требуется использовать объект-

но-ориентированный язык . Необходимо лишь связать воедино критические 

бизнес-данные с критическими бизнес-правилами и выделить их в отдель-

ный программный модуль .

Варианты использования

Не все бизнес-правила так же чисты, как сущности . Некоторые бизнес-пра-

вила делают или экономят деньги, определяя и ограничивая деятельность 

автоматизированной системы . Эти правила не могут выполняться вручную, 

потому что имеют смысл только как часть автоматизированной системы .

Например, представьте приложение, используемое служащими банка для 

оформления нового кредита . Банк может решить, что сотрудники, оформ-

ляющие кредиты, не должны предлагать график погашения кредита, пока не 

соберут и не проверят контактную информацию и не убедятся, что кандидат 

имеет кредитный балл 500 или выше . По этой причине банк может потре-

бовать, чтобы система не отображала форму с графиком платежей, пока не 

194   Глава 20. Бизнес-правила

будет заполнена и проверена форма с контактной информацией и не придет 

подтверждение, что кредитный балл клиента выше требуемого порога .

Это вариант использования1 . Вариант использования описывает способ 

использования автоматизированной системы . Он определяет, что должен 

ввести пользователь, что должно быть выведено в ответ и какие действия 

должны быть выполнены для получения выводимой информации . В отли-

чие от критических бизнес-правил внутри сущностей, вариант использова-

ния описывает бизнес-правила, характерные для конкретного приложения .

На рис . 20 .2 изображен пример варианта использования . Обратите внима-

ние, что в последней строке упоминается Клиент . Это ссылка на сущность 

Клиент, содержащую критические бизнес-правила, регулирующие отноше-

ния между банком и клиентами .

Порядок сбора информации 

для оформления кредита

Ввод: имя, адрес, дата рождения, водительские 

права, номер карты социального страхования и пр.

Вывод: Некоторая информация для обратной связи 

+ кредитный балл.

Порядок действий:

1. Принять и проверить имя.

2. Проверить адрес, дату рождения, водительские 

права, номер карты социального страхования и пр.

3. Узнать кредитный балл.

4. Если балл < 500, отклонить заявку на кредит

5. Иначе создать Клиента и активировать 

график погашения

Рис. 20.2. Пример варианта использования

Варианты использования определяют, как и когда вызываются критические 

бизнес-правила в сущности . Варианты использования управляют действи-

ями сущности .

Отмечу также, что варианты использования не описывают пользователь-

ский интерфейс, они лишь неформально определяют входные и выходные 

данные, поступающие и возвращаемые через интерфейс . По вариантам 

использования нельзя определить, является ли данная система веб-при-

1 Это название тоже было предложено Иваром Якобсоном в той же книге .

Модели запросов и ответов      195

ложением, толстым клиентом, утилитой командной строки или чистой 

службой .

Это очень важно . Варианты использования не описывают, как выглядит си-

стема для пользователя . Они описывают только конкретные правила работы 

приложения, определяющие порядок взаимодействий между пользователя-

ми и сущностями . Для вариантов использования абсолютно неважно, как 

система осуществляет ввод/вывод данных .

Вариант использования — это объект . Он имеет одну или несколько функ-

ций, реализующих конкретные прикладные бизнес-правила . Он также имеет 

элементы данных, включая входные данные, выходные данные и ссылки на 

соответствующие сущности, с которыми он взаимодействует .

Сущности не знают ничего о вариантах использования, контролирующих их . 

Это еще один пример ориентации зависимостей в соответствии с принципом 

инверсии зависимостей (Dependency Inversion Principle) . Высокоуровневые 

элементы, такие как сущности, ничего не знают о низкоуровневых элемен-

тах, таких как варианты использования . Напротив, низкоуровневые вари-

анты использования знают все о высокоуровневых сущностях .

Почему сущности относятся к высокому уровню, а варианты использования 

к низкому? Потому что варианты использования характерны для един-

ственного приложения и, соответственно, ближе к вводу и выводу системы . 

Сущности — это обобщения, которые можно использовать в множестве раз-

ных приложений, соответственно, они дальше от ввода и вывода системы . 

Варианты использования зависят от сущностей; сущности не зависят от 

вариантов использования .

Модели запросов и ответов

Варианты использования принимают входные данные и возвращают резуль-

тат . Однако в правильно сформированном объекте варианта использования 

ничто не должно говорить о способах передачи данных пользователю или 

другим компонентам . И тем более код в классе, реализующем вариант ис-

пользования, ничего не должен знать об HTML или SQL!

Класс варианта использования принимает простые структуры данных на 

входе и возвращает простые структуры данных на выходе . Эти структуры 

данных ни от чего не зависят . Они не связаны со стандартными интерфейса-

ми фреймворков, такими как HttpRequest и HttpResponse . Они ничего не зна-

ют о Веб и не используют никакие атрибуты пользовательского интерфейса .

196   Глава 20. Бизнес-правила

Такое отсутствие зависимостей имеет решающее значение . Если модели за-

просов и ответов зависят от чего-то, варианты использования, зависящие от 

них, оказываются косвенно связанными с зависимостями, которые вносят 

эти модели .

У вас может возникнуть соблазн включить в эти структуры ссылки на объ-

екты сущностей . На первый взгляд кажется, что в этом есть определенный 

смысл, потому что сущности и модели запросов/ответов совместно ис-

пользуют так много данных . Боритесь с этим искушением! Эти два объекта 

имеют слишком разные цели . Со временем они будут меняться по разным 

причинам, поэтому создание связи между ними нарушит принципы со-

гласованного изменения (CCP) и единственной ответственности (SRP) . 

В результате у вас появится множество кочующих данных и масса условных 

инструкций в коде .

Заключение

Бизнес-правила являются причиной существования программной системы . 

Они составляют основу функционирования . Они порождают код, который 

делает или экономит деньги . Они — наши семейные реликвии .

Бизнес-правила должны оставаться в неприкосновенности, незапятнанными 

низкоуровневыми аспектами, такими как пользовательский интерфейс или 

база данных . В идеале код, представляющий бизнес-правила, должен быть 

сердцем системы, а другие задачи — просто подключаться к ним . Реализация 

бизнес-правил должна быть самым независимым кодом в системе, готовым 

к многократному использованию .

21

Кричащая 

архитектура

198   Глава 21. Кричащая архитектура

Представьте, что перед вами чертежи здания . Они подготовлены архитекто-

ром и представляют собой планы здания . О чем они вам говорят?

Если это чертежи коттеджа, вы наверняка увидите на них парадный вход, 

вестибюль, ведущий в гостиную и, может быть, в столовую . Рядом со столо-

вой, скорее всего, будет расположена кухня . Рядом с кухней, вероятно, будет 

малая столовая и где-то поблизости — общая комната . При рассмотрении 

этих планов у вас не возникнет сомнений, что вы видите коттедж для одной 

семьи . Архитектура как бы кричит: «Это коттедж» .

А теперь представьте, что вы рассматриваете архитектуру библиотеки . Вы 

наверняка увидите центральный вход, места для размещения библиотека-

рей, читальные залы, небольшие конференц-залы и галереи для хранения 

книг . Архитектура кричит: «Это библиотека» .

А что кричит архитектура вашего приложения? Увидев высокоуровневую 

структуру каталогов и пакетов с исходным кодом, услышите ли вы, как она 

кричит: «Это медицинская система», или «Это система учета», или «Это 

система управления складским хозяйством»? Или вы услышите: «Rails», 

или «Spring/Hibernate», или «ASP»?

Тема архитектуры

Отвлекитесь и прочитайте фундаментальный труд Ивара Якобсона об 

архитектуре программного обеспечения: книгу Object Oriented Software 

Engineering1 . Обратите внимание на подзаголовок книги: A Use Case Driven 

Approach2 . В этой книге Якобсон подчеркивает, что архитектура программ-

ного обеспечения — это структура, поддерживающая варианты использова-

ния системы . В точности как план библиотеки или коттеджа кричит о на-

значении здания, архитектура программного обеспечения должна кричать 

о вариантах использования приложения .

Архитектуры не связаны (и не должны быть связаны) с фреймворками . 

Архитектура не должна определяться фреймворками . Фреймворки — это 

1 Проектирование объектно-ориентированного программного обеспечения . — Примеч. 

пер.

2 Подход на основе вариантов использования . — Примеч. пер.

А что насчет Веб?      199

инструменты, а вовсе не аспекты, определяющие черты архитектуры . Если 

ваша архитектура опирается на фреймворки, она не сможет опираться на 

варианты использования .

Цель архитектуры

Хорошие архитектуры опираются на варианты использования и помогают 

архитекторам описывать структуры, поддерживающие эти варианты ис-

пользования, не связывая себя фреймворками, инструментами и окружени-

ями . Взгляните на план коттеджа еще раз . Одной из первоочередных забот 

архитектора является удобная планировка дома, а не выбор материала для 

стен . Действительно, архитектор прилагает максимум усилий, чтобы дать 

домовладельцу возможность самому выбрать материал (кирпич, камень или 

дерево), потом, когда планы, соответствующие вариантам использования, 

уже будут начерчены .

Хорошая архитектура позволяет отложить решение о выборе фреймворков, 

баз данных, веб-серверов и других инструментов и элементов окружения . 

Фреймворки относятся к возможностям, которые должны оставаться от-

крытыми. Хорошая архитектура позволяет отложить выбор Rails, Spring, 

Hibernate, Tomcat или MySQL на отдаленный срок . Хорошая архитектура 

позволяет с легкостью менять подобные решения . Хорошая архитектура 

подчеркивает варианты использования и отделяет их от второстепенных 

проблем .

А что насчет Веб?

Веб — это архитектура? Зависит ли архитектура системы от того факта, что 

свои услуги она предоставляет через Веб? Конечно нет! Всемирная паутина 

(или Веб) — это механизм доставки, устройство ввода/вывода . И архитек-

тура вашего приложения должна интерпретировать его именно так, а не 

иначе . Факт предоставления услуг через Веб — это деталь, и она не должна 

определять структуру системы . В действительности решение о предостав-

лении услуг через Веб относится к разряду решений, которые должны от-

кладываться . Архитектура системы должна быть максимально нейтральной 

200   Глава 21. Кричащая архитектура

к механизмам доставки услуг . У вас должна иметься возможность реализо-

вать систему в форме консольного приложения, веб-приложения, толстого 

клиента или даже веб-службы без чрезмерного усложнения или изменения 

основной архитектуры .

Фреймворки — это инструменты, 

а не образ жизни

Фреймворки могут быть очень мощными и удобными . Авторы фреймворков 

часто глубоко убеждены в своих творениях . Примеры, которые они пишут, 

рассказывают об использовании их фреймворков с точки зрения истинно 

верующих . Другие авторы, пишущие книги о фреймворках, тоже часто сто-

ят на позициях истинной веры . Они показывают способы использования 

фреймворков, часто с позиции всеобъемлющего, всепроникающего и по-

всеместного применения .

Вы не должны вставать на эту позицию.

Рассматривайте фреймворки с холодком . Смотрите на них скептически . Да, 

они могут помочь, но какой ценой? Спросите себя, как бы вы их исполь-

зовали и как защитились бы от них . Подумайте, как сохранить приоритет 

вариантов использования для архитектуры . Разработайте стратегию, не 

позволяющую фреймворку влиять на архитектуру .

Тестируемые архитектуры

Если архитектура вашей системы основана исключительно на вариантах 

использования и вам удалось удержать фреймворки на расстоянии, у вас 

должна иметься возможность протестировать все эти варианты использо-

вания без привлечения фреймворков . Вы не должны испытывать потреб-

ности в веб-сервере для выполнения тестов . Вы не должны испытывать 

потребности в подключении к базе данных для выполнения тестов . Ваши 

сущности должны быть самыми обычными объектами, не зависящими от 

фреймворков, баз данных или чего-то другого . Ваши объекты вариантов 

использования должны координировать действия сущностей . Наконец, 

должна иметься возможность протестировать их вместе без привлечения 

любых фреймворков .

Заключение      201

Заключение

Ваша архитектура должна рассказывать о системе, а не о фреймворках, ис-

пользованных в системе . Если вы работаете над системой для медицинского 

учреждения, тогда первый же взгляд на репозиторий с исходным кодом 

должен вызывать у новых программистов, подключающихся к проекту, 

мысль: «Да, это медицинская система» . Новые программисты должны иметь 

возможность изучить все возможные варианты использования, даже не зная, 

как будут доставляться услуги системы . Они могут подойти к вам и сказать: 

«Мы видим что-то похожее на модели, но где контроллеры и представле-

ния?»

А вы должны ответить:

«Это такая мелочь, которая нас пока не заботит . Мы решим этот вопрос 

позже» .

22 Чистая архитектура

Чистая архитектура      203

За последние несколько десятилетий мы видели целый ряд идей об органи-

зации архитектур . В том числе:

 

� Гексагональная архитектура (Hexagonal Architecture, также известна как 

архитектура портов и адаптеров), разработанная Алистером Кокберном 

и описанная Стивом Фриманом и Натом Прайсом в их замечательной 

книге Growing Object Oriented Software with Tests .

 

� DCI1, предложенная Джеймсом Коплиеном и Трюгве Реенскаугом .

 

� BCE2, предложенная Иваром Якобсоном в книге Object Oriented Software 

Engineering: A Use-Case Driven Approach .

Несмотря на различия в деталях, все эти архитектуры очень похожи . Они 

все преследуют одну цель — разделение задач . Они все достигают этой цели 

путем деления программного обеспечения на уровни . Каждая имеет хотя 

бы один уровень для бизнес-правил и еще один для пользовательского 

и системного интерфейсов .

Каждая из этих архитектур способствует созданию систем, обладающих 

следующими характеристиками:

 

� Независимость от фреймворков. Архитектура не зависит от наличия 

какой-либо библиотеки . Это позволяет рассматривать фреймворки как 

инструменты, вместо того чтобы стараться втиснуть систему в их рамки .

 

� Простота тестирования. Бизнес-правила можно тестировать без поль-

зовательского интерфейса, базы данных, веб-сервера и любых других 

внешних элементов .

 

� Независимость от пользовательского интерфейса . Пользовательский 

интерфейс можно легко изменять, не затрагивая остальную систему . 

Например, веб-интерфейс можно заменить консольным интерфейсом, 

не изменяя бизнес-правил .

 

� Независимость от базы данных. Вы можете поменять Oracle или SQL 

Server на Mongo, BigTable, CouchDB или что-то еще . Бизнес-правила не 

привязаны к базе данных .

 

� Независимость от любых внешних агентов. Ваши бизнес-правила ничего 

не знают об интерфейсах, ведущих во внешний мир .

Диаграмма на рис . 22 .1 — это попытка объединить все эти архитектуры 

в одну практически осуществимую идею .

1 Data-Context-Interaction — данные, контекст, взаимодействие . — Примеч. пер.

2 Boundary-Control-Entity — граница, управление, сущность . — Примеч. пер.

204   Глава 22. Чистая архитектура

Чистая архитектура

Устройства

Контроллеры

Веб

Варианты

использования

Сущности

Шлюзы

Презентаторы

Пользовательский

интерфейс

Внешние

интерфейсы

Бизнес-правила уровня

предприятия

Прикладные

бизнес-правила

Адаптеры

интерфейсов

Фреймворки

и драйверы

Презентатор

Порт вывода

варианта

использования

Средство

управления

в варианте

использования

Порт ввода

варианта

использования

Контроллер

Поток управления

Рис. 22.1. Чистая архитектура

Правило зависимостей

Концентрические круги на рис . 22 .1 представляют разные уровни про-

граммного обеспечения . Чем ближе к центру, тем выше уровень . Внешние 

круги — это механизмы . Внутренние — политики .

Главным правилом, приводящим эту архитектуру в действие, является пра-

вило зависимостей (Dependency Rule):

Зависимости в исходном коде должны быть направлены внутрь, в сторону 

высокоуровневых политик.

Ничто во внутреннем круге ничего не знает о внешних кругах . Например, 

имена, объявленные во внешних кругах, не должны упоминаться в коде, 

находящемся во внутренних кругах . Сюда относятся функции, классы, пере-

менные и любые другие именованные элементы программы .

Точно так же форматы данных, объявленные во внешних кругах, не должны 

использоваться во внутренних, особенно если эти форматы генерируются 

Правило зависимостей      205

фреймворком во внешнем круге . Ничто во внешнем круге не должно влиять 

на внутренние круги .

Сущности

Сущности заключают в себе критические бизнес-правила уровня предпри-

ятия . Сущность может быть объектом с методами или набором структур 

данных и функций . Сама организация не важна, если сущности доступны 

для использования разными приложениями на предприятии .

Если вы пишете только одно приложение и не для предприятия, эти сущ-

ности становятся бизнес-объектами приложения . Они инкапсулируют 

наиболее общие и высокоуровневые правила . Их изменение маловероятно 

под влиянием внешних изменений . Например, трудно представить, что эти 

объекты изменятся из-за изменения структуры навигации или безопасности 

страницы . Никакие изменения в работе любого конкретного приложения не 

должны влиять на уровень сущностей .

Варианты использования

Программное обеспечение на уровне вариантов использования содержит 

бизнес-правила, характерные для приложения . Оно инкапсулирует и ре-

ализует все варианты использования системы . Варианты использования 

организуют поток данных в сущности и из них и требуют от этих сущностей 

использовать их критические бизнес-правила для достижения своих целей .

Изменения внутри этого уровня не должны влиять на сущности . Аналогич-

но изменения во внешних уровнях, например в базе данных, пользователь-

ском интерфейсе или в любом из общих фреймворков, не должны влиять 

на этот уровень . Уровень вариантов использования изолирован от таких 

проблем .

Но изменения в работе приложения безусловно повлияют на варианты ис-

пользования и, соответственно, на программное обеспечение, находящееся 

на этом уровне . Изменение деталей вариантов использования определенно 

затронет некоторый код на этом уровне .

Адаптеры интерфейсов

Программное обеспечение на уровне адаптеров интерфейсов — это набор 

адаптеров, преобразующих данные из формата, наиболее удобного для 

206   Глава 22. Чистая архитектура

вариантов использования и сущностей, в формат, наиболее удобный для 

некоторых внешних агентов, таких как база данных или веб-интерфейс . 

Именно на этом уровне целиком находится архитектура MVC графического 

пользовательского интерфейса . Презентаторы, представления и контрол-

леры — все принадлежат уровню адаптеров интерфейсов . Модели — часто 

лишь структуры данных, которые передаются из контроллеров в варианты 

использования и затем обратно из вариантов использования в презентаторы 

и представления .

Аналогично на этом уровне преобразуются данные из формата, наиболее 

удобного для вариантов использования и сущностей, в формат, наиболее 

удобный для инфраструктуры хранения данных (например, базы данных) . 

Никакой код, находящийся в других внутренних кругах, не должен ничего 

знать о базе данных . Если данные хранятся в базе данных SQL, тогда весь 

код на языке SQL должен находиться именно на этом уровне, точнее, в эле-

ментах этого уровня, связанных с базой данных .

Также в этом уровне находятся любые другие адаптеры, необходимые для 

преобразования данных из внешнего формата, например полученных от 

внешней службы, во внутренний, используемый вариантами использования 

и сущностями .

Фреймворки и драйверы

Самый внешний уровень модели на рис . 22 .1 обычно состоит из фреймвор-

ков и инструментов, таких как база данных и веб-фреймворк . Как правило, 

для этого уровня требуется писать не очень много кода, и обычно этот код 

играет роль связующего звена со следующим внутренним кругом .

На уровне фреймворков и драйверов сосредоточены все детали . Веб-

интерфейс — это деталь . База данных — это деталь . Все это мы храним во 

внешнем круге, где они не смогут причинить большого вреда .

Толька четыре круга?

Круги на рис . 22 .1 лишь схематически изображают основную идею: иногда 

вам может понадобиться больше четырех кругов . Фактически нет никако-

го правила, утверждающего, что кругов должно быть именно четыре . Но 

всегда действует правило зависимостей . Зависимости в исходном коде 

всегда должны быть направлены внутрь . По мере движения внутрь уро-

вень абстракции и политик увеличивается . Самый внешний круг включает 

низкоуровневые конкретные детали . По мере приближения к центру про-

Правило зависимостей      207

граммное обеспечение становится все более абстрактным и инкапсулирует 

все более высокоуровневые политики . Самый внутренний круг является 

самым обобщенным и находится на самом высоком уровне .

Пересечение границ

Справа внизу на рис . 22 .1 приводится пример пересечения границ кругов . 

На нем изображены контроллеры и презентаторы, взаимодействующие 

с вариантами использования на следующем уровне . Обратите внимание на 

поток управления: он начинается в контроллере, проходит через вариант 

использования и завершается в презентаторе . Отметьте также, как направ-

лены зависимости в исходном коде: каждая указывает внутрь, на варианты 

использования .

Обычно мы разрешаем это кажущееся противоречие с использованием 

принципа инверсии зависимостей (Dependency Inversion Principle) . В таких 

языках, как Java, например, мы можем определять интерфейсы и использо-

вать механизм наследования, чтобы направление зависимостей в исходном 

коде было противоположно направлению потока управления на границах 

справа .

Допустим, что вариант использования должен вызвать презентатора . Такой 

вызов нельзя выполнить непосредственно, потому что иначе нарушится 

правило зависимостей: никакие имена, объявленные во внешних кругах, 

не должны упоминаться во внутренних . Поэтому вариант использования 

должен вызвать интерфейс (на рис . 22 .1 подписан как «Порт вывода вари-

анта использования»), объявленный во внутреннем круге, а презентатор во 

внешнем круге должен реализовать его .

Тот же прием используется для всех пересечений границ в архитектуре . Мы 

используем преимущество динамического полиморфизма, чтобы обратить 

зависимости в исходном коде в направлении, противоположном потоку 

управления, и тем самым соблюсти правило зависимостей при любом на-

правлении потока управления .

Какие данные пересекают границы

Обычно через границы данные передаются в виде простых структур . При 

желании можно использовать простейшие структуры или объекты переда-

чи данных (Data Transfer Objects; DTO) . Данные можно также передавать 

в вызовы функций через аргументы . Или упаковывать их в ассоциативные 

массивы или объекты . Важно, чтобы через границы передавались простые, 

208   Глава 22. Чистая архитектура

изолированные структуры данных . Не нужно хитрить и передавать объекты 

сущностей или записи из базы данных . Структуры данных не должны на-

рушать правило зависимостей .

Например, многие фреймворки для работы с базами данных возвращают 

ответы на запросы в удобном формате . Их можно назвать «представлением 

записей» . Такие представления записей не должны передаваться через гра-

ницы внутрь . Это нарушает правило зависимостей, потому что заставляет 

внутренний круг знать что-то о внешнем круге .

Итак, при передаче через границу данные всегда должны принимать форму, 

наиболее удобную для внутреннего круга .

Типичный сценарий

Диаграмма на рис . 22 .2 показывает типичный сценарий работы веб-системы 

на Java, использующей базу данных . Веб-сервер принимает исходные дан-

ные от пользователя и передает их контроллеру Controller в левом верхнем 

Рис. 22.2. Типичный сценарий работы веб-системы на Java, использующей базу 

данных

Заключение      209

углу . Контроллер упаковывает данные в простой Java-объект InputData и пе-

редает его через интерфейс InputBoundary классу UseCaseInteractor . Класс 

UseCaseInteractor интерпретирует данные и использует их для управления 

действиями сущностей Entities . Он также переносит данные из базы данных 

Database в память сущностей Entities через интерфейс DataAccessInterface . 

По завершении UseCaseInteractor забирает данные из сущностей Entities 

и конструирует из них другой простой Java-объект OutputData . Затем объ-

ект OutputData передается через интерфейс OutputBoundary презентатору 

Presenter .

Презентатор Presenter переупаковывает данные из объекта OutputData в объ-

ект ViewModel, еще один простой Java-объект, содержащий в основном строки 

и флаги, используемые представлением View для отображения данных . Объ-

ект OutputData мог бы содержать объекты типа Date, но Presenter преобразует 

их в процессе формирования ViewModel в строковые значения, пригодные 

для отображения . То же произойдет с объектами типа Currency и любыми 

другими бизнес-данными . Имена кнопок Button и пунктов меню MenuItem по-

мещаются в ViewModel вместе с флагами, сообщающими представлению View, 

следует ли отобразить эти кнопки и пункты меню в неактивном состоянии .

В результате представлению View практически ничего не приходится делать, 

кроме как перенести данные из ViewModel в HTML-страницу .

Обратите внимание на направления зависимостей . Все они пересекают 

линии границ только в направлении внутрь, следуя правилу зависимостей .

Заключение

Следование этим простым правилам не требует больших усилий и поможет 

сохранить душевный покой в будущем . Разделив программное обеспечение 

на уровни и соблюдая правило зависимостей, вы создадите систему, которую 

легко протестировать — со всеми вытекающими из этого преимуществами . 

Когда какой-либо из внешних элементов системы, например база данных 

или веб-фреймворк, устареет, вы сможете без всякой суеты заменить его .

23

Презентаторы 

и скромные объекты

Презентаторы и представления      211

В главе 22 мы познакомились с понятием презентатора (presenter) . Пре-

зентаторы являются разновидностью шаблона проектирования «Скромный 

объект» (Humble Object), помогающего выявлять и защищать архитектур-

ные границы . Фактически чистая архитектура в предыдущей главе полна 

реализациями шаблона «Скромный объект» .

Шаблон «Скромный объект»

Шаблон проектирования «Скромный объект»1 первоначально предлагался 

для использования в модульном тестировании как способ отделения поведе-

ния, легко поддающегося тестированию, от поведения, с трудом поддающе-

гося тестированию . Идея очень проста: разделить поведение на два модуля 

или класса . Один из модулей, который называется «скромным», содержит 

все, что с трудом поддается тестированию, в виде, упрощенном до предела . 

Второй — все, что было выброшено из «скромного» модуля .

Например, графические пользовательские интерфейсы сложны для мо-

дульного тестирования, потому что трудно писать тесты, которые могут 

видеть изображение на экране и проверять присутствие соответствующих 

элементов . Однако в действительности большая часть поведения пользо-

вательского интерфейса легко тестируется . Используя шаблон «Скромный 

объект», можно разделить два вида поведения на два разных класса, которые 

называют Презентатором (Presenter) и Представлением (View) .

Презентаторы и представления

Представление (View) — это «скромный» объект, сложный для тестиро-

вания . Код в этом объекте упрощается до предела . Он просто переносит 

данные в графический интерфейс, никак не обрабатывая их .

Презентатор (Presenter) — это легко тестируемый объект . Его задача — полу-

чить данные от приложения и преобразовать их так, чтобы Представление 

(View) могло просто переместить их на экран . Например, если приложе-

нию потребуется отобразить дату в некотором поле, оно должно передать 

Презентатору объект Date . Презентатор затем должен преобразовать дату 

в строку и поместить ее в простую структуру данных, которую называют 

Моделью представления (View Model), где Представление сможет найти ее .

1 xUnit Patterns, Meszaros, Addison-Wesley, 2007, p . 695 . (Джерард Месарош. Шаблоны 

тестирования xUnit: рефакторинг кода тестов . М .: Вильямс, 2017 . — Примеч. пер.) .

212   Глава 23. Презентаторы и скромные объекты

Если приложению потребуется отобразить на экране денежную сумму, оно 

может передать Презентатору объект Currency . Презентатор должен преоб-

разовать этот объект в строковое представление десятичного числа с соот-

ветствующим количеством десятичных знаков и знаком валюты и поместить 

полученную строку в Модель представления . Если отрицательные суммы 

должны отображаться красным цветом, тогда в Модели представления дол-

жен устанавливаться соответствующий флаг .

Каждая кнопка на экране имеет имя . Это имя является строкой в Модели 

представления, помещаемой туда Презентатором . Если кнопка должна ото-

бражаться как неактивная, Презентатор установит соответствующий логиче-

ский флаг в Модели представления . Имя каждого пункта меню представлено 

строкой в Модели представления, помещаемой туда Презентатором . Имена 

всех радиокнопок, флажков и текстовых полей и соответствующих логи-

ческих флагов устанавливаются Презентатором в Модели представления . 

Таблицы чисел, которые должны отображаться на экране, преобразуются 

Презентатором в таблицы форматированных строк в Модели представления .

Все, что отображается на экране и чем так или иначе управляет приложение, 

представлено в Модели представления строкой, или логическим значением, 

или элементом перечисления . На долю Представления остается только пере-

нести данные из Модели представления на экран . То есть Представление 

играет скромную роль .

Тестирование и архитектура

Давно известно, что простота тестирования является характерным призна-

ком хорошей архитектуры . Шаблон «Скромный объект» — хороший при-

мер, потому что раздел между легко и тяжело тестируемыми частями часто 

совпадает с архитектурными границами . Раздел между Презентаторами 

и Представлениями — одна из таких границ, но существует много других .

Шлюзы к базам данных

Между средствами управления в вариантах использования и базами данных 

находятся шлюзы к базам данных1 . Эти шлюзы являются полиморфными 

1 Patterns of Enterprise Application Architecture, Martin Fowler, et . al ., Addison-Wesley, 2003, 

p . 466 . (Мартин Фаулер. Шаблоны корпоративных приложений . М .: Вильямс, 2017 . — 

Примеч. пер.) .

Преобразователи данных      213

интерфейсами, содержащими методы для каждой операции создания, чте-

ния, изменения и удаления, которые приложение может выполнить в базе 

данных . Например, если приложению может понадобиться узнать фамилии 

всех пользователей, работавших вчера, в интерфейсе UserGateway должен 

иметься метод с именем getLastNamesOfUsersWhoLoggedInAfter, принимающий 

объект Date и возвращающий список фамилий .

Как вы помните, мы полностью отвергаем возможность появления кода на 

SQL на уровне вариантов использования; для этого используются интер-

фейсы шлюзов, имеющие определенные методы . Эти шлюзы реализуются 

классами на уровне базы данных . Такие реализации являются «скромными 

объектами» . Они просто используют код SQL или любой другой интерфейс 

доступа к базе данных для извлечения данных, необходимых каждому из 

методов . Механизмы управления в вариантах использования, напротив, не 

являются «скромными», потому что заключают бизнес-правила, характер-

ные для приложения . Даже при том, что они не являются «скромными», 

средства управления легко поддаются тестированию, потому что шлюзы 

можно заменить соответствующими заглушками .

Преобразователи данных

Вернемся к теме баз данных . На каком уровне, по вашему мнению, должны 

находиться фреймворки ORM, такие как Hibernate?

Во-первых, давайте кое-что проясним: нет такой штуки, как инструмент 

объектно-реляционного преобразования (Object Relational Mapper; ORM), 

потому что объекты не являются структурами данных, по крайней мере 

с точки зрения пользователя . Пользователи объекта не видят данных, по-

тому что все они хранятся в приватных полях . Пользователи видят только 

общедоступные методы объекта . То есть с точки зрения пользователя объ-

ект — это набор операций .

Структура данных, напротив, — набор общедоступных данных, не облада-

ющих подразумеваемым поведением . Название «преобразователи данных» 

лучше подходит для инструментов ORM, потому что они загружают данные 

из реляционных таблиц в структуры .

Где должны находиться такие системы ORM? Конечно, на уровне базы 

данных . В действительности инструменты ORM представляют еще одну 

разновидность границы «Скромный объект» между интерфейсами шлюза 

и базой данных .

214   Глава 23. Презентаторы и скромные объекты

Службы

А что можно сказать о службах? Если приложение взаимодействует со 

службами или реализует свой набор служб, можно ли в этом случае при-

менить шаблон «Скромный объект» для создания границы, отделяющей 

службу?

Конечно! Приложение должно загружать данные в простые структуры 

и передавать эти структуры через границу модулям, которые преобразуют 

данные и посылают их внешним службам . С другой стороны, в точке ввода 

слушатель службы должен принимать данные через интерфейс службы, 

преобразовывать их в простые структуры данных, пригодные для исполь-

зования в приложении, и затем передавать их через границу службы .

Заключение

Практически на каждой архитектурной границе можно найти возможность 

применить шаблон «Скромный объект» . Взаимодействия через границу поч-

ти всегда осуществляются с применением некой простой структуры данных, 

и граница часто делит что-то на сложное и простое для тестирования . При-

менение этого шаблона для организации архитектурных границ значительно 

улучшает возможность тестирования системы в целом .

24 Неполные границы

216   Глава 24. Неполные границы

Полноценные архитектурные границы обходятся дорого . Они требуют 

определения двусторонних пограничных интерфейсов, структур для вход-

ных и выходных данных и управления зависимостями для выделения двух 

сторон в компоненты, компилируемые и развертываемые независимо . Это 

требует значительных усилий для создания и сопровождения .

Во многих ситуациях хороший архитектор мог бы посчитать затраты на 

создание такой границы слишком высокими, но хотел бы сохранить место 

для такой границы на будущее .

Подобное упреждающее проектирование часто расценивается многими по-

следователями гибкой разработки как нарушение принципа YAGNI: «You 

Aren’t Going to Need It» («Вам это не понадобится») . Однако некоторые 

архитекторы смотрят на эту проблему и думают: «А мне может это понадо-

биться» . В этом случае они могут реализовать неполную границу .

Пропустить последний шаг

Один из способов сконструировать неполную границу — проделать все, 

что необходимо для создания независимо компилируемых и развертывае-

мых компонентов, и затем просто оставить их в одном компоненте . В этом 

компоненте будут присутствовать парные интерфейсы, структуры входных 

и выходных данных и все остальное, но все это будет компилироваться 

и развертываться как один компонент .

Очевидно, что для реализации такой неполной границы потребуется тот же 

объем кода и подготовительного проектирования, что и для полной границы . 

Но в этом случае не потребуется администрировать несколько компонентов . 

Не потребуется следить за номерами версий и нести дополнительное бремя 

управления версиями . Это отличие не нужно недооценивать .

Эта стратегия использовалась в начале развития FitNesse . Компонент веб-

сервера FitNesse проектировался с возможностью отделения от компо-

нентов вики и тестирования . Мы думали, что впоследствии у нас может 

появиться желание создать другие веб-приложения, использующие этот 

веб-компонент . В то же время мы не хотели вынуждать пользователей за-

гружать два компонента . Как вы помните, одна из наших целей выражалась 

фразой «Загрузи и вперед» . Мы специально хотели, чтобы пользователям 

нужно было загрузить и выполнить только один jar-файл, не заботясь о по-

иске других jar-файлов с совместимыми версиями и т . д .

История FitNesse также указывает на одну из опасностей такого подхода . 

Со временем, когда стало ясно, что отдельный веб-компонент никог-

Фасады      217

да не понадобится, грань между веб-компонентом и компонентом вики 

стала размываться . Начали появляться зависимости, пересекающие ли-

нию в  неправильном направлении . Разделить их сейчас было бы очень 

сложно .

Одномерные границы

Для оформления полноценной архитектурной границы требуется создать 

парные пограничные интерфейсы для управления изоляцией в обоих на-

правлениях . Поддержание разделения в обоих направлениях обходится 

дорого не только на начальном этапе, но и на этапе сопровождения .

На рис . 24 .1 показана более простая схема, помогающая зарезервировать 

место для последующего превращения в полноценную границу . Это пример 

традиционного шаблона «Стратегия» . Клиенты пользуются интерфейсом 

ServiceBoundary, который реализуют классы ServiceImpl .

Клиент

Рис. 24.1. Шаблон «Стратегия»

Должно быть ясно, что это создает основу для будущей архитектурной гра-

ницы . Здесь имеет место инверсия зависимости, необходимая для отделения 

клиента от класса ServiceImpl . Также должно быть ясно, что разделение мо-

жет очень быстро стираться, о чем свидетельствует пунктирная стрелка на 

диаграмме . В отсутствие парных интерфейсов ничто не мешает появлению 

таких обратных зависимостей, кроме старательности и дисциплинирован-

ности разработчиков и архитекторов .

Фасады

Еще более простой подход к организации границ дает шаблон «Фасад», 

изображенный на рис . 24 .2 . В этом случае отсутствует даже инверсия зави-

симостей . Граница определяется простым классом Facade c методами, пред-

218   Глава 24. Неполные границы

ставляющими службы и реализующими обращения к службам, к которым 

клиенты, как предполагается, не должны иметь прямого доступа .

Клиент

Служба

Рис. 24.2. Шаблон «Фасад»

Обратите внимание, однако, что клиент имеет транзитивную (переходную) 

зависимость от всех этих классов служб . В языках со статической системой 

типов изменение исходного кода в одном из классов служб вызывает необ-

ходимость повторной компиляции клиента . Также представьте, насколько 

просто в этой схеме создать обратные связи .

Заключение

Мы увидели три простых способа реализации неполных архитектурных 

границ . Конечно, таких способов намного больше . Эти три стратегии служат 

лишь примерами .

Каждый из представленных подходов имеет свои достоинства и недостатки . 

Каждый подходит на роль заменителя полноценной архитектурной границы 

в определенных контекстах . И каждый может со временем деградировать, 

если граница никогда не будет материализована .

Одна из задач архитектора — решить, где провести архитектурную границу 

и как ее реализовать, частично или полностью .

25 Уровни и границы

220   Глава 25. Уровни и границы

В любой системе легко выделить три компонента: пользовательский интер-

фейс, бизнес-правила и базу данных . Для простых систем этого более чем 

достаточно . Но для большинства систем число компонентов должно быть 

больше .

Рассмотрим, например, простую компьютерную игру . В ней легко выделить 

три компонента . Пользовательский интерфейс обрабатывает все сообщения 

от пользователя и передает их правилам игры . Правила сохраняют состо-

яние игры в некоторой хранимой структуре данных . Но действительно ли 

это все, что нужно?

Охота на Вампуса

Давайте немного конкретизируем . Возьмем в качестве примера почтенную 

приключенческую игру «Охота на Вампуса»1, придуманную в 1972 году . 

В этой текстовой игре используются очень простые команды, такие как GO 

EAST (идти быстро) и SHOOT WEST (выстрелить в западном направле-

нии) . Игрок вводит команду, а компьютер в ответ сообщает, что персонаж 

видит, обоняет, слышит и чувствует . Игрок охотится за Вампусом в лаби-

ринте пещер и должен избегать ловушек, ям и других опасностей . Желаю-

щие без труда найдут правила игры в Интернете .

Допустим, мы решили сохранить текстовый интерфейс, но отделить его от 

правил игры, чтобы наша версия могла обрабатывать команды на разных 

языках и распространяться в разных странах . Игровые правила взаимо-

действуют с компонентом пользовательского интерфейса посредством 

прикладного интерфейса, не зависящего от языка, а пользовательский 

интерфейс транслирует команды API на соответствующий естественный 

язык .

При правильной организации зависимостей, как показано на рис . 25 .1, 

можно создать произвольное количество компонентов с пользовательским 

интерфейсом, использующих те же игровые правила . Правила игры ничего 

не знают об используемом естественном языке общения с пользователем .

Допустим также, что состояние игры сохраняется в некотором хранилище — 

это может быть флешка, облачное хранилище или просто ОЗУ . В любом из 

этих случаев игровые правила не должны знать деталей . Поэтому снова мы 

создаем прикладной интерфейс, который игровые правила смогут исполь-

зовать для взаимодействия с компонентом хранилища .

1 https://ru.wikipedia.org/wiki/Hunt_the_Wumpus. — Примеч. пер.

Чистая архитектура?      221

Английский

интерфейс

Испанский

интерфейс

Правила

игры

</p>
   </article>
</body>
</html>
