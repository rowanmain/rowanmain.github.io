<!DOCTYPE html>
<html>
<head>
   <title>Моя статья</title>
   <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<style>
body {
   background-color: #f0f0f0;
   font-family: Arial, sans-serif;
}

header {
   background-color: #333;
   color: white;
   padding: 10px;
   text-align: center;
}

h1 {
   margin: 0;
}

article {
   margin: 20px;
}

h2 {
   color: #333;
}

p {
   line-height: 1.6;
}
</style>
<body>
   <header>
       <h1>статья</h1>
   </header>
   <article>
       <p>
прямой доступ к регистрам процессора, портам ввода/вывода, таймерам, 

битам интерфейсов ввода/вывода, контроллерам прерываний и другим 

функциям процессора . Их удобно использовать для доступа ко всему пере-

численному, но вы должны понимать, что код, использующий эти вспо-

могательные средства, больше не является кодом на языке C . Он не будет 

компилироваться для другого процессора или даже другим компилятором 

для этого же процессора .

Не хотелось бы думать, что производитель оборудования цинично привя-

зывает ваш продукт к своему компилятору, поэтому будем считать, что он 

искренне желает помочь . Но теперь вам решать — как использовать эту по-

мощь, чтобы не навредить себе же в будущем . Вам придется ограничить круг 

файлов, которым будет известно о нестандартных расширениях языка C .

Взгляните на следующий заголовочный файл, созданный для семейства 

ACME процессоров цифровой обработки сигналов:

1 В этом предложении преднамеренно использована разметка HTML .

258   Глава 29. Чистая встраиваемая архитектура

#ifndef _ACME_STD_TYPES

#define _ACME_STD_TYPES

#if defined(_ACME_X42)

    typedef unsigned int     Uint_32;

    typedef unsigned short   Uint_16;

    typedef unsigned char    Uint_8;

    typedef int              Int_32;

    typedef short            Int_16;

    typedef char             Int_8;

#elif defined(_ACME_A42)

    typedef unsigned long    Uint_32;

    typedef unsigned int     Uint_16;

    typedef unsigned char    Uint_8;

    typedef long             Int_32;

    typedef int              Int_16;

    typedef char             Int_8;

#else

    #error <acmetypes.h> is not supported for this environment

#endif

#endif

Заголовочный файл acmetypes.h не следует использовать непосредствен-

но, иначе ваш код окажется тесно связанным с процессорами ACME . Вы 

думаете, что если используете процессор ACME, то какой вред он может 

причинить? Все просто, вы не сможете скомпилировать свой код, не подклю-

чив этот заголовочный файл . А если подключить его и определить символ 

_ACME_X42 или _ACME_A42, целые числа будут иметь неправильный размер при 

тестировании за пределами целевой платформы . Какое-то время это может 

не вызывать никаких проблем, но однажды у вас может появиться желание 

перенести свое приложение на другой процессор, и тогда вы обнаружите, что 

задача сильно усложнилась из-за отказа от переносимости и ограничения 

на подключение файлов, знающих о процессорах ACME .

Вместо использования acmetypes.h следует попробовать пойти более стан-

дартным путем и использовать stdint.h . Но как быть, если в состав целе-

вого компилятора не входит файл stdint.h? Вы можете сами написать этот 

заголовочный файл . Файл stdint.h может использовать acmetypes.h, когда 

выполняется компиляция для целевой платформы:

#ifndef _STDINT_H_

#define _STDINT_H_

#include <acmetypes.h>

Привязка к оборудованию — узкое место      259

typedef Uint_32 uint32_t;

typedef Uint_16 uint16_t;

typedef Uint_8 uint8_t;

typedef Int_32 int32_t;

typedef Int_16 int16_t;

typedef Int_8 int8_t;

#endif

Использование stdint.h во встраиваемом программном обеспечении и ми-

кропрограммах поможет вам сохранить код чистым и переносимым . Всякое 

программное обеспечение должно быть независимым от типа процессора, но 

этот совет годится не для всякой микропрограммы . В следующем фрагменте 

кода используются особые расширения языка C, позволяющие коду обра-

щаться к периферийным устройствам в микроконтроллере . Продукт может 

быть оснащен этим микроконтроллером, поэтому вы можете использовать 

интегрированные в него периферийные устройства . Следующая функция 

выводит в последовательный порт строку с текстом "hi" . (Этот пример 

основан на реальном коде .)

void say_hi()

{

  IE = 0b11000000;

  SBUF0 = (0x68);

  while(TI_0 == 0);

  TI_0 = 0;

  SBUF0 = (0x69);

  while(TI_0 == 0);

  TI_0 = 0;

  SBUF0 = (0x0a);

  while(TI_0 == 0);

  TI_0 = 0;

  SBUF0 = (0x0d);

  while(TI_0 == 0);

  TI_0 = 0;

  IE = 0b11010000;

}

Эта маленькая функция страдает множеством проблем . Первое, что бро-

сается в глаза, — присутствие последовательности символов 0b11000000 . 

Такая форма записи двоичных чисел очень удобна, но поддерживается ли 

она стандартным языком C? К сожалению, нет . Еще несколько проблем 

проистекают непосредственно из использования нестандартных расши-

рений:

260   Глава 29. Чистая встраиваемая архитектура

 

� IE: устанавливает биты разрешения прерываний .

 

� SBUF0: буфер вывода последовательного порта .

 

� TI_0: прерывание опустошения буфера передачи последовательного пор-

та . Если операция чтения возвращает 1, это указывает, что буфер пуст .

Переменные с именами, состоящими из букв верхнего регистра, в дей-

ствительности представляют механизмы доступа к встроенной периферии 

микроконтроллера . Если программе понадобится управлять прерываниями 

и выводить символы, вам придется использовать эту периферию . Да, это 

удобно, но это уже не язык C .

Чистая архитектура будет напрямую использовать эти средства доступа 

к периферии лишь в нескольких местах и только в пределах микропро-

граммы . Любой код, знающий о существовании регистров, автоматически 

превращается в микропрограмму и, соответственно, оказывается тесно свя-

занным с конкретным оборудованием . Тесная связь кода с оборудованием 

мешает получить действующий код до получения стабильно работающего 

оборудования . Она также будет мешать переносить встраиваемое приложе-

ние на новый процессор .

Если вы используете микроконтроллер, подобный этому, ваша програм-

ма могла бы спрятать эти низкоуровневые функции за слоем абстракций 

процессора (Processor Abstraction Layer; PAL) . Часть микропрограммы, 

находящаяся над слоем PAL, могла бы проверять платформу, на которой 

выполняется, и таким способом ослабить жесткость кода .

Операционная система — это деталь

Слой аппаратных абстракций (HAL) является насущной необходимостью, 

но достаточно ли его? Во встраиваемых системах, где отсутствует другое 

программное окружение, слоя HAL более чем достаточно, чтобы оградить 

код от избыточной зависимости от операционной среды . Но что, если встра-

иваемая система использует некоторую операционную систему реального 

времени (RealTime Operating System; RTOS) или встраиваемую версию 

Linux или Windows?

Чтобы дать коду шанс служить долго, операционную систему следует рас-

сматривать как деталь и защищаться от зависимостей, связывающих с ней .

Программное обеспечение обращается к операционному окружению по-

средством операционной системы (ОС) . ОС — это слой, отделяющий про-

граммное обеспечение от микропрограмм (рис . 29 .5) . Прямое использование 

механизмов ОС может стать источником проблем . Например, представьте, 

Привязка к оборудованию — узкое место      261

Программное

обеспечение

Микропрограмма

Оборудование

ОС

Рис. 29.5. Дополнительный слой операционной системы

что производителя вашей RTOS купила другая компания и из-за этого вы-

росла стоимость системы или упало ее качество . Или ваши потребности 

изменились, а используемая вами RTOS не обладает необходимыми воз-

можностями . Вам придется изменить много кода . И это будут не просто 

синтаксические изменения, обусловленные сменой API, скорее всего, вам 

придется приспосабливать семантику кода к различным механизмам и при-

митивам новой ОС .

Чистая встраиваемая архитектура изолирует программное обеспечение от 

операционной системы, реализуя слой абстракции операционной системы 

(Operating System Abstraction Layer; OSAL), как показано на рис . 29 .6 . 

В некоторых случаях этот слой может иметь очень простую реализацию, 

выражающуюся в простой подмене имен функций . Но иногда может по-

требоваться полное обертывание некоторых функций .

Если вам доводилось переносить программное обеспечение с одной RTOS 

на другую, вы знаете, насколько трудно это дается . Если ваше программное 

обеспечение зависит только от слоя OSAL, но не зависит от ОС, вам по-

требуется только написать новый слой OSAL, совместимый с прежним . 

Что бы вы предпочли: изменить кучу сложного кода или написать новый 

код, определяющий интерфейс и поведение? Это даже не спорный вопрос . 

Я выбираю последнее .

Вас может обеспокоить проблема разбухания кода . Однако вам не о чем 

беспокоиться . Большая часть повторяющегося кода, обусловленного исполь-

зованием операционной системы, будет сосредоточена в слое абстракции . 

Такой повторяющийся код не будет вызывать больших накладных расходов . 

262   Глава 29. Чистая встраиваемая архитектура

Программное

обеспечение

ОС

Микропрограмма

Оборудование

Рис. 29.6. Слой абстракции операционной системы

Определяя слой OSAL, вы также получаете возможность привести свои 

приложения к некоторой общей структуре . Например, вы могли бы реали-

зовать механизмы передачи сообщений и отказаться от ручного управления 

конкурентным выполнением в каждом потоке .

Слой OSAL может помочь создать точки для тестирования, чтобы приклад-

ной программный код можно было тестировать без использования целевого 

оборудования и ОС . Программное обеспечение с чистой встраиваемой 

архитектурой поддерживает возможность тестирования вне целевой опе-

рационной системы . Удачно спроектированный слой OSAL предоставляет 

тот шов, или набор, точек подстановки, которые облегчат тестирование вне 

целевой среды .

Программирование с применением интерфейсов 

и возможность подстановки

Помимо добавления слоев HAL и, возможно, OSAL, внутри каждого из 

основных уровней (программное обеспечение, ОС, микропрограмма и обо-

рудование) можно и должно применять принципы, описанные в этой книге . 

Эти принципы способствуют разделению ответственности, программирова-

нию с применением интерфейсов и возможности подстановки .

Идея многоуровневой архитектуры основывается на идее программиро-

вания с применением интерфейсов . Когда один модуль взаимодействует 

Привязка к оборудованию — узкое место      263

с другим посредством интерфейса, появляется возможность заменить одного 

поставщика услуг другим . Многим из вас наверняка приходилось писать 

свои небольшие версии printf для развертывания в целевой среде . Если 

интерфейс вашей функции printf совпадает с интерфейсом стандартной 

версии printf, вы можете использовать их взаимозаменяемо .

Главное правило — использовать заголовочные файлы как определения 

интерфейсов . Однако такой подход требует внимательно следить за тем, что 

помещается в заголовочный файл . Желательно не помещать в него ничего, 

кроме объявлений функций, а также констант и имен структур, необходи-

мых функциям .

Не загромождайте интерфейсные заголовочные файлы структурами данных, 

константами и определениями типов, которые нужны только реализации . 

Это не просто вопрос беспорядка: подобный беспорядок приводит к не-

желательным зависимостям . Ограничьте видимость деталей реализации . 

Исходите из предположения, что детали реализации будут изменяться . 

Чем меньше мест, где код знает детали, тем меньше кода вам придется про-

сматривать и изменять .

Чистая встраиваемая архитектура позволяет выполнять послойное тести-

рование, потому что модули взаимодействуют посредством интерфейсов . 

Каждый интерфейс обеспечивает шов, или точку подстановки, для тести-

рования вне целевого окружения .

Принцип DRY и директивы условной 

компиляции

Одно из использований возможности подстановки, которое часто упускают 

из виду, связано с особенностями обработки разных целевых платформ или 

операционных систем программами на C и C++ . Для этого часто исполь-

зуются директивы условной компиляции, включающие и выключающие 

сегменты кода . Я вспоминаю один особенно тяжелый случай, когда в теле-

коммуникационном приложении директива #ifdef BOARD_V2 встречалась 

несколько тысяч раз .

Повторяющийся код нарушает принцип «не повторяйся» (Don’t Repeat 

Yourself; DRY)1 . Если #ifdef BOARD_V2 встречается один раз, в этом нет ни-

какой проблемы . Но шесть тысяч раз — это большая проблема. Условная 

1 Hunt and Thomas, The Pragmatic Programmer . (Э. Хант, Д. Томас . Программист-прагма-

тик . Путь от подмастерья к мастеру . М .: Лори, 2016 . — Примеч. пер.)

264   Глава 29. Чистая встраиваемая архитектура

компиляция, идентифицирующая тип целевого оборудования, часто ис-

пользуется во встраиваемых системах . Можно ли от нее избавиться?

Можно, если реализовать слой аппаратных абстракций и скрыть определе-

ние типа оборудования в этом слое . Если слой HAL предоставляет набор 

интерфейсов, вместо условной компиляции можно взвалить всю работу 

на компоновщика (редактора связей) или использовать некоторую форму 

связывания во время выполнения для подключения программного обеспе-

чения к оборудованию .

Заключение

Программисты, разрабатывающие встраиваемое программное обеспечение, 

могут многое взять из опыта разработки обычного программного обеспече-

ния . Если вы занимаетесь разработкой встраиваемого программного обе-

спечения, то найдете в этой книге много мудрых и полезных советов и идей, 

которые пригодятся и вам .

Не позволяйте всему вашему коду превращаться в микропрограммы — это 

вредно для долгого и доброго здоровья вашего продукта . Возможность 

тестирования исключительно в целевом окружении — вредна для долгого 

и доброго здоровья вашего продукта . Следование принципам чистой встра-

иваемой архитектуры — полезно для долгого и доброго здоровья вашего 

продукта .

VI 

Детали

30

База данных — 

это деталь

Реляционные базы данных      267

С архитектурной точки зрения база данных не является сущностью — это 

деталь, которая не должна подниматься до уровня архитектурного элемента . 

Ее отношение к архитектуре программной системы сопоставимо с отноше-

нием дверной ручки к архитектуре здания .

Я понимаю, что эти слова могут показаться провокационными . Но верьте 

мне, я знаю, о чем говорю . А теперь позвольте мне пояснить: я не имею 

в виду модель данных . Структура, которую вы придаете данным в своем 

приложении, очень важна для архитектуры системы . Но база данных — это 

не модель данных . База данных — это часть программного обеспечения . База 

данных — это утилита, обеспечивающая доступ к данным . С архитектурной 

точки зрения эта утилита не имеет никакого значения, это низкоуровневая 

деталь — механизм . А хороший архитектор не позволяет низкоуровневым 

механизмам просачиваться в архитектуру системы .

Реляционные базы данных

Принципы реляционных баз данных были определены Эдгаром Коддом 

в 1970 году . К середине 1980-х годов реляционная модель разрослась 

и превратилась в доминирующую форму хранения данных . Такая попу-

лярность появилась не на пустом месте: реляционная модель элегантна, 

дисциплинированна и надежна . Это отличная технология хранения и до-

ступа к данным .

Но какой бы блестящей, полезной и близкой к математике ни выглядела 

технология, она не перестает быть просто технологией . А значит, она — 

деталь .

Реляционные таблицы удобны для некоторых видов доступа к данным, но 

в упорядочивании данных по записям в таблицах нет ничего архитектур-

но значимого . Варианты использования в приложении не должны знать 

и заботиться о таких вещах . В действительности о табличной организации 

данных должны знать только низкоуровневые вспомогательные функции 

во внешних кругах архитектуры .

Многие фреймворки доступа к данным позволяют передавать записи и та-

блицы из базы данных в виде объектов через всю систему . Но такой способ 

действий является архитектурной ошибкой . Он связывает варианты ис-

пользования, бизнес-правила, а в некоторых случаях даже пользовательский 

интерфейс с определенной реляционной структурой данных .

268   Глава 30. База данных — это деталь

Почему системы баз данных 

настолько распространены?

Почему среди программных систем и корпоративных программных про-

дуктов доминирующее положение заняли системы баз данных? Чем объяс-

няется превосходство Oracle, MySQL и SQL Server? Если говорить одним 

словом — диски .

Пять десятилетий вращающийся магнитный диск был основой хранения 

данных . Несколько поколений программистов не знали иных форм хране-

ния данных . Технология производства дисковых накопителей прошла дол-

гий путь от огромных пакетов массивных пластин по 48 дюймов в диаметре, 

весивших тысячи килограммов и способных хранить 20 мегабайт, до тонких 

дисков по 3 дюйма в диаметре, весящих несколько граммов и способных 

хранить терабайт данных и даже больше . Это была сумасшедшая гонка. И на 

протяжении всей этой гонки программисты страдали от одного фатального 

свойства дисков: они работают слишком медленно .

Данные хранятся на диске на круговых дорожках . Дорожки делятся на 

секторы, хранящие определенное круглое число байтов, обычно 4 Кбайт . 

На каждой пластине может иметься несколько сотен дорожек, а в одном 

дисковом накопителе — десяток или около того пластин . Чтобы прочитать 

конкретный байт, устройство должно поместить головку на конкретную 

дорожку, дождаться, пока диск повернется так, что требуемый сектор ока-

жется под головкой, прочитать все 4 Кбайт из сектора в ОЗУ, и затем вам 

останется только прочитать требуемый байт из ОЗУ . Но все это требует 

времени — миллисекунд времени .

Может показаться, что миллисекунды — это немного, но миллисекунда 

в миллион раз продолжительнее одного такта большинства процессоров . 

Если бы данные хранились не на диске, к ним можно было бы получить до-

ступ не за миллисекунды, а за наносекунды .

Чтобы уменьшить задержку, вносимую дисками, нужны индексы, кэши и оп-

тимизированные схемы запросов; а еще нужны какие-то регулярные средства 

представления данных, чтобы все эти индексы, кэши и схемы запросов знали, 

с чем они работают . Проще говоря, нужен доступ к данным и система управле-

ния . За годы развития эти системы разделились на два разных типа: файловые 

системы и системы управления реляционными базами данных (СУРБД) .

Файловые системы опираются на понятие документа . Они поддерживают 

естественный и удобный способ хранения целых документов . Они хорошо 

Сохранятся ли диски?      269

работают, когда требуется сохранить или извлечь набор документов по 

имени, но не предлагают сколько-нибудь существенной помощи в поиске 

по содержимому документов . Вы легко найдете файл с именем login.c, но 

поиск всех файлов .c, содержащих переменную с именем x, будет долгим 

и трудным .

Системы баз данных ориентированы на содержимое . Они поддерживают 

естественный и удобный способ поиска записей по содержимому . Они очень 

хорошо связывают вместе несколько записей, имеющих общее содержимое . 

К сожалению, их преимущества теряются при хранении и извлечении не-

прозрачных документов .

Обе системы организуют хранение данных на диске так, чтобы обеспечить 

максимальную эффективность их сохранения и чтения, с учетом конкрет-

ных особенностей . Каждая имеет свою схему индексирования и организации 

данных . Кроме того, обе переносят соответствующие данные в ОЗУ, где ими 

можно быстро манипулировать .

Сохранятся ли диски?

Прежде занимающие доминирующие позиции, ныне диски превратились 

в вымирающий вид . В скором времени их ожидает судьба накопителей на 

магнитной ленте, гибких дисков и приводов компакт-дисков . Им на смену 

придет ОЗУ .

Спросите себя: когда диски исчезнут и все данные будут храниться в ОЗУ, 

как вы будете организовывать их? Вы предпочтете организовать их в табли-

цы и обращаться к ним, используя запросы на языке SQL? Или организовать 

их в файлы и обращаться к ним через систему каталогов?

Конечно нет . Вы организуете их в связные  списки, деревья, хеш-таблицы, 

стеки, очереди или любые другие структуры данных и будете обращаться 

к ним, используя указатели или ссылки, потому что программисты так при-

выкли .

На самом деле, поразмыслив об этой проблеме, вы поймете, что все это 

вы уже делаете . Несмотря на то что данные хранятся в базе данных или 

в файловой системе, вы читаете их в ОЗУ и затем реорганизуете в удобные 

списки, множества, стеки, очереди, деревья или любые другие структуры по 

своему усмотрению . Очень маловероятно, что вы оставите данные в форме 

файлов или таблиц .

270   Глава 30. База данных — это деталь

Детали

Такое положение дел объясняет, почему я говорю, что база данных — это 

деталь . Это лишь механизм перемещения данных взад-вперед между по-

верхностью диска и ОЗУ . База данных в действительности — не более чем 

большой мешок с битами, в котором мы храним свои данные . Но мы редко 

используем данные именно в такой форме .

То есть с архитектурной точки зрения мы не должны беспокоиться о том, 

какую форму принимают данные, пока хранятся на поверхности вращающе-

гося магнитного диска . В действительности нас вообще не должно волновать 

наличие или отсутствие диска .

А производительность?

Является ли производительность архитектурной проблемой? Конечно! Но 

в отношении хранения данных эту проблему можно полностью инкапсули-

ровать и отделить от бизнес-правил . Да, нам нужно, чтобы данные быстро 

перемещались из хранилища и в хранилище, но это низкоуровневая про-

блема . Ее можно решить с помощью низкоуровневых механизмов доступа 

к данным . И она не имеет ничего общего с архитектурой системы .

История

В конце 1980-х годов я возглавлял команду разработчиков программного 

обеспечения в начинающей компании, которая пыталась создать и продать 

систему управления сетью, оценивавшую целостность телекоммуникацион-

ных линий T1 . Система извлекала данные из устройств в конечных точках 

этих линий, а затем запускала ряд алгоритмов для обнаружения проблем .

Мы использовали платформы UNIX и хранили наши данные в простых 

файлах . Нам не нужна была реляционная база данных, потому что наши 

данные были слабо связаны между собой . Намного удобнее было хранить 

их в простых файлах, в виде деревьев и связных списков . Короче говоря, мы 

хранили данные в форме, упрощающей их загрузку в ОЗУ .

Мы наняли специалиста по маркетингу — хорошего знающего парня . Но 

он тут же заявил, что в нашей системе должна иметься реляционная база 

История      271

данных . Этого не требовалось для нормальной работы, и это не было техни-

ческой проблемой — это была проблема маркетинга .

Для меня это было бессмысленно . Почему я должен превращать связные 

списки и деревья в кучу записей и таблиц, доступных через SQL? Почему 

я должен вводить накладные расходы и тратить деньги на приобретение 

массивной СУРБД, если простых файлов более чем достаточно? Поэтому 

я вступил в сражение с ним, пустив в ход зубы и когти .

В этой компании работал один инженер-электронщик, который направо 

и налево расхваливал СУРБД . Он имел свое, техническое обоснование 

необходимости СУРБД в нашей системе . За моей спиной он встретился 

с руководством компании, нарисовал изображение дома на шесте и спросил 

у руководства: «Хотели бы вы жить в доме на шесте?» Его посыл был прост: 

он считал, что СУРБД, хранящая таблицы в файлах, надежнее простых 

файлов, которые мы использовали .

Я боролся с ним . Я боролся с маркетологом . Я придерживался своих тех-

нических принципов перед лицом невероятного невежества . Я боролся, 

боролся и боролся .

В конце концов электронщик пошел на повышение и стал руководителем 

отдела программного обеспечения . Они втиснули СУРБД в эту несчастную 

систему . И в результате они оказались абсолютно правы, а я ошибался .

Нет, с технической точки зрения, заметьте, я был прав . Я был прав, что 

боролся с внедрением СУРБД в архитектурное ядро системы . Но я был не 

прав, потому что клиенты ожидали получить реляционную базу данных 

в нашей системе . Они не знали, что с ней делать . Они не представляли, 

как использовать реляционные данные из нее . Но это не имело значения: 

клиенты рассчитывали получить СУРБД . Она была галочкой, которую все 

покупатели программного обеспечения ставили в своих списках . Не было 

никакого технического обоснования — рациональность здесь вообще была 

ни при чем . Это была иррациональная, внешняя и полностью необоснован-

ная потребность, но это не делало ее менее реальной .

Откуда это взялось? Причина кроется в высокоэффективных маркетин-

говых кампаниях, широко проводимых производителями баз данных в то 

время . Им удалось убедить высокопоставленных руководителей, что их 

корпоративные «активы данных» нуждаются в защите, а предлагаемые ими 

системы баз данных являются идеальным средством такой защиты .

272   Глава 30. База данных — это деталь

Ныне мы наблюдаем похожие маркетинговые кампании . Слово «корпора-

тивный» и понятие «сервис-ориентированная архитектура» имеют больше 

общего с маркетингом, чем с реальностью .

Что я должен был сделать в описанной ситуации? Я должен был прикрутить 

СУРБД к системе и дать ей узкий и безопасный канал доступа к данным, 

сохранив в ядре системы простые файлы . А что я сделал? Я ушел и стал 

консультантом .

Заключение

Организационная структура и модель данных являются архитектурно зна-

чимыми, а технологии и системы, перемещающие данные на вращающуюся 

магнитную поверхность, — нет . Системы реляционных баз данных, которые 

заставляют организовывать данные в таблицы и обращаться к ним посред-

ством SQL, имеют гораздо больше общего с последними, чем с первыми . 

Данные — значимы, а база данных — это деталь .

31 Веб — это деталь

274   Глава 31. Веб — это деталь

Вы занимались разработкой в 1990-х годах? Помните, как Всемирная пау-

тина изменила все вокруг? Помните, с каким презрением мы смотрели на 

наши старые архитектуры клиент/сервер перед лицом новой сверкающей 

технологии «Веб»?

На самом деле Веб ничего не изменил . По крайней мере не должен был ни-

чего изменить . Веб — это всего лишь последнее из последовательности ко-

лебаний, которые наша индустрия пережила с 1960-х годов . Эти колебания 

заставляют переносить всю вычислительную мощность то на центральные 

серверы, то на терминалы .

Только за последние десять лет (или около того), пока Веб занял заметное 

место, мы видели несколько таких колебаний . Сначала мы думали, что вся 

вычислительная мощность будет сосредоточена в фермах серверов, а бра-

узеры будут просто отображать информацию . Затем мы начали добавлять 

апплеты в браузеры . Но нам это не понравилось, поэтому мы переместили 

динамическое содержимое обратно на серверы . Но это нам тоже не понра-

вилось, и мы изобрели Веб 2 .0, переместив почти всю обработку обратно 

в браузер, используя для этого Ajax и JavaScript . Мы зашли так далеко, что 

создали целые приложения, выполняющиеся в браузерах . И теперь мы снова 

возбуждены перемещением JavaScript обратно на сервер в виде Node .

(Вздох .)

Бесконечный маятник

Конечно, было бы неправильно думать, что колебания начались с появле-

нием Веб . До Веб существовала архитектура клиент/сервер . До этого были 

центральные мини-компьютеры с массивами неинтеллектуальных терми-

налов . До этого были мейнфреймы с интеллектуальными терминалами 

(зеленого свечения, которые были очень похожи на современные браузеры) . 

До этого были машинные залы и перфокарты . . .

Так выглядит история . Мы никак не можем определить, где должна быть 

сосредоточена вычислительная мощность . Мы все время то централизуем 

ее, то распределяем . И я думаю, что эти колебания будут еще продолжаться 

в течение какого-то времени .

С точки зрения истории развития информационных технологий Веб во-

обще ничего не изменил . Это просто одно из множества колебаний, которые 

начались еще до того, как многие из нас появились на свет, и продолжатся 

после того, как многие из нас уйдут на пенсию .

Бесконечный маятник      275

Однако как архитекторы мы должны быть нацелены на долгосрочную пер-

спективу . Эти колебания — лишь кратковременные проблемы, которые не 

должны проникать в центральное ядро с нашими бизнес-правилами .

Я хочу рассказать вам одну историю о компании Q . Компания Q создала 

очень популярную систему управления персональными финансами . Это 

было приложение для настольного компьютера с очень удобным графиче-

ским интерфейсом . Мне нравилось пользоваться им .

Затем появился Веб . В следующей версии системы компания Q изменила 

пользовательский интерфейс — он стал выглядеть и действовать подобно 

веб-интерфейсу в браузере . Я был в шоке! Какой гений маркетинга решил, 

что программа управления персональными финансами, действующая на 

настольном компьютере, должна выглядеть как веб-браузер?

Конечно, я возненавидел новый интерфейс . Все остальные, видимо, тоже, 

потому что после выпуска нескольких версий компания Q отказалась от 

внешнего вида, напоминающего браузер, и вернула системе графический 

интерфейс обычного настольного приложения .

Теперь представьте, что в ту пору вы работали программным архитектором 

в Q . Вообразите, что какой-то гений от маркетинга убеждает высшее ру-

ководство в необходимости переделать весь пользовательский интерфейс, 

чтобы он напоминал веб-интерфейс . Что бы вы сделали? Точнее, что вы 

должны были бы сделать до этого момента, чтобы защитить приложение от 

этого гения маркетинга?

Вы должны были бы отделить бизнес-правила от пользовательского интер-

фейса . Я не знаю, как поступили архитекторы в Q . Я хотел бы когда-нибудь 

услышать их рассказ . Если бы в то время я работал там, я бы точно изоли-

ровал бизнес-правила от пользовательского интерфейса, потому что никто 

не знает, что взбредет в голову гениям маркетинга в следующий раз .

Теперь рассмотрим пример с компанией A, выпускающей замечательные 

смартфоны . Недавно она выпустила обновленную версию своей «операци-

онной системы» (это так необычно — говорить об операционной системе 

внутри телефона) . Кроме всего прочего модернизация кардинально измени-

ла внешний вид всех приложений . Зачем? Я полагаю, что вновь не обошлось 

без какого-то гения маркетинга .

Я не эксперт по программному обеспечению в этих устройствах, поэтому не 

знаю, вызвали ли эти изменения какие-либо трудности для программистов 

приложений, выполняющихся на смартфонах компании A . Я надеюсь, что 

архитекторы в A и архитекторы приложений изолировали бизнес-правила 

276   Глава 31. Веб — это деталь

и пользовательский интерфейс друг от друга, потому что всегда найдутся 

гении маркетинга, которые только и ждут, чтобы наброситься на что-то, 

созданное вами.

Вывод

Вывод из всего вышесказанного прост: пользовательский интерфейс — это 

деталь. Веб — это пользовательский интерфейс. То есть Веб — это деталь. 

И как архитектор вы должны размещать детали, как эта, за границами, от-

деляющими их от основной бизнес-логики.

Подумайте об этом с такой позиции: Веб — это устройство ввода/вывода. 

Еще в 1960-х годах мы поняли ценность методики создания приложений, 

не зависящих от устройств ввода/вывода. Побудительные мотивы такой 

независимости не изменились. Веб не является исключением из этого 

правила.

Или я не прав? Можно утверждать, что графический интерфейс, как и Веб, 

настолько уникален и богат, что абсурдно продолжать создавать архи-

тектуры, независимые от устройства. Когда вы думаете о тонкостях про-

верки входных данных на JavaScript, особенностях технологии «перета-

щил и бросил» в AJAX или о том, какие еще виджеты/гаджеты вставить 

в веб-страницу, легко можно скатиться до утверждения, что независимость 

устройства непрактична.

Все это верно до определенной степени. Взаимодействия приложения 

с пользовательским интерфейсом обширны, многообразны и порой очень 

специфичны для данного интерфейса. Веб-приложение и веб-браузер 

взаимодействуют совершенно иначе, чем настольное приложение и гра-

фический интерфейс. Попытка абстрагироваться от этих взаимодействий, 

подобно тому, как в UNIX абстрагируются устройства, выглядит неверо-

ятной.

Но границу между пользовательским интерфейсом и приложением можно 

абстрагировать. Бизнес-логику можно рассматривать как набор вариантов 

использования, каждый из которых выполняет некоторую функцию от 

имени пользователя. Каждый вариант использования можно описать как 

комплекс входных данных, выполняемую обработку и комплекс выходных 

данных.

В какой-то момент в череде взаимодействий пользовательского интерфейса 

и приложения подготовка входных данных будет закончена и появится воз-

Заключение      277

можность выполнить вариант использования . По завершении полученные 

данные можно вернуть обратно, включив их во взаимодействия между 

пользовательским интерфейсом и приложением .

Входные и выходные данные можно поместить в структуры и использовать 

как входные и выходные значения для процесса, выполняющего вариант 

использования . При таком подходе можно считать, что каждый вариант ис-

пользования работает с пользовательским интерфейсом как с устройством 

ввода/вывода независимо от этого устройства .

Заключение

Достичь такой абстракции очень непросто, и, скорее всего, потребуется не-

сколько итераций, чтобы достичь желаемого результата . Но это возможно . 

А поскольку мир полон гениев от маркетинга, это не самое сложное, потому 

что часто бывает необходимо .

32

Фреймворки — 

это деталь

Неравный брак      279

Фреймворки обрели большую популярность . Вообще говоря, это хорошая 

штука . Существует много бесплатных, мощных и полезных фреймворков .

Но фреймворки не определяют архитектуру, хотя некоторые пытаются .

Авторы фреймворков

Большинство авторов фреймворков предлагают результаты своего труда 

бесплатно, потому что хотят быть полезными для сообщества . Они хотят 

внести свой вклад . Это похвально . Однако, независимо от благородства 

мотивов, авторы не думают о ваших интересах . И не могут думать, потому 

что они не знают ни вас, ни ваших проблем .

Но они знают свои проблемы и проблемы своих коллег и друзей . И они 

пишут свои фреймворки для решения этих проблем, а не ваших .

Конечно, ваши проблемы, скорее всего, частично будут совпадать с этими 

другими проблемами . Иначе фреймворки не были бы столь популярны . 

Поэтому фреймворки могут быть очень полезными — в той мере, в какой 

существует совпадение .

Неравный брак

Отношения между вами и автором фреймворка чрезвычайно асимметричны . 

Вы должны обладать огромной приверженностью фреймворку, но его автор 

не несет никаких обязательств перед вами .

Задумайтесь над этим . Когда вы используете фреймворк, вы читаете до-

кументацию, предоставленную его автором . В этой документации автор 

и другие пользователи фреймворка рассказывают вам, как интегрировать 

ваше программное обеспечение с фреймворком . Обычно это означает, что 

вы должны обернуть фреймворк своей архитектурой . Автор рекомендует 

использовать базовые классы и импортировать инструменты фреймворка 

в свои бизнес-объекты . Автор настоятельно рекомендует вам привязать 

ваше приложение к фреймворку настолько, насколько это возможно .

Для автора тесная связь с его собственным фреймворком не является про-

блемой . Для автора такая связь желательна, потому что он обладает абсо-

лютным контролем над этим фреймворком .

Более того, автор хочет привязать вас к фреймворку, потому что, привя-

завшись, будет очень трудно отвязаться . Ничто не подтверждает авторитет 

280   Глава 32. Фреймворки — это деталь

автора так, как группа пользователей, готовых порождать свои классы на 

основе базовых классов автора .

Фактически автор предлагает вам вступить в союз с фреймворком — вы-

разить ему большую и долговременную приверженность . Но при этом сам 

автор ни при каких обстоятельствах не выражает ответной приверженности 

вам . Это однонаправленный союз . Вы принимаете на себя все риски и не-

удобства; автор фреймворка не берет на себя ничего .

Риски

Какие риски, спросите вы? Вот лишь некоторые из них .

 

� Часто архитектура фреймворков не отличается особой чистотой . Фрейм-

воркам свойственно нарушать правило зависимости . Авторы предлагают 

вам наследовать их код в ваших бизнес-объектах — ваших сущностях! 

Они хотят внедрить свои фреймворки в самый внутренний круг . Как 

только это произойдет, убрать фреймворк оттуда будет почти невозмож-

но . Надев обручальное кольцо на палец, он останется жить там .

 

� Фреймворк может помочь с реализацией первых возможностей при-

ложения . Однако, достигнув некоторого уровня зрелости, ваш продукт 

перерастет фреймворк . Если вы надели это обручальное кольцо, то 

со временем заметите, что вам все чаще и чаще приходится бороться 

с фреймворком .

 

� Фреймворк может развиваться в направлении, бесполезном для вас . Вы 

можете столкнуться с необходимостью обновления до следующей версии, 

не несущей ничего, что могло бы пригодиться вам . Вы можете даже об-

наружить, что старые особенности, которыми вы пользовались, исчезают 

или изменяются так, что вам трудно поспевать за ними .

 

� Может появиться новый, более удачный фреймворк, на который вы за-

хотите перейти .

Решение

И каково решение?

Не заключать союзов с фреймворками!

О, вы можете использовать фреймворк — просто не привязывайтесь к нему . 

Держите его на расстоянии вытянутой руки . Рассматривайте фреймворк 

Заключение      281

как деталь, принадлежащую одному из внешних кругов архитектуры . Не 

впускайте его во внутренние круги .

Если фреймворк предложит вам породить свои бизнес-объекты от его 

базовых классов, скажите «нет»! Определите прокси-классы и держите их 

в компонентах, являющихся плагинами для ваших бизнес-правил .

Не позволяйте фреймворкам проникать в ваш основной код . Внедряйте их 

в компоненты, которые лишь подключаются к вашему основному коду, как 

того требует правило зависимости .

Например, возможно, вам нравится Spring — хороший фреймворк внедрения 

зависимостей . Возможно, вы используете Spring для автоматического вне-

дрения своих зависимостей . Это замечательно, но вы не должны окроплять 

аннотациями @autowired свои бизнес-объекты . Бизнес-объекты не должны 

знать о существовании Spring .

Но вы с успехом можете использовать Spring для внедрения зависимостей 

в своем компоненте Main . Этот компонент может знать о фреймворке Spring, 

потому что он является самым грязным и самым низкоуровневым компо-

нентом в системе .

Объявляю вас

Есть некоторые фреймворки, с которыми вы просто обязаны вступить 

в союз . Если, например, вы пишете на C++, вам почти наверняка придется 

вступить в союз с STL — избежать этого очень сложно . Если вы пишете на 

Java, вы будете вынуждены вступить в союз со стандартной библиотекой .

Это нормально — но все равно это должно быть осознанное решение . Вы 

должны понимать, что, заключив союз между фреймворком и вашим при-

ложением, вам придется придерживаться этого фреймворка в течение всего 

жизненного цикла этого приложения . В радости и в горе, в болезни и в здо-

ровье, в богатстве и в бедности, отказавшись от всех остальных, вы будете 

использовать этот фреймворк . Этот шаг нельзя делать по легкомыслию .

Заключение

Встретившись с фреймворком, не торопитесь вступать с ним в союз . По-

смотрите, есть ли возможность отложить решение . Если это возможно, 

удерживайте фреймворк за архитектурными границами . Может быть, вам 

удастся найти способ получить молоко, не покупая корову .

33

Практический пример: 

продажа видео

Анализ вариантов использования      283

Теперь самое время объединить изученные нами правила и принципы 

создания архитектур и применить их для реализации учебного примера . 

Пример будет коротким и простым, но его будет вполне достаточно, чтобы 

продемонстрировать процесс, которому следует хороший архитектор, и при-

нимаемые им решения .

Продукт

Для этого примера я выбрал продукт, с которым довольно близко знаком: 

программное обеспечение для веб-сайта, продающего видеоматериалы . 

Да, он напоминает cleancoders.com — сайт, где я продаю свои обучающие 

видеофильмы .

Основная идея проста . У нас есть партия видеофильмов, которые требуется 

продать . Мы продаем их через Веб физическим лицам и компаниям . Физи-

ческие лица могут заплатить одну, более низкую, цену за потоковое видео, 

или другую, более высокую, за загрузку копий и их постоянное использо-

вание . Бизнес-лицензии распространяются только на потоковую доставку 

и приобретаются партиями, что позволяет предоставлять скидки .

Физические лица обычно выступают в роли зрителей или покупателей . 

В компаниях, напротив, есть люди, которые покупают видеофильмы для 

просмотра другими .

Авторы видеофильмов должны предоставлять свои видеофайлы, сопрово-

ждая их описанием и вспомогательными файлами с контрольными вопро-

сами, решениями, исходным кодом и другими материалами .

Администраторам необходимо добавлять новые видеоролики, добавлять 

видеоролики в серию и удалять их, а также устанавливать цены на различ-

ные лицензии .

Администраторы должны добавлять коллекции видеофильмов, удалять 

коллекции и устанавливать цены на различные лицензии .

Наш первый шаг в определении начальной архитектуры системы — выяв-

ление действующих лиц и вариантов использования .

Анализ вариантов использования

На рис . 33 .1 изображена схема типичного анализа вариантов использо-

вания .

284   Глава 33. Практический пример: продажа видео

Автор

Покупатель

Зритель

Администратор

Отправляет

файл MP4

Покупает

лицензию

на загрузку

копии

Покупает

бизнес-лицензию

Просматривает

каталог

как покупатель

Просматривает

каталог

как зритель

Просматривает

потоковое

видео

Загружает

видеофильм

Покупает

лицензию

Просмотр

каталога

Добавляет

новые

коллекции

Публикует

видеофильмы

из коллекций

Удаляет

видеофильмы

из коллекций

Устанавливает

цены

на лицензии

Отправляет

контрольные

вопросы

Отправляет

описание

видеофильма

Покупает

лицензию

на просмотр

потокового

видео

Рис. 33.1. Типичный анализ вариантов использования

На этой схеме изображены четыре действующих лица . В соответствии 

с принципом единственной ответственности, эти четыре действующих лица 

станут основными источниками изменений для системы . Добавление любых 

новых возможностей или изменение существующих будет выполняться ради 

обслуживания одного из действующих лиц . Поэтому мы должны разбить 

систему так, чтобы изменения, предназначенные для одного действующего 

лица, не затрагивали других .

На рис . 33 .1 изображены не все варианты использования . Например, на схе-

ме отсутствуют варианты, отвечающие за вход и выход . Это сделано специ-

ально, чтобы упростить задачу и ограничить ее размер . Если бы я включил 

все возможные варианты использования, эта глава могла бы превратиться 

в самостоятельную книгу .

Компонентная архитектура      285

Обратите внимание на варианты использования в центре на рис . 33 .1, заклю-

ченные в пунктирные рамки . Это абстрактные1 варианты использования . 

Абстрактным называется такой вариант использования, который определяет 

общую политику для других вариантов использования . Как видите, абстракт-

ный вариант использования Просмотр каталога наследуют варианты Про-

сматривает каталог как зритель и Просматривает каталог как покупатель .

С одной стороны, эту абстракцию можно было не создавать . Я мог бы убрать 

абстрактный вариант использования из схемы без ущерба для каких-либо 

особенностей продукта . С другой стороны, эти два варианта использования 

настолько похожи, что я счел разумным признать сходство и найти способ 

унифицировать его с самого начала .

Компонентная архитектура

Теперь, когда известны действующие лица и варианты использования, мож-

но создать предварительную компонентную архитектуру (рис . 33 .2) .

Представ-

ления

для админист-

ратора

Презентаторы

для админист-

ратора

Интеракторы 

для админист-

ратора

Контроллеры 

для админист-

ратора

Представ-

ления 

для автора

Презента-

торы 

для автора

Интеракторы 

для автора

Контроллеры 

для автора

Презентаторы 

для 

покупателя

Интеракторы 

для 

покупателя

Контроллеры 

для 

покупателя

Представ-

ление 

каталога

Презентатор 

каталога

Представ-

ления 

для зрителя

Презентаторы 

для зрителя

Интеракторы 

для зрителя

Контроллеры 

для зрителя

Шлюзы для 

поступления 

доходов

Шлюзы 

для данных

База данных 

(Datomic)

Представ-

ления для 

покупателя

Рис. 33.2. Предварительная компонентная архитектура

1 Это мой собственный стиль выделения абстрактных вариантов использования . Я мог 

бы использовать более стандартный UML-стереотип, такой как <<abstract>>, но в дан-

ный момент я не считаю полезным следовать таким стандартам .

286   Глава 33. Практический пример: продажа видео

Двойными линиями, как обычно, изображены архитектурные границы . Как 

видите, это типичное деление на представления, презентаторы, интеракторы 

и контроллеры . Также отметьте, что каждую из этих категорий я разбил на 

подкатегории по соответствующим им действующим лицам .

Каждый компонент на рис . 33 .2 потенциально представляет файл .jar или 

.dll и каждый будет содержать соответствующие представления, презента-

торы, интеракторы и контроллеры .

Обратите внимание на особые компоненты Представление каталога и Пре-

зентатор каталога . Именно так предполагается реализовать абстрактный 

вариант использования Просмотр каталога . Я предполагаю, что такие пред-

ставления и презентаторы будут иметь вид абстрактных классов, которые 

будут наследовать конкретные классы представлений и презентаторов 

в производных компонентах .

Стал бы я действительно разбивать систему на все эти компоненты и органи-

зовывать их в файлы .jar или .dll? И да и нет . Конечно, я мог бы помудрить 

над компиляцией и настроить окружение так, чтобы действительно можно 

было создавать компоненты, развертываемые независимо . Также я мог бы 

оставить за собой право объединить компоненты, чтобы при необходимости 

получить меньшее количество единиц развертывания . Например, компонен-

ты, изображенные на рис . 33 .2, легко можно объединить в пять файлов .jar — 

по одному для представлений, презентаторов, интеракторов, контроллеров 

и утилит соответственно . В этом случае я мог развертывать компоненты, 

которые, скорее всего, будут меняться независимо друг от друга .

Еще один возможный вариант группировки: объединить представления 

и презентаторы в один файл .jar, а интеракторы, контроллеры и утилиты 

поместить в свои, отдельные файлы . Другой, еще более простой вариант 

группировки: создать два файла .jar — один с представлениями и презен-

таторами и другой со всем остальным .

Оставив эти возможности открытыми, позже мы сможем изменить способ 

развертывания системы, исходя из особенностей ее развития .

Управление зависимостями

Поток управления на рис . 33 .2 движется справа налево . Входные данные 

поступают в контроллеры и затем обрабатываются интеракторами . Презен-

таторы форматируют результаты обработки и передают их представлениям 

для отображения .

Заключение      287

Обратите внимание, что не все стрелки направлены справа налево . Факти-

чески большинство из них направлено слева направо . Это объясняется тем, 

что архитектура следует правилу зависимости . Все зависимости пересекают 

архитектурные границы в одном направлении и всегда направлены в сторо-

ну компонентов, содержащих политики более высокого уровня .

Также отметьте, что отношения использования (открытые стрелки) со-

впадают с направлением потока управления, а отношения наследования 

(закрытые стрелки) направлены против потока управления . Это отражает 

использование принципа открытости/закрытости, который требует, чтобы 

зависимости были направлены в правильном направлении и изменения 

в низкоуровневых деталях не затрагивали высокоуровневые политики .

Заключение

Диаграмма архитектуры на рис . 33 .2 включает разделение по двум измере-

ниям . Первое — разделение на основе действующих лиц согласно принципу 

единственной ответственности; второе соответствует правилу зависимости . 

Цель обоих — разделить компоненты, изменяющиеся по разным причинам 

и с разной скоростью . Причины в данном случае соответствуют действую-

щим лицам, а скорости — разным уровням политик .

После структуризации кода таким способом появляется возможность сме-

шивать и распределять его по единицам развертывания как угодно . Вы смо-

жете группировать компоненты в любые единицы развертывания, имеющие 

смысл, и менять правила группировки с изменением условий .

34 Недостающая глава

Автор: Симон Браун (Simon Brown), 2 марта 2017

Упаковка по уровням      289

Все советы, которые вы прочитали к настоящему моменту, безусловно, по-

могут вам проектировать замечательные приложения, состоящие из классов 

и компонентов с четко определенными границами, понятными обязан-

ностями и управляемыми зависимостями . Но как всегда, дьявол кроется 

в деталях реализации, и действительно, очень легко споткнуться о последнее 

препятствие, если не уделить ему должного внимания .

Представим, что мы строим книжный онлайн-магазин и один из вариантов 

использования, который нам предлагается внедрить, — возможность про-

смотра клиентами состояния своих заказов . Пример, следующий ниже, 

описывается с позиции языка Java, однако принципы в равной степени 

применимы к другим языкам программирования . Отложим пока чистую 

архитектуру в сторону и рассмотрим не-

сколько подходов к проектированию и ор-

ганизации кода .

Упаковка по уровням

Первый и самый простой, пожалуй, под-

ход — организация традиционной много-

уровневой архитектуры, в которой код раз-

деляется по функциональному признаку . 

Этот подход часто называют «упаковкой по 

уровням» . На рис . 34 .1 показано, как мог-

ла бы выглядеть соответствующая UML-

диаграмма классов .

В такой типичной многоуровневой архи-

тектуре один уровень выделяется для веб-

кода, один уровень — для «бизнес-логики» 

и один уровень — для работы с хранилищем 

данных . Иными словами, горизонтальные 

уровни используются как способ груп-

пировки по подобию . В «строгой много-

уровневой архитектуре» уровни должны 

зависеть только от следующего смежного 

уровня . В Java уровни обычно реализуются 

в виде пакетов . Как показано на рис . 34 .1, 

все зависимости между уровнями (пакета-

ми) направлены вниз . В этом примере у нас 

имеются следующие Java-типы:

<<использует>>

<<использует>>

<<интерфейс>>

<<интерфейс>>

Рис. 34.1. Упаковка по уровням

290   Глава 34. Недостающая глава

 

� OrdersController: веб-контроллер, иногда что-то вроде MVC-контроллера 

из Spring, обрабатывающего запросы из Веб .

 

� OrdersService: интерфейс, определяющий «бизнес-логику», связанную 

с заказами .

 

� OrdersServiceImpl: реализация службы заказов1 .

 

� OrdersRepository: интерфейс, определяющий порядок доступа к инфор-

мации о заказах в хранилище .

 

� JdbcOrdersRepository: реализация интерфейса хранилища .

В своей статье Presentation Domain Data Layering2 («Многоуровневая 

организация: представление, бизнес-логика, данные») Мартин Фаулер 

написал, что такая трехуровневая организация отлично подходит для на-

чального этапа . И он не одинок . Во многих книгах, руководствах, курсах 

и примерах кода демонстрируются способы создания многоуровневой 

архитектуры . Это очень быстрый способ без особых затруднений создать 

и запустить что-то . Проблема, как указывает Мартин, в том, что с ростом 

масштаба и сложности программного обеспечения трех больших слоев 

кода оказывается недостаточно и приходится задумываться о более дроб-

ной организации .

Другая проблема, как уже сказал «дядюшка Боб»3, — многоуровневая архи-

тектура не кричит о своем практическом назначении . Поместите рядом код 

двух многоуровневых архитектур из разных предметных областей, и они 

почти наверняка будут выглядеть пугающе похожими: веб-интерфейсы, 

службы и хранилища . Многоуровневые архитектуры страдают еще от одного 

большого недостатка, но мы поговорим о нем позже .

Упаковка по особенностям

Другой вариант организации кода — «упаковка по особенностям» . Это 

разделение по вертикали, основанное на объединении связанных особен-

ностей, предметных понятий и общих корней (если использовать терми-

нологию предметно-ориентированного проектирования) . В типичных 

реализациях, которые мне доводилось видеть, все типы помещаются в один 

1 Это ужасное имя для класса, но, как будет показано ниже, в действительности это не 

имеет большого значения .

2 https://martinfowler.com/bliki/PresentationDomainDataLayering.html .

3 Псевдоним «дядюшка Боб» (Uncle Bob) принадлежит автору этой книги Роберту 

Мартину . — Примеч. пер.

Порты и адаптеры      291

Java-пакет, имя которого отражает идею 

группировки .

</p>
   </article>
</body>
</html>
