<!DOCTYPE html><html lang="ru"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>book</title></head><body>взаимодействующими по сети .

Многие архитекторы называют такие компоненты «службами» или «микро-

службами», в зависимости от некоторого неопределенного понятия величи-

ны . Архитектуру, основанную на службах (или сервисах), часто называют 

сервис-ориентированной архитектурой .

Возможность независимого развертывания      161

Если в ответ на увиденные термины в вашей голове зазвенел звоночек, не 

волнуйтесь . Я не собираюсь убеждать вас, что SOA1 — лучшая из возможных 

архитектур или что за микрослужбами будущее . Я лишь хотел отметить, 

что иногда мы должны разделять свои компоненты вплоть до создания от-

дельных служб .

Помните, что хорошая архитектура оставляет возможности открытыми . 

Режим разделения — одна из таких возможностей.

Прежде чем продолжить обсуждение этой темы, рассмотрим два других 

пункта .

Возможность независимой разработки

В третьем пункте, в начале главы, говорилось о простоте разработки . Оче-

видно, что полное разделение компонентов ослабляет взаимовлияние 

 команд разработчиков . Если бизнес-правила никак не зависят от пользо-

вательского интерфейса, тогда команда, занятая его разработкой, едва ли 

сможет как-то помешать команде, занятой реализацией бизнес-правил . Если 

варианты использования отделены друг от друга, тогда команда, сосредо-

точенная на реализации варианта addOrder, не сможет помешать команде, 

сосредоточенной на варианте deleteOrder .

Архитектура системы, разделенная на уровни и варианты, будет поддер-

живать любую организацию команд, по какому бы признаку они ни были 

организованы — функциональному, по компонентам, по уровням или как-то 

иначе .

Возможность независимого 

развертывания

Разделение на уровни и варианты использования помогает также добиться 

максимальной гибкости при развертывании . Фактически при эффективном 

разделении должна открываться возможность «горячей» замены уровней 

и вариантов использования в действующей системе . Добавление нового 

варианта использования может заключаться в простом копировании не-

скольких jar-файлов или служб, без влияния на что-то другое .

1 SOA (Service-Oriented Architecture): сервис-ориентированная архитектура . — Примеч. 

пер.

162   Глава 16. Независимость

Дублирование

Архитекторы часто попадают в ловушку, зависящую от их страха перед 

дублированием .

Вообще в программном обеспечении считается, что дублирования следует 

избегать . Мы стараемся предотвратить дублирование программного кода . 

Когда обнаруживается действительно повторяющийся код, мы с благогове-

нием смотрим, как профессионалы устраняют его .

Но есть разные виды дублирования . Есть истинное дублирование, когда лю-

бое изменение в одной копии требует того же изменения во всех остальных 

копиях . А есть ложное или случайное дублирование . Если два фрагмента 

кода, кажущиеся одинаковыми, развиваются разными путями — если они 

изменяются с разной скоростью и по разным причинам — этот случай не 

является истинным дублированием . Вернитесь к ним через несколько лет, 

и вы увидите, что они совершенно не похожи друг на друга .

Теперь представьте два варианта использования, одинаково отображаю-

щиеся на экране . Многие архитекторы будут испытывать непреодолимое 

желание использовать общую реализацию отображения . Но правы ли они? 

Действительно ли это истинное дублирование? Или сходство получилось 

случайным?

Скорее всего, это случайность . С течением времени эти два экрана будут 

приобретать все больше и больше различий и, наконец, будут выглядеть со-

вершенно непохоже . По этой причине желательно избежать их объединения . 

Иначе потом разделить их будет очень сложно .

В процессе создания вертикального деления на варианты использования 

могут возникать проблемы и желание объединить какие-то варианты со 

схожими отображениями на экране, или алгоритмами, или запросами к базе 

данных и/или схемами . Будьте осторожны . Сопротивляйтесь рефлекторно-

му желанию устранить дублирование . Убедитесь прежде, что дублирование 

действительно истинное .

Точно так же, выполняя горизонтальное деление на уровни, можно заметить, 

что структура данных в какой-то записи в базе данных очень похожа на 

структуру данных в экранной форме . В результате может возникнуть жела-

ние просто передать запись из базы данных в пользовательский интерфейс, 

не создавая промежуточную модель представления, которая, казалось бы, 

просто копирует элементы . Будьте осторожны: эта схожесть почти всегда 

оказывается случайной . Создание отдельной модели представления не тре-

бует много усилий и поможет вам правильно отделить уровни .

Режимы разделения (еще раз)      163

Режимы разделения (еще раз)

Вернемся к режимам . Существует много разных способов деления на уровни 

и варианты использования . Деление можно выполнить на уровне исходного 

кода, на уровне двоичного кода (развертывания) и на уровне единиц вы-

полнения (служб) .

 

� Уровень исходного кода . Мы можем так настроить зависимости между 

модулями с исходным кодом, чтобы изменения в одном модуле не вы-

нуждали производить изменения в других (например, Ruby Gems) .

При использовании этого режима разделения все компоненты выполня-

ются в общем адресном пространстве и взаимодействуют, просто вызывая 

функции друг друга . То есть имеется единственный выполняемый файл, 

загружаемый в память компьютера . Люди часто называют это монолит-

ной структурой .

 

� Уровень развертывания . Мы можем так настроить зависимости между 

единицами развертывания, jar-файлами или динамически загружаемыми 

библиотеками, чтобы изменения в исходном коде в одном модуле не вы-

нуждали производить повторную сборку и развертывание других .

Многие компоненты могут находиться в общем адресном пространстве 

и взаимодействовать, вызывая функции друг друга . Другие компоненты 

могут выполняться в других процессах на той же машине и взаимодей-

ствовать посредством механизмов межпроцессных взаимодействий, 
</body></html>