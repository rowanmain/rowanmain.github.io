<!DOCTYPE html><html lang="ru"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>book</title></head><body>ISR(TIMER1_vect) { ... }

ISR(INT2_vect) { ... }

void btn_Handler(void) { ... }

float calc_RPM(void) { ... }

static char Read_RawData(void) { ... }

void Do_Average(void) { ... }

void Get_Next_Measurement(void) { ... }

void Zero_Sensor_1(void) { ... }

void Zero_Sensor_2(void) { ... }

void Dev_Control(char Activation) { ... }

char Load_FLASH_Setup(void) { ... }

void Save_FLASH_Setup(void) { ... }

void Store_DataSet(void) { ... }

float bytes2float(char bytes[4]) { ... }

void Recall_DataSet(void) { ... }

void Sensor_init(void) { ... }

void uC_Sleep(void) { ... }

1 Фредерик Брукс . Мифический человеко-месяц, или Как создаются программные си-

стемы . СПб .: Символ-Плюс (2007) . — Примеч. пер.

252   Глава 29. Чистая встраиваемая архитектура

В таком порядке функции были объявлены в файле с исходным кодом . 

А теперь разделим их и сгруппируем по решаемым задачам:

 

� функции, реализующие предметную логику:

• float calc_RPM(void) { ... }

• void Do_Average(void) { ... }

• void Get_Next_Measurement(void) { ... }

• void Zero_Sensor_1(void) { ... }

• void Zero_Sensor_2(void) { ... }

 

� функции, обслуживающие аппаратную платформу:

• ISR(TIMER1_vect) { ... }*

• ISR(INT2_vect) { ... }

• void uC_Sleep(void) { ... }

 

� функции, реагирующие на нажатия кнопок:

• void btn_Handler(void) { ... }

• void Dev_Control(char Activation) { ... }

 

� функция, читающая данные из аппаратного аналогово-цифрового пре-

образователя:

• static char Read_RawData(void) { ... }

 

� функции, записывающие значения в долговременное хранилище:

• char Load_FLASH_Setup(void) { ... }

• void Save_FLASH_Setup(void) { ... }

• void Store_DataSet(void) { ... }

• float bytes2float(char bytes[4]) { ... }

• void Recall_DataSet(void) { ... }

 

� функция, которая не делает того, что подразумевает ее имя:

• void Sensor_init(void) { ... }

Заглянув в другие файлы этого приложения, я нашел множество препят-

ствий, мешающих пониманию кода . Также я обнаружил, что организация 

файлов подра зумевает единственный способ тестирования этого кода — 

непосредственно внутри целевого устройства . Практически каждый бит 

этого кода знает, что относится к специализированной микропроцессорной 

Привязка к оборудованию — узкое место      253

архитектуре, используя «расширенные» конструкции языка C1, привязыва-

ющие код к конкретному набору инструментов и микропроцессору . У этого 

кода нет ни малейшего шанса служить долго, если будет решено перенести 

продукт на другую аппаратную платформу .

Приложение работает: инженер прошел тест на профпригодность . Но нельзя 

сказать, что оно имеет чистую встраиваемую архитектуру .

Привязка к оборудованию — 

узкое место

Существует масса особых проблем, с которыми приходится сталкиваться 

разработчикам встраиваемых систем и не знакомых разработчикам обыч-

ного программного обеспечения . Например, ограниченный объем памяти, 

ограничения по времени выполнения операций, ограниченные возмож-

ности ввода/вывода, нетрадиционные пользовательские интерфейсы, 

а также наличие датчиков и контактов, соединяющих с внешним миром . 

В большинстве случаев аппаратное обеспечение развивается параллельно 

с программным обеспечением и микропрограммами . У вас, как инженера, 

разрабатывающего код для такого рода систем, может не быть места для за-

пуска кода . Но это еще не самое худшее — полученное оборудование может 

иметь собственные недостатки, что замедляет разработку программного 

обеспечения больше, чем обычно .

Да, встраиваемое программное обеспечение имеет свои особенности, и ин-

женеры встраиваемых систем — особые люди . Но разработка встраиваемых 

систем не настолько особенная, чтобы принципы, описываемые в этой книге, 

нельзя было применить к встраиваемым системам .

Одна из особых проблем встраиваемых систем — тесная зависимость от 

оборудования . Когда встраиваемый код структурируется без применения 

принципов и приемов чистой архитектуры, часто приходится сталкиваться 

со сценарием, когда код можно протестировать только на целевом обо-

рудовании . Если это оборудование — единственное место, где возможно 

тестирование, такая тесная связь начинает замедлять вас .

1 Некоторые производители микроконтроллеров добавляют свои ключевые слова 

в язык C, чтобы упростить доступ к регистрам и портам из кода на C . К сожалению, 

как только код начинает использовать такие ключевые слова, он перестает быть 

кодом на C .

254   Глава 29. Чистая встраиваемая архитектура

Чистая встраиваемая архитектура — 

архитектура, поддерживающая тестирование

Давайте посмотрим, как применяются некоторые архитектурные принципы 

к встраиваемому программному обеспечению и микропрограммам и как они 

помогают избавиться от тесной привязки к оборудованию .

Уровни

Деление на уровни можно произвести разными способами . Начнем с трех-
</body></html>