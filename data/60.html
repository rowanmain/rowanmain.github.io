<!DOCTYPE html><html lang="ru"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>book</title></head><body>появиться желание создать другие веб-приложения, использующие этот 

веб-компонент . В то же время мы не хотели вынуждать пользователей за-

гружать два компонента . Как вы помните, одна из наших целей выражалась 

фразой «Загрузи и вперед» . Мы специально хотели, чтобы пользователям 

нужно было загрузить и выполнить только один jar-файл, не заботясь о по-

иске других jar-файлов с совместимыми версиями и т . д .

История FitNesse также указывает на одну из опасностей такого подхода . 

Со временем, когда стало ясно, что отдельный веб-компонент никог-

Фасады      217

да не понадобится, грань между веб-компонентом и компонентом вики 

стала размываться . Начали появляться зависимости, пересекающие ли-

нию в  неправильном направлении . Разделить их сейчас было бы очень 

сложно .

Одномерные границы

Для оформления полноценной архитектурной границы требуется создать 

парные пограничные интерфейсы для управления изоляцией в обоих на-

правлениях . Поддержание разделения в обоих направлениях обходится 

дорого не только на начальном этапе, но и на этапе сопровождения .

На рис . 24 .1 показана более простая схема, помогающая зарезервировать 

место для последующего превращения в полноценную границу . Это пример 

традиционного шаблона «Стратегия» . Клиенты пользуются интерфейсом 

ServiceBoundary, который реализуют классы ServiceImpl .

Клиент

Рис. 24.1. Шаблон «Стратегия»

Должно быть ясно, что это создает основу для будущей архитектурной гра-

ницы . Здесь имеет место инверсия зависимости, необходимая для отделения 

клиента от класса ServiceImpl . Также должно быть ясно, что разделение мо-

жет очень быстро стираться, о чем свидетельствует пунктирная стрелка на 

диаграмме . В отсутствие парных интерфейсов ничто не мешает появлению 

таких обратных зависимостей, кроме старательности и дисциплинирован-

ности разработчиков и архитекторов .

Фасады

Еще более простой подход к организации границ дает шаблон «Фасад», 

изображенный на рис . 24 .2 . В этом случае отсутствует даже инверсия зави-

симостей . Граница определяется простым классом Facade c методами, пред-

218   Глава 24. Неполные границы

ставляющими службы и реализующими обращения к службам, к которым 

клиенты, как предполагается, не должны иметь прямого доступа .

Клиент

Служба

Рис. 24.2. Шаблон «Фасад»

Обратите внимание, однако, что клиент имеет транзитивную (переходную) 

зависимость от всех этих классов служб . В языках со статической системой 

типов изменение исходного кода в одном из классов служб вызывает необ-

ходимость повторной компиляции клиента . Также представьте, насколько 

просто в этой схеме создать обратные связи .

Заключение

Мы увидели три простых способа реализации неполных архитектурных 

границ . Конечно, таких способов намного больше . Эти три стратегии служат 

лишь примерами .

Каждый из представленных подходов имеет свои достоинства и недостатки . 

Каждый подходит на роль заменителя полноценной архитектурной границы 

в определенных контекстах . И каждый может со временем деградировать, 

если граница никогда не будет материализована .

Одна из задач архитектора — решить, где провести архитектурную границу 

и как ее реализовать, частично или полностью .

25 Уровни и границы

220   Глава 25. Уровни и границы

В любой системе легко выделить три компонента: пользовательский интер-

фейс, бизнес-правила и базу данных . Для простых систем этого более чем 

достаточно . Но для большинства систем число компонентов должно быть 

больше .

Рассмотрим, например, простую компьютерную игру . В ней легко выделить 

три компонента . Пользовательский интерфейс обрабатывает все сообщения 

от пользователя и передает их правилам игры . Правила сохраняют состо-

яние игры в некоторой хранимой структуре данных . Но действительно ли 

это все, что нужно?

Охота на Вампуса

Давайте немного конкретизируем . Возьмем в качестве примера почтенную 

приключенческую игру «Охота на Вампуса»1, придуманную в 1972 году . 

В этой текстовой игре используются очень простые команды, такие как GO 

EAST (идти быстро) и SHOOT WEST (выстрелить в западном направле-

нии) . Игрок вводит команду, а компьютер в ответ сообщает, что персонаж 

видит, обоняет, слышит и чувствует . Игрок охотится за Вампусом в лаби-

ринте пещер и должен избегать ловушек, ям и других опасностей . Желаю-

щие без труда найдут правила игры в Интернете .

Допустим, мы решили сохранить текстовый интерфейс, но отделить его от 

правил игры, чтобы наша версия могла обрабатывать команды на разных 

языках и распространяться в разных странах . Игровые правила взаимо-

действуют с компонентом пользовательского интерфейса посредством 

прикладного интерфейса, не зависящего от языка, а пользовательский 

интерфейс транслирует команды API на соответствующий естественный 

язык .

При правильной организации зависимостей, как показано на рис . 25 .1, 

можно создать произвольное количество компонентов с пользовательским 

интерфейсом, использующих те же игровые правила . Правила игры ничего 

не знают об используемом естественном языке общения с пользователем .

Допустим также, что состояние игры сохраняется в некотором хранилище — 

это может быть флешка, облачное хранилище или просто ОЗУ . В любом из 

этих случаев игровые правила не должны знать деталей . Поэтому снова мы 

создаем прикладной интерфейс, который игровые правила смогут исполь-

зовать для взаимодействия с компонентом хранилища .

1 https://ru.wikipedia.org/wiki/Hunt_the_Wumpus. — Примеч. пер.

Чистая архитектура?      221

Английский

интерфейс

Испанский

интерфейс

Правила

игры
</body></html>