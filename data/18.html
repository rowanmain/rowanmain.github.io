<!DOCTYPE html><html lang="ru"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>book</title></head><body>ОО, но они сделали его намного надежнее и удобнее .

Проблема явного использования указателей на функции для создания по-

лиморфного поведения в том, что указатели на функции по своей природе 

опасны . Такое их применение оговаривается множеством соглашений . Вы 

должны помнить об этих соглашениях и инициализировать указатели . Вы 

должны помнить об этих соглашениях и вызывать функции посредством 

62   Глава 5. Объектно-ориентированное программирование  

указателей . Если какой-то программист забудет о соглашениях, возникшую 

в результате ошибку будет чертовски трудно отыскать и устранить .

Языки ОО избавляют от необходимости помнить об этих соглашениях и, со-

ответственно, устраняют опасности, связанные с этим . Поддержка полимор-

физма на уровне языка делает его использование тривиально простым . Это 

обстоятельство открывает новые возможности, о которых программисты 

на C могли только мечтать . Отсюда можно заключить, что ОО накладывает 

ограничение на косвенную передачу управления .

Сильные стороны полиморфизма

Какими положительными чертами обладает полиморфизм? Чтобы в пол-

ной мере оценить их, рассмотрим пример программы copy . Что случится 

с программой, если создать новое устройство ввода/вывода? Допустим, 

мы решили использовать программу copy для копирования данных из 

устройства распознавания рукописного текста в устройство синтеза речи: 

что нужно изменить в программе copy, чтобы она смогла работать с новыми 

устройствами?

Самое интересное, что никаких изменений не требуется! В действитель-

ности нам не придется даже перекомпилировать программу copy . Почему? 

Потому что исходный код программы copy не зависит от исходного кода 

драйверов ввода/вывода . Пока драйверы реализуют пять стандартных 

функций, определяемых структурой FILE, программа copy сможет с успехом 

их использовать .

Проще говоря, устройства ввода/вывода превратились в плагины для про-

граммы copy .

Почему операционная система UNIX превратила устройства ввода/выво-

да в плагины? Потому что в конце 1950-х годов мы поняли, что наши про-

граммы не должны зависеть от конкретных устройств . Почему? Потому что 

мы успели написать массу программ, зависящих от устройств, прежде чем 

смогли понять, что в действительности мы хотели бы, чтобы эти программы, 

выполняя свою работу, могли бы использовать разные устройства .

Например, раньше часто писались программы, читавшие исходные данные 

из пакета перфокарт1 и пробивавшие на перфораторе новую стопку пер-

1 Перфокарты IBM Hollerith имели ширину 80 колонок . Я уверен, что многие из вас 

никогда даже не видели их, но они широко были распространены в 1950-е, 1960-е 

и даже в 1970-е годы .

Полиморфизм?      63

фокарт с результатами . Позднее наши клиенты стали передавать исходные 

данные не на перфокартах, а на магнитных лентах . Это было неудобно, по-

тому что приходилось переписывать большие фрагменты первоначальных 

программ . Было бы намного удобнее, если бы та же программа могла рабо-

тать и с перфокартами, и с магнитной лентой .

Для поддержки независимости от устройств ввода/вывода была придумана 

архитектура плагинов и реализована практически во всех операционных 

системах . Но даже после этого большинство программистов не давали рас-

пространения этой идее в своих программах, потому что использование 

указателей на функции было опасно .

Объектно-ориентированная парадигма позволила использовать архитектуру 

плагинов повсеместно .

Инверсия зависимости

Представьте, на что походило программное обеспечение до появления на-

дежного и удобного механизма полиморфизма . В типичном дереве вызовов 

главная функция вызывала функции верхнего уровня, которые вызывали 

функции среднего уровня, в свою очередь, вызывавшие функции нижнего 

уровня . Однако в таком дереве вызовов зависимости исходного кода непре-

клонно следовали за потоком управления (рис . 5 .1) .

Главная

Зависимости

исходного кода

Поток

управления

Рис. 5.1. Зависимости исходного кода следуют за потоком управления

Чтобы вызвать одну из функций верхнего уровня, функция main должна 

сослаться на модуль, содержащий эту функцию . В языке C для этой цели 

64   Глава 5. Объектно-ориентированное программирование  

используется директива #include . В Java — инструкция import . В C# — ин-

струкция using . В действительности любой вызывающий код был вынужден 

ссылаться на модуль, содержащий вызываемый код .

Эти требования предоставляли архитектору программного обеспечения не-

сколько вариантов . Поток управления определяется поведением системы, 

а зависимости исходного кода определяются этим потоком управления .

Однако когда в игру включился полиморфизм, стало возможным нечто со-

вершенно иное (рис . 5 .2) .

Рис. 5.2. Инверсия зависимости

На рис . 5 .2 модуль верхнего уровня HL1 вызывает функцию F() из модуля 

среднего уровня ML1 . Вызов посредством интерфейса является уловкой лишь 

для исходного кода . Во время выполнения интерфейсов не существует . 

 Модуль HL1 просто вызывает F() внутри ML11 .

Но обратите внимание, что направление зависимости в исходном коде (от-

ношение наследования) между ML1 и интерфейсом I поменялось на противо-

положное по отношению к потоку управления . Этот эффект называют 

инверсией зависимости (dependency inversion), и он имеет далеко идущие 

последствия для архитекторов программного обеспечения .

Факт поддержки языками ОО надежного и удобного механизма полимор-

физма означает, что любую зависимость исходного кода, где бы она ни на-

ходилась, можно инвертировать .

Теперь вернемся к дереву вызовов, изображенному на рис . 5 .1, и к множеству 

зависимостей в его исходном коде . Любую из зависимостей в этом исходном 

коде можно обратить, добавив интерфейс .

1 Хотя и косвенно .

Полиморфизм?      65

При таком подходе архитекторы, работающие в системах, которые написа-

ны на объектно-ориентированных языках, получают абсолютный контроль 

над направлением всех зависимостей в исходном коде . Они не ограничены 
</body></html>